//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  MakeFloorSlope
//
//==========================================================================

void MakeFloorSlope(mthing_t * mthing)
{
	sector_t *sec;
	line_t *line;
	int i;

	sec = GLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		if (mthing->tid == line->arg1)
		{
			TVec v1;
			TVec v2;
			TVec p1;
			TVec p2;
			TVec p3;

			p1 = vector(line->v1->x, line->v1->y, sec->floor.minz);
			p2 = vector(line->v2->x, line->v2->y, sec->floor.minz);
			p3 = vector(mthing->x, mthing->y, mthing->height);
			if (PointOnPlaneSide(p3, line) == 0)
			{
				v1 = p2 - p3;
				v2 = p1 - p3;
			}
			else
			{
				v1 = p1 - p3;
				v2 = p2 - p3;
			}
			sec->floor.normal = Normalise(CrossProduct(v1, v2));
			if (sec->floor.normal.z <= 0.0)
			{
				Error("Floor with normal.z <= 0.0");
			}
			sec->floor.dist = DotProduct(sec->floor.normal, p3);
			sec->base_floorheight = sec->floor.dist;
			SendFloorSlope(sec);
			return;
		}
	}
}

//==========================================================================
//
//  MakeCeilingSlope
//
//==========================================================================

void MakeCeilingSlope(mthing_t * mthing)
{
	sector_t *sec;
	line_t *line;
	int i;

	sec = GLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		if (mthing->tid == line->arg1)
		{
			TVec p1;
			TVec p2;
			TVec p3;
			TVec v1;
			TVec v2;

			p1 = vector(line->v1->x, line->v1->y, sec->ceiling.maxz);
			p2 = vector(line->v2->x, line->v2->y, sec->ceiling.maxz);
			p3 = vector(mthing->x, mthing->y, mthing->height);
			if (PointOnPlaneSide(p3, line) == 0)
			{
				v1 = p1 - p3;
				v2 = p2 - p3;
			}
			else
			{
				v1 = p2 - p3;
				v2 = p1 - p3;
			}
			sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
			if (sec->ceiling.normal.z >= 0.0)
			{
				Error("Ceiling with normal.z >= 0.0");
			}
			sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
			sec->base_ceilingheight = sec->ceiling.dist;
			SendCeilingSlope(sec);
			return;
		}
	}
}

//==========================================================================
//
//	SetVertexHeights
//
//==========================================================================

bool SetVertexHeights(int ThingID)
{
	int i;
	int j;
	bool ret;
	mthing_t * mthing;
	
	ret = false;
	//	Clean all
	for (i = 0; i < GLevel.NumVertexes; i++)
	{
		GLevel.Vertexes[i].z = 0.1;
	}
	for (j = 0; j < GLevel.NumThings; j++)
	{
		mthing = &GLevel.Things[j];
		if (mthing->type == ThingID)
		{
			for (i = 0; i < GLevel.NumVertexes; i++)
			{
				if (GLevel.Vertexes[i].x == mthing->x &&
					GLevel.Vertexes[i].y == mthing->y)
				{
					GLevel.Vertexes[i].z = mthing->height;
					ret = true;
				}
			}
		}
	}
	return ret;
}

//==========================================================================
//
//	CleanVertexHeights
//
//==========================================================================

void CleanVertexHeights(void)
{
	int i;
	
	for (i = 0; i < GLevel.NumVertexes; i++)
	{
		GLevel.Vertexes[i].z = 0.0;
	}
}

//==========================================================================
//
//	MakeVertexFloorHeights
//
//==========================================================================

void MakeVertexFloorHeights(void)
{
	int i;
	sector_t *sec;
	TVec p1;
	TVec p2;
	TVec p3;
	TVec v1;
	TVec v2;
	
	if (!SetVertexHeights(1504))
	{
		return;
	}
	for (i = 0; i < GLevel.NumSectors; i++)
	{
		sec = &GLevel.Sectors[i];
		if (sec->linecount != 3)
			continue;
		p1 = *sec->lines[0]->v1;
		p2 = *sec->lines[0]->v2;
		if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
			sec->lines[1]->v1 == sec->lines[0]->v2)
		{
			p3 = *sec->lines[1]->v2;
		}
		else
		{
			p3 = *sec->lines[1]->v1;
		}
		if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1)
		{
			continue;
		}
		if (p1.z == 0.1)
		{
			p1.z = sec->floorheight;
		}
		if (p2.z == 0.1)
		{
			p2.z = sec->floorheight;
		}
		if (p3.z == 0.1)
		{
			p3.z = sec->floorheight;
		}
		if (PointOnPlaneSide(p3, sec->lines[0]) == 0)
		{
			v1 = p2 - p3;
			v2 = p1 - p3;
		}
		else
		{
			v1 = p1 - p3;
			v2 = p2 - p3;
		}
		sec->floor.normal = Normalise(CrossProduct(v1, v2));
		if (sec->floor.normal.z <= 0.0)
		{
			Error("Floor with normal.z <= 0.0");
		}
		sec->floor.dist = DotProduct(sec->floor.normal, p3);
		sec->base_floorheight = sec->floor.dist;
		SendFloorSlope(sec);
	}
}

//==========================================================================
//
//	MakeVertexCeilingHeights
//
//==========================================================================

void MakeVertexCeilingHeights(void)
{
	int i;
	sector_t *sec;
	TVec p1;
	TVec p2;
	TVec p3;
	TVec v1;
	TVec v2;
	
	if (!SetVertexHeights(1505))
	{
		return;
	}
	for (i = 0; i < GLevel.NumSectors; i++)
	{
		sec = &GLevel.Sectors[i];
		if (sec->linecount != 3)
			continue;
		p1 = *sec->lines[0]->v1;
		p2 = *sec->lines[0]->v2;
		if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
			sec->lines[1]->v1 == sec->lines[0]->v2)
		{
			p3 = *sec->lines[1]->v2;
		}
		else
		{
			p3 = *sec->lines[1]->v1;
		}
		if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1)
		{
			continue;
		}
		if (p1.z == 0.1)
		{
			p1.z = sec->ceilingheight;
		}
		if (p2.z == 0.1)
		{
			p2.z = sec->ceilingheight;
		}
		if (p3.z == 0.1)
		{
			p3.z = sec->ceilingheight;
		}
		if (PointOnPlaneSide(p3, sec->lines[0]) == 0)
		{
			v1 = p1 - p3;
			v2 = p2 - p3;
		}
		else
		{
			v1 = p2 - p3;
			v2 = p1 - p3;
		}
		sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
		if (sec->ceiling.normal.z >= 0.0)
		{
			Error("Ceiling with normal.z >= 0.0");
		}
		sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
		sec->base_ceilingheight = sec->ceiling.dist;
		SendCeilingSlope(sec);
	}
}

//==========================================================================
//
//	AlignPlane
//
//	Set slopes for sectors, based on line specials
//
//	Aligns the floor or ceiling of a sector to the corresponding plane
// on the other side of the reference line. (By definition, line must be
// two-sided.)
//
//	If (which & 1), sets floor.
//	If (which & 2), sets ceiling.
//
//==========================================================================

void AlignPlane(sector_t *sec, line_t *line, int which)
{
	sector_t *refsec;
	float bestdist;
	TVec *refvert = (*sec->lines)->v1;
	int i;
	line_t **probe;
	float dist;
	TVec *vert;
	TVec p, v1, v2, cross;
	sec_plane_t *refplane;
	sec_plane_t *srcplane;
	float srcheight, destheight;

	if (line->backsector == NULL)
		return;

	//	Find furthest vertex from the reference line. It, along with the two
	// ends of the line will define the plane.
	bestdist = 0.0;
	for (i = sec->linecount * 2, probe = sec->lines; i > 0; i--)
	{
		if (i & 1)
		{
			vert = (*probe)->v2;
			probe = &probe[1];
		}
		else
			vert = (*probe)->v1;
		dist = fabs(DotProduct(*vert, line->normal));

		if (dist > bestdist)
		{
			bestdist = dist;
			refvert = vert;
		}
	}

	refsec = line->frontsector == sec ? line->backsector : line->frontsector;

	p = *line->v1;
	v1 = *line->v2 - *line->v1;
	v2 = *refvert - *line->v1;

	refplane = (which == 0) ? &refsec->floor : &refsec->ceiling;
	srcplane = (which == 0) ? &sec->floor : &sec->ceiling;
	srcheight = (which == 0) ? sec->floorheight : sec->ceilingheight;
	destheight = (which == 0) ? refsec->floorheight : refsec->ceilingheight;

	p.z = destheight;
	v1.z = 0.0;
	v2.z = srcheight - destheight;

	cross = Normalise(CrossProduct(v1, v2));

	// Fix backward normals
	if ((cross.z < 0.0 && which == 0) || (cross.z > 0.0 && which == 1))
	{
		cross = -cross;
	}

	srcplane->normal = cross;
	srcplane->dist = DotProduct(cross, p);
	if (which == 0)
		SendFloorSlope(sec);
	else
		SendCeilingSlope(sec);
}

//==========================================================================
//
//	SetSlopes
//
//==========================================================================

void SetSlopes(void)
{
	int i, s;

	for (i = 0; i < GLevel.NumLines; i++)
	{
		if (GLevel.Lines[i].special == 181)
		{
			GLevel.Lines[i].special = 0;
//			GLevel.Lines[i].id = GLevel.Lines[i].args[2];
			if (GLevel.Lines[i].backsector != NULL)
			{
				// args[0] is for floor, args[1] is for ceiling
				//
				// As a special case, if args[1] is 0,
				// then args[0], bits 2-3 are for ceiling.
				for (s = 0; s < 2; s++)
				{
					int bits = (s == 0 ? GLevel.Lines[i].arg1 :
 						GLevel.Lines[i].arg2) & 3;

					if (s == 1 && bits == 0)
						bits = (GLevel.Lines[i].arg1 >> 2) & 3;

					if (bits == 1)			// align front side to back
						AlignPlane(GLevel.Lines[i].frontsector,
							&GLevel.Lines[i], s);
					else if (bits == 2)		// align back side to front
						AlignPlane(GLevel.Lines[i].backsector,
							&GLevel.Lines[i], s);
				}
			}
		}
	}
}

//==========================================================================
//
//  SpawnExtraFloors
//
//==========================================================================

void SpawnExtraFloors(line_t * line)
{
	int j;

	for (j = 0; j < GLevel.NumSectors; j++)
	{
		if (line->arg1 == GLevel.Sectors[j].tag)
		{
			AddExtraFloor(line, &GLevel.Sectors[j]);
		}
	}
}

//==========================================================================
//
//  CreateContents
//
//==========================================================================

int terrain_contents[] = {
	CONTENTS_EMPTY,
	CONTENTS_EMPTY,
	CONTENTS_WATER,
	CONTENTS_WATER,
	CONTENTS_LAVA,
	CONTENTS_SLUDGE,
};
int contents_transluc[] = { 0, 50, 20, 30 };

void CreateContents(line_t * line)
{
	int contents;

	if (!line->arg1 && !line->arg2 && !line->arg3)
	{
		contents =
			terrain_contents[TerrainType(line->frontsector->floor.pic)];
		line->frontsector->params.contents = contents;
		if (line->frontsector->floor.dist == -line->frontsector->ceiling.dist)
		{
			line->frontsector->floor.translucency =
				contents_transluc[contents];
			line->frontsector->ceiling.translucency =
				contents_transluc[contents];
			line->frontsector->ceiling.flags |=
				SPF_NOBLOCKING | SPF_NOBLOCKSIGHT | SPF_NOBLOCKSHOOT;
			line->frontsector->floor.flags |=
				SPF_NOBLOCKING | SPF_NOBLOCKSIGHT | SPF_NOBLOCKSHOOT;
		}
	}
	else
	{
		line->frontsector->params.contents = line->arg1;

		line->frontsector->floor.translucency = line->arg2;
		line->frontsector->ceiling.translucency = line->arg2;

		line->frontsector->ceiling.flags = line->arg3;
		line->frontsector->floor.flags = line->arg3;
	}
}

//==========================================================================
//
//  SpawnWorld
//
//==========================================================================

void SpawnWorld(void)
{
	int i;
	mthing_t *mthing;

	//  Spawn slopes first
	SetSlopes();
	for (i = 0; i < GLevel.NumThings; i++)
	{
		mthing = &GLevel.Things[i];

		if (mthing->type == 1500)
		{
			MakeFloorSlope(mthing);
			mthing->type = 0;
			continue;
		}

		if (mthing->type == 1501)
		{
			MakeCeilingSlope(mthing);
			mthing->type = 0;
			continue;
		}
	}
	MakeVertexFloorHeights();
	MakeVertexCeilingHeights();
	CleanVertexHeights();

	//  Spawn 3D floors
	for (i = 0; i < GLevel.NumLines; i++)
	{
		if (GLevel.Lines[i].special == 160)
		{
			SpawnExtraFloors(&GLevel.Lines[i]);
		}
		if (GLevel.Lines[i].special == 161)
		{
			CreateContents(&GLevel.Lines[i]);
		}
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.2  2004/12/27 12:30:02  dj_jl
//  Vavoom version 1.16 changes.
//
//  Revision 1.1  2004/11/16 13:33:23  dj_jl
//  Initial import.
//
//  Revision 1.9  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.8  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.7  2002/08/24 14:53:06  dj_jl
//  Implemented sloping with vertex heights.
//
//  Revision 1.6  2002/05/03 17:13:35  dj_jl
//  Fixed content types.
//
//  Revision 1.5  2002/01/07 12:25:58  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
