//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class PlayerPawn : PlayerPawnBase
	abstract;

class<Weapon>			WeaponClasses[HexenDefs::NUMWEAPONSLOTS];

int InitialStrength;
int InitialWisdom;
int InitialDexterity;
int InitialConstitution;
int InitialIntelligence;

bool bSafeToRemove;

bool bOverrideCoop;	// [CW] Override IsTeammate method by always returning false
					// currently is used as a temporary fix for targetinfo not showing for allies

int experience;

//===========================================================================
//
//	PlayerIsMorphed
//
//===========================================================================

bool PlayerIsMorphed()
{
	return self.Class == PlayerPig;
}

//==========================================================================
//
//  IsDeathInflictor
//
//	[CW]
//
//==========================================================================

void IsDeathInflictor(EntityEx victim)
{
	//[CW] DEBUGGING *****************
	if (!victim)
		Error("PlayerPawn::IsDeathInflictor : victim reference not set to an instance of an object");
	if (!Player)
		Error("PlayerPawn::IsDeathInflictor : Player reference not set to an instance of an object");
	if (!Player(Player).ReadyWeapon)
		Error("PlayerPawn::IsDeathInflictor : Player.ReadyWeapon reference not set to an instance of an object");
	//[CW] DEBUGGING *****************

	// Currently only Pawn's death has a meaning here
	if (ClassIsChildOf(victim.Class, Pawn))
	{
		if (KArenaWeapon(Player(Player).ReadyWeapon).bInstantRanged &&
			Length(KArenaWeapon(Player(Player).ReadyWeapon).ShotPosition - victim.GetCentre()) >= HexenDefs::ACCURATE_SHOT_DISTANCE)
				Player(Player).ConfirmTrophy(HexenDefs::trophycl_accuracy);
	}
}

//===========================================================================
//
//  RoughCheckThing
//
//	Minotaur looking around player
//
//===========================================================================

bool RoughCheckThing(Entity Other)
{
	EntityEx link = EntityEx(Other);
	
	if (!bIsPlayer)
	{
		return false;
	}
	if (!link.bMonster && (!link.bIsPlayer || link == self))
	{
		return false;
	}
	if (!link.bShootable)
	{
		return false;
	}
	if (link.bDormant)
	{
		return false;
	}
	if (link.IsA('Minotaur') && link.Tracer == self)
	{
		return false;
	}
	if (Level.Game.netgame && !Level.Game.deathmatch && link.bIsPlayer)
	{
		return false;
	}
	if (CanSee(link))
	{
		return true;
	}
	return false;
}

//==========================================================================
//
//  A_AddPlayerCorpse
//
//==========================================================================

final void A_AddPlayerCorpse()
{
	int n = HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo(Level).BodyQueSize;
	if (HexenLevelInfo(Level).bodyqueslot >= HexenLevelInfo(Level).BodyQueSize)
	{
		// Too many player corpses - remove an old one
		if (HexenLevelInfo(Level).bodyque[n])
			HexenLevelInfo(Level).bodyque[n].Destroy();
	}
	HexenLevelInfo(Level).bodyque[n] = self;
	Translation = XLevel.SetBodyQueueTrans(n, Translation);
	HexenLevelInfo(Level).bodyqueslot++;
}

//==========================================================================
//
//	MoveToFreePosition
//
//	[CW]
//
//==========================================================================

bool MoveToFreePosition()
{
	TVec bak_org;
	float test_ang;
	TVec test_dir;
	float test_dist;

	bak_org = Origin;
	test_dir = vector(1.0, 0.0, 0.0);

	for (test_dist = 0.0; test_dist <= 512.0; test_dist += 64.0)
	{
		for (test_ang = 0.0; test_ang < 360.0; test_ang += 45.0)
		{
			VectorRotateAroundZ(&test_dir, test_ang);
			UnlinkFromWorld();
			Origin = bak_org + test_dir * test_dist;
			LinkToWorld();
			// [FB] We must check if the move is being done inside the map
			if (!CheckSides(Origin + vector((4.0 + 3.0 * (Radius) / 2.0) * cos(test_ang), (4.0 + 3.0 * (Radius) / 2.0) * sin(test_ang), ONFLOORZ)))
			{
				// [FB] OK, we are inside the map
				if (TestLocation()/*TeleportMove(bak_org + test_dir * test_dist)*/)
				{
					return true;
				}
			}

			if (test_dist == 0.0)
				break;
		}
	};

	UnlinkFromWorld();
	Origin = bak_org;
	LinkToWorld();
	return false;
}

//==========================================================================
//
//	Kill
//
//==========================================================================

void Kill(optional EntityEx inflictor, optional EntityEx source, optional bool bXDeath, optional name DamageType)
{
	Damage(inflictor, source, bXDeath ? Health - GibsHealth + 1 : Health + 1,
		specified_DamageType ? DamageType : 'InstantKill');
}

//==========================================================================
//
//	IsTeammate
//
//==========================================================================

bool IsTeammate(EntityEx Other)
{
	if (bOverrideCoop)
		return false;

	if (::IsTeammate(Other))
	{
		return true;
	}
	if (bIsPlayer && Other.bIsPlayer)
	{
		if (MainGameInfo(Level.Game).GameModel &&
			MainGameInfo(Level.Game).GameModel.TeamFactor(self, Other) ==
			GameModel::teamfactor_coop)
		{
			return true;
		}
		if ((MainGameInfo(Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM ||
			MainGameInfo(Level.Game).bIsCoopGame[MainGameInfo(Level.Game).GameType]) &&
			Player(Player).Team == Player(Other.Player).Team)
		{
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  HeresiarchMorphPlayer
//
//  [CW] Morph player into... err... something
//
//==========================================================================

bool HeresiarchMorphPlayer(int pclass, class<Actor> moclass, bool timed,
	bool until_death)
{
	Actor fog;
	Actor beastMo;
	int i;
	int bak_level;

	if (bInvulnerable)
	{
		// Immune when invulnerable
		return false;
	}
	if (Player(Player).Morph.bMorphed)
	{
		// Player is already a beast
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0,
		MainGameInfo::TELEFOGHEIGHT));
	fog.PlaySound('Teleport', CHAN_VOICE);

	beastMo = Spawn(moclass, Origin);
	beastMo.Tracer = Player(Player).ReadyWeapon;
	beastMo.Angles = Angles;
	beastMo.Player = Player;
	beastMo.bIsPlayer = true;
	Player.Health = beastMo.Health;
	Player.MO = beastMo;
	Player.Camera = beastMo;
	BasicArmor BArmor = BasicArmor(FindInventory(BasicArmor));
	BArmor.Amount = 0;
	Player.PClass = pclass;
	beastMo.bFly = bFly;
	Player(Player).Morph.bMorphed = true;
	Player(Player).Morph.bTimer = timed;
	Player(Player).Morph.bUntilDeath = until_death;
	if (timed)
		Player(Player).Morph.MorphTime = Player::MORPHTIME;
	Player(Player).ActivateMorphWeapon();

	// [CW] If morphed player cannot move from current position try to find more appropriate position or him
	if (!Actor(Player.MO).TryMove(Origin))
	{
		PlayerPawn(Player.MO).MoveToFreePosition();
	}
	else
	{
		fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0,
			MainGameInfo::TELEFOGHEIGHT));
		fog.PlaySound('Teleport', CHAN_VOICE);
	}

	// [CW] Recalc attributes based on the new player's body
	bak_level = Player(Player).exp_level;
	Player(Player).InitiateLevel();
	Player(Player).ActivateLevel(bak_level, false);

	SetState(FindState('FreeTargMobj'));

	return true;
}

//==========================================================================
//
//  BlindPlayer
//
//  [FB] Similar to Actor::Damage
//
//==========================================================================

void BlindPlayer(Actor blinder, int blind)
{
	if ((Player(Player).Cheats & Player::CF_GODMODE) || bInvulnerable)
	{
		return;
	}
	Player(Player).BlindCount += blind;
	if (blinder)
		Player(Player).Blinder = Player(blinder.Player);
	if (Player(Player).BlindCount > 220)
	{
		Player(Player).BlindCount = 220;
	}
	Player(Player).LastBlindTime = XLevel.Time;
}

//==========================================================================
//
//  BlindDamage
//
//==========================================================================

void BlindDamage(Actor source, int damage, bool playPainSound)
{
	Actor inflictor;

	inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
		bInvulnerable))
	{
		return;
	}
	Player.Health -= damage;	// mirror mobj health here for Dave
	if (Player.Health < 0)
	{
		Player.Health = 0;
	}
	Player(Player).Attacker = source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (bIsPlayer && inflictor && Player(Player).PClass != HexenDefs::PCLASS_PIG)
		{
			// Check for flame death
			if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
			{
				DamageType = 'Fire';
			}
			else
			{
				DamageType = inflictor.DamageType;
			}
		}
		DamageType = 'Blind';
		Died(source, inflictor);
		return;
	}
	if (playPainSound)
	{
		SetState(FindState('Pain'));
	}
}

//==========================================================================
//
//  Spawn_2
//
//==========================================================================

Actor Spawn_2(Thinker shooter, class<Thinker> Type, optional TVec AOrigin,
	optional TAVec AAngles, optional mthing_t* mthing)
{
	KArenaActor A;
	if (specified_mthing)
		A = KArenaActor(Spawn(Type, AOrigin, AAngles, mthing));
	else if (specified_AAngles)
		A = KArenaActor(Spawn(Type, AOrigin, AAngles));
	else if (specified_AOrigin)
		A = KArenaActor(Spawn(Type, AOrigin));
	else
		A = KArenaActor(Spawn(Type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissile_2
//
//==========================================================================

Actor SpawnPlayerMissile_2(Thinker shooter, class<EntityEx> type)
{
	KArenaActor A = KArenaActor(SpawnPlayerMissile(type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileAngle_2
//
//==========================================================================

Actor SpawnPlayerMissileAngle_2(Thinker shooter, class<EntityEx> type, float angle)
{
	KArenaActor A = KArenaActor(SpawnPlayerMissileAngle(type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//===========================================================================
//
//  SpawnPlayerMissileAngleXYZ_2
//
//===========================================================================

Actor SpawnPlayerMissileAngleXYZ_2(Thinker shooter, TVec org, class<EntityEx> type,
	float angle)
{
	KArenaActor A = KArenaActor(SpawnPlayerMissileAngleXYZ(org, type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileEx_2
//
//==========================================================================

Actor SpawnPlayerMissileEx_2(Thinker shooter, class<EntityEx> type, bool RetExploded,
	out EntityEx AimTarget, optional float angle, optional TVec SpawnOrg)
{
	KArenaActor A;
	if (specified_SpawnOrg)
		A = KArenaActor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle, SpawnOrg));
	else if (specified_angle)
		A = KArenaActor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle));
	else
		A = KArenaActor(SpawnPlayerMissileEx(type, RetExploded, AimTarget));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//	CanReach
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional EntityEx TargetEntity,
			  // [CW] use these three to override default passability calculations
			  optional float MaxPassableStep,
			  optional float MaxPassableDropOff,
			  optional float MinPassableOpening,
			  optional bool bCanUseLines)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!specified_TargetEntity)
		TargetEntity = none;

	if (!specified_MaxPassableStep)
		MaxPassableStep = MaxStepHeight;
	if (!specified_MaxPassableDropOff)
		MaxPassableDropOff = MaxDropoffHeight;
	if (!specified_MinPassableOpening)
		MinPassableOpening = Height;
	
	canreach = DoCanReachPathTraverse(TargetPos, &CRTRData,
		MaxPassableStep, MaxPassableDropOff, MinPassableOpening, bCanUseLines);
	
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;
	
	if (canreach && TargetEntity)
	{
		//
		// [CW] CHECKME ---
		//
		//if (CRTRData.linetarget != TargetEntity)
		//	return false;

		// [FB]  3d Floor checks...
		if (TargetEntity.Origin.z > FloorZ + MaxPassableStep)
			return false;
		if (TargetEntity.Origin.z < FloorZ)
			return false;

		// [CW] prev_sector is now the last sector met
		if (TargetEntity.Origin.z > CRTRData.prev_sector->floorheight + MaxPassableStep)
			return false;		// [CW] target thing is too high to reach
		if (TargetEntity.Origin.z < CRTRData.prev_sector->floorheight)
			return false;		// [CW] target thing is under the floor
	}

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
// [FB] Added partial 3d floor support, needs to be checked and corrected...
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							ReachTraverse::reach_traverse_data_t * pCRTRData,
							float MaxPassableStep,
							float MaxPassableDropOff,
							float MinPassableOpening,
							bool bCanUseLines)
{
	intercept_t * in;
	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pCRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;
			TVec tracedir;
			TVec hit_point;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
				return false;

			// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			if (p_sector->floorheight > pCRTRData->prev_sector->floorheight + MaxPassableStep)
				// will stuck in high floor
				return false;
			if (p_sector->floorheight < pCRTRData->prev_sector->floorheight - MaxPassableDropOff)
				// must avoid dropoffs
				return false;
			if (p_sector->ceilingheight < pCRTRData->prev_sector->floorheight + MinPassableOpening ||
				p_sector->floorheight + MinPassableOpening > pCRTRData->prev_sector->ceilingheight)
				// will stuck in low ceiling...
				return false;

			pCRTRData->prev_sector = p_sector;

			// [FB] partial 3d floor support...
			tracedir.x = cos(Angles.yaw);
			tracedir.y = sin(Angles.yaw);
			tracedir.z = FloorZ;
			hit_point = Origin + (Length(Origin - TargetPos) * in->frac) * tracedir;
			pCRTRData->opening = LineOpenings(in->line, hit_point);
			pCRTRData->opening = FindOpening(pCRTRData->opening, hit_point.z, hit_point.z + Height);

			// only valid openings
			if (pCRTRData->opening)
			{
				if ((pCRTRData->opening->range <= MinPassableOpening) ||
					(pCRTRData->opening->lowfloor - pCRTRData->opening->bottom > MaxPassableStep) ||
					(pCRTRData->opening->lowfloor - pCRTRData->opening->bottom > MaxPassableDropOff))
					return false;
			}
			// [FB] This should partially cover it...
		}
		else
		{
			// TODO: check this precisely...
			pCRTRData->linetarget = Actor(in->Thing);
		}
	}

	return true;
}

//==========================================================================
//
//	A_GetNearestEntity
//
//==========================================================================

final EntityEx A_GetNearestEntity(class<EntityEx> EClass, optional bool bReachable)
{
	EntityEx EE;
	EntityEx ee;
	float dist = -1.0;

	foreach AllThinkers(EClass, ee)
	{
		if (dist < 0.0 || Length(ee.Origin - Origin) < dist)
		{
			if (bReachable && !CanReach(ee.Origin))
				continue;
			EE = ee;
			dist = Length(ee.Origin - Origin);
		}
	}

	return EE;
}

defaultproperties
{
	ViewHeight = 48.0;
	RDFactor = 0.25;
	SoundClass = 'fighter';
	CrunchSound = '*splat';
}
