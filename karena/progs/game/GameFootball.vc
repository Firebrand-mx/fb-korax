//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: GameFootball.vc 508 2006-07-10 19:02:43Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class GameFootball : GameModel;

enum
{
	state_preparematch,
	state_kickoff,
	state_freeplay,
	state_finished,
	state_waitkickoff
	//state_waitforplayerspawn
};

enum
{
	event_goal			= GameModel::event_custom,
	event_offside,
	event_dokickoff,
	num_footballevents	= event_dokickoff - GameModel::event_custom + 1
};


acsnotifier_t	AcsNotifiersFootball[num_footballevents];


SoccerBall			Ball;
SoccerBallSpot		spot_ball;
bool				bBallCreated;
bool				bSpotBallCreated;

struct spot_players_t
{
	KickOffSpot		ms[MAXPLAYERS];
};
spot_players_t spot_players[2];

GameSequencer	fbTimer;


//==========================================================================
//
//	AllowedTeams
//
//==========================================================================

int AllowedTeams()
{
	return 2;
}

//==========================================================================
//
//	BeginState
//
//	ACS callable
//
//==========================================================================

void BeginState(int newstate)
{
	int i;

	dprint("GameFootball::BeginState : %i", newstate);

	switch(newstate)
	{
	case state_preparematch:

		if (!PrepareMatch())
		{
			dprint("GameFootball::BeginState : failed to prepare match, delay start");
			State = -1;
			return;
		}
		
		dprint("GameFootball::BeginState : starting match");
		Game.bcentreprint("Let the game begin!");
		
		HandleEvent(event_playablestatebegins, none, 0,0,0,0);
		
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Teams[0] && Game.Teams[0].Players[i])
			   Game.Teams[0].Players[i].UpdateScore(HexenDefs::scoreevent_PlayerReset);
			if (Game.Teams[1] && Game.Teams[1].Players[i])
			   Game.Teams[1].Players[i].UpdateScore(HexenDefs::scoreevent_PlayerReset);
		}
		if (Game.Teams[0])
			Game.Teams[0].UpdateScore(HexenDefs::scoreevent_TeamReset);
		if (Game.Teams[1])
			Game.Teams[1].UpdateScore(HexenDefs::scoreevent_TeamReset);
		EndCurrentState(state_waitkickoff);
		return;
		
	case state_kickoff:
	
		if (!Game.Teams[0] || !Game.Teams[1])
		{
			dprint("GameFootball::BeginState : state_kickoff : not enouph teams, ending game");
			EndCurrentState(state_finished);
			return;
		}
		
		if (!spot_ball || !Ball)
		{
			dprint("GameFootball::BeginState : state_kickoff : ball and/or spot_ball missing, ending game");
			EndCurrentState(state_finished);
			return;
		}
		
		Ball.Teleport(spot_ball.Origin, spot_ball.Angles.yaw, true, true, false);
		
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Teams[0].Players[i] && spot_players[0].ms[i])
			   EntityEx(Game.Teams[0].Players[i].MO).Teleport(spot_players[0].ms[i].Origin, spot_players[0].ms[i].Angles.yaw, true, true, false);
			if (Game.Teams[1].Players[i] && spot_players[1].ms[i])
			   EntityEx(Game.Teams[1].Players[i].MO).Teleport(spot_players[1].ms[i].Origin, spot_players[1].ms[i].Angles.yaw, true, true, false);
		}
		
		Game.bcentreprint("kick off!");
		
		EndCurrentState(state_freeplay);
		return;
	case state_freeplay:
		break;
	case state_finished:
		//
		// do something here?
		//
		break;
	case state_waitkickoff:
		fbTimer = Level.Spawn(GameSequencer);
		if (fbTimer)
		{
			fbTimer.event_id = event_dokickoff;
			fbTimer.time_limit = 4.0;
		}
		break;
	};

	State = newstate;
}

//==========================================================================
//
//	IsInPlayableState
//
//==========================================================================

bool IsInPlayableState()
{
	return (State >= 0 && State != state_preparematch && State != state_finished);
}

//==========================================================================
//
//	EndCurrentState
//
//	ACS callable
//
//==========================================================================

void EndCurrentState(int nextstate)
{
	dprint("GameFootball::EndCurrentState : state = %i, next_state = %i", State, nextstate);
	if (nextstate == state_finished)
	{
		Cleanup();
	}

	BeginState(nextstate);
}

//==========================================================================
//
//	NotifyUpdateTeams
//
//==========================================================================

void NotifyUpdateTeams()
{
	if (!IsInPlayableState() && (Game.Teams[0] && Game.Teams[1]))
		BeginState(state_preparematch);
	else if (IsInPlayableState() && (!Game.Teams[0] || !Game.Teams[1]))
		EndCurrentState(state_finished);
}

//==========================================================================
//
//	HandleEvent
//
//	ACS callable
//
//==========================================================================

void HandleEvent(int Event, EntityEx A, int arg1, int arg2, int arg3, int arg4)
{
	int notifyACSArgs[3];

	dprint("GameFootball::HandleEvent : %i", Event);

	switch (Event)
	{
	case event_goal:
		if (State != state_freeplay)
			return;

		if (!A || A != Ball)
			return;
			
		// arg1 is a team, in which gates a ball was thrown
		if (arg1 >= 0 && arg1 < 2 && Game.Teams[arg1])
		{
			if (Ball.Owner && Game.Teams[arg1] == Ball.Owner.Team)
			{
				// 'self-goal'
				Ball.Owner.UpdateScore(HexenDefs::scoreevent_FtbSelfGoal);
				// opponent team is getting aware of happening
				// (in case special score should be provided for it)
				if (arg1 && Game.Teams[0])
				   Game.Teams[0].UpdateScore(HexenDefs::scoreevent_FtbOpSelfGoal);
				else if (!arg1 && Game.Teams[1])
				   Game.Teams[1].UpdateScore(HexenDefs::scoreevent_FtbOpSelfGoal);
				Game.bcentreprint(va("OOOPS! Team %d kicked a ball into their own gates!", arg1));
				
				notifyACSArgs[1] = arg1;
			}
			else if (Ball.Owner)
			{
				// normal goal
				Ball.Owner.UpdateScore(HexenDefs::scoreevent_FtbGoal);
				Game.bcentreprint(va("Team %d scores a goal!", arg1 ? 0 : 1));
				notifyACSArgs[1] = arg1 ? 0 : 1;

				if (GetCvar('ScoreLimit') <= Ball.Owner.Team.Goals)
				{
					// [FB] Exit map
					Level.ExitLevel(0);
				}
			}
			else
				notifyACSArgs[1] = -1;
		}
		
		notifyACSArgs[0] = arg1;
		
		EndCurrentState(state_waitkickoff);
		break;
	case event_offside:

		//[CW] continue from kickoff maybe??
		// need timer here though, since there should be delay
		// before players are repositioned

		break;
		
	case event_dokickoff:
		if (fbTimer)
			fbTimer.Destroy();
		EndCurrentState(state_kickoff);
		break;
		
	default:
		::HandleEvent(Event, A, arg1, arg2, arg3, arg4);
		return;
	}
	
	NotifyACS(Event, notifyACSArgs[0], notifyACSArgs[1], notifyACSArgs[2]);
}	

//==========================================================================
//
//	SetACSNotifier
//
//	ACS callable
//
//==========================================================================

void SetACSNotifier(int event, int script)
{
	if (event >= GameModel::event_custom && event < event_goal + num_footballevents)
	{
		event -= GameModel::event_custom;
		AcsNotifiersFootball[event].enabled = true;
		AcsNotifiersFootball[event].script = script;
	}
	else
	{
		::SetACSNotifier(event, script);
	}
}

//==========================================================================
//
//	NotifyACS
//
//==========================================================================

void NotifyACS(int Event, int Arg1, int Arg2, int Arg3)
{
	dprint("GameFootball::NotifyACS : Event = %i", Event);
	if (Event >= GameModel::event_custom && Event < event_goal + num_footballevents)
	{
		Event -= GameModel::event_custom;
		if (AcsNotifiersFootball[Event].enabled)
		{
			Level.ExecuteActionSpecial(LNSPEC_ACSExecute,
					AcsNotifiersFootball[Event].script,
					0,
					Arg1,
					Arg2,
					Arg3,
					NULL, 0, none);
		}
	}
	else
		::NotifyACS(Event, Arg1, Arg2, Arg3);
}

//==========================================================================
//
//	Cleanup
//
//==========================================================================

void Cleanup()
{
	if (bBallCreated)
	{
		if (Ball)
			Ball.Destroy();
		bBallCreated = false;
	}
	Ball = none;
	if (bSpotBallCreated)
	{
		if (spot_ball)
			spot_ball.Destroy();
		bSpotBallCreated = false;
	}
	spot_ball = none;

	int i;
	for (i = 0; i < MAXPLAYERS; i++)
	{
		spot_players[0].ms[i] = none;
		spot_players[1].ms[i] = none;
	}
}

//==========================================================================
//
//	PrepareMatch
//
//==========================================================================

bool PrepareMatch()
{
	int i;
	KickOffSpot kos;

	if (!Game.Teams[0] || !Game.Teams[1])
	{
		dprint("GameFootball : not enouph teams");
		return false;
	}

	Cleanup();	

	foreach Level.AllThinkers(SoccerBall, Ball)
	{
		dprint("SoccerBall --> found!");
		break;
	}

	foreach Level.AllThinkers(SoccerBallSpot, spot_ball)
	{
		dprint("SoccerBallSpot --> found!");
		break;
	}

	foreach Level.AllThinkers(KickOffSpot, kos)
	{
		if (kos.Args[0] >= 0 && kos.Args[0] < AllowedTeams() && kos.Args[1] >= 0 && kos.Args[1] < MAXPLAYERS)
			spot_players[kos.Args[0]].ms[kos.Args[1]] = kos;
		else
			dprint("GameFootball::PrepareMatch : bad argument(s) for kick off spot at %f,%f,%f",
				kos.Origin.x, kos.Origin.y, kos.Origin.z);
	}

	if (!Ball)
	{
		if (spot_ball)
		{
			Ball = HexenLevelInfo(Level).Spawn(SoccerBall, spot_ball.Origin);
			if (Ball)
				bBallCreated = true;
			else
			{
				dprint("GameFootball::PrepareMatch : failed to spawn ball at spot_ball");
				return false;
			}
		}
		else
		{
			dprint("GameFootball::PrepareMatch : there are no spot_ball nor ball objects on map");
			return false;
		}
	}
	
	if (Ball && !spot_ball)
	{
		spot_ball = HexenLevelInfo(Level).Spawn(SoccerBallSpot, Ball.Origin);
		if (spot_ball)
			bSpotBallCreated = true;
		else
		{
			dprint("GameFootball::PrepareMatch : failed to spawn spot_ball at initial ball position; ball will be unable to set position on kickoff");
			return false;
		}
	}
	
	return true;
}

defaultproperties
{
}
