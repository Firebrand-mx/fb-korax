//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: GameKTH.vc 508 2006-07-10 19:02:43Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class GameKTH : Game;

enum
{
	state_preparegame,
	state_freeramble,
	state_heresiarch,
	state_finished,
	state_birthsequence,
	state_deathsequence,
	state_rebornsequence
};

enum
{
	event_heresiarchspawn,
	event_heresiarchdead,
	event_playdeathsequence,
	event_playbirthsequence
};


Player				plHeresiarch;
Actor				DeathSpot;

GameSequencer		deathSequencer;
GameSequencer		birthSequencer;

int		deathsequence_state;
int		birthsequence_state;

name	originalMusic;

// Animated sequences stuff
int		dlDelay1, dlDelay2;	// dynamic lighting delays
int		dmDelay;			// darkness missiles' delay
TVec	CircularPosition;	// used to form a revolving vector



//==========================================================================
//
//	BeginState
//
//	ACS callable
//
//==========================================================================

void BeginState(int newstate)
{
	switch(newstate)
	{
	case state_preparegame:
		EndCurrentState(state_freeramble);
		return;
	case state_freeramble:
		// awaiting sound here
		Game.BroadcastLocalSound(HexenDefs::lsid_kth_an_awaiting, true, HexenDefs::STANDART_LSQ_DELAY);
		Game.bcentreprint("first fragger shall become heresiarch");
		break;
	case state_heresiarch:
	case state_finished:
		break;
	case state_birthsequence:
	case state_deathsequence:
	case state_rebornsequence:
		originalMusic = Game.level->SongLump;
		deathsequence_state = 0;
		birthsequence_state = 0;
		break;
	};

	State = newstate;
}

//==========================================================================
//
//	TeamFactor
//
//==========================================================================

int TeamFactor(Pawn p1, Pawn p2)
{
	if (State == state_heresiarch && p1.bIsPlayer && p2.bIsPlayer &&
				p1 != plHeresiarch.MO && p2 != plHeresiarch.MO)
		return teamfactor_coop;
	return teamfactor_any;
}

//==========================================================================
//
//	NotifySpawnPlayer
//
//==========================================================================

void NotifyPlayerSpawn(Player pl)
{
	// If the game hasn't been started yet and
	// if there's at least 2 players in game, begin free ramble mode
	if (State < 0 && pl.GetPlayerNum() > 0)
		BeginState(state_preparegame);
}

//==========================================================================
//
//	NotifyPlayerDeath
//
//==========================================================================

void NotifyPlayerDeath(Player pl, Actor source)
{
	// For missiles: switch to missile's instigator
	if (source && source.Instigator)
	{
		source = source.Instigator;
	}

	switch (State)
	{
	case state_freeramble:
		// First fragger becomes Heresiarch
		if (source && source.bIsPlayer)
		{
			plHeresiarch = Player(source.Player);
			EndCurrentState(state_birthsequence);

			birthSequencer = GameSequencer(NewSpecialThinker(GameSequencer));
			if (birthSequencer)
				birthSequencer.event_id = event_playbirthsequence;
		}
		break;
	case state_heresiarch:
		// Handle Heresiarch death
		if (pl == plHeresiarch)
		{
			DeathSpot = Actor(plHeresiarch.MO);
			if (source && source.bIsPlayer)
			{
				plHeresiarch = Player(source.Player);
				EndCurrentState(state_rebornsequence);

				deathSequencer = GameSequencer(NewSpecialThinker(GameSequencer));
				if (deathSequencer)
					deathSequencer.event_id = event_playdeathsequence;
				birthSequencer = GameSequencer(NewSpecialThinker(GameSequencer));
				if (birthSequencer)
					birthSequencer.event_id = event_playbirthsequence;
			}
			else
			{
				plHeresiarch = none;
				EndCurrentState(state_deathsequence);
				
				deathSequencer = GameSequencer(NewSpecialThinker(GameSequencer));
				if (deathSequencer)
					deathSequencer.event_id = event_playdeathsequence;
			}
		}
		break;
	}
}

//==========================================================================
//
//	HandleGameEvent
//
//	ACS callable
//
//==========================================================================

void HandleGameEvent(Actor A, int Event, int arg1, int arg2, int arg3, int arg4)
{
	switch (Event)
	{
	case event_heresiarchspawn:
		Game.BroadcastLocalSound((State == state_rebornsequence ?
						(P_Random() > 127 ? HexenDefs::lsid_kth_an_hasreborn : HexenDefs::lsid_kth_an_ishere) : HexenDefs::lsid_kth_an_ishere),
						true, HexenDefs::STANDART_LSQ_DELAY);
		EndCurrentState(state_heresiarch);
		break;
	case event_heresiarchdead:
		Game.BroadcastLocalSound((State == state_rebornsequence ?
						(P_Random() > 127 ? HexenDefs::lsid_kth_an_isdefeated : HexenDefs::lsid_kth_an_isdown) : HexenDefs::lsid_kth_an_isdown),
						true, HexenDefs::STANDART_LSQ_DELAY);
		if (!plHeresiarch)
			EndCurrentState(state_freeramble);
		break;
	case event_playdeathsequence:
		PlayDeathSequence();
		break;
	case event_playbirthsequence:
		PlayBirthSequence();
		break;
	}
}

//==========================================================================
//
//	End
//
//==========================================================================

void End()
{
	EndCurrentState(state_finished);
	::End();
}

//==========================================================================
//
//	PlayDeathSequence
//
//==========================================================================

void PlayDeathSequence()
{
	switch(deathsequence_state)
	{
	case 0:
		dlDelay1 = 2;
		CircularPosition.x = 64.0;
		CircularPosition.y = 64.0;
		CircularPosition.z = 0.0;
		ChangeMusic(va("%n", 'kth_mus1'));
		break;
	case 13:
		{
			FlameLargeTemp flame;
			flame = FlameLargeTemp(Level.Spawn(FlameLargeTemp, DeathSpot.Origin));
			if (flame) flame.Args[0] = 8;
		}
		break;
	case 30:
		HandleGameEvent(none, event_heresiarchdead, 0,0,0,0);
		break;
	default:

		if (dlDelay1)
			dlDelay1--;
		else
		{
			TVec vec;
			dlDelay1 = 7;

			vec.x = (Random() - 0.5) * 128.0;
			vec.y = (Random() - 0.5) * 128.0;
			vec.z = (Random() - 0.25) * 32.0;

			Game.SpawnDynamicLight(RGB(255, 32, 32), MobjCentre(DeathSpot) + vec, 512, 200, 5000);
		}

		if (deathsequence_state > 0 && deathsequence_state < 13)
		{
			int i;
			FlameSmallTemp flame;
			for (i = 0; i < 3; i++)
			{
				flame = FlameSmallTemp(Level.Spawn(FlameSmallTemp, DeathSpot.Origin + CircularPosition));
				if (flame)
				{
					flame.Origin.z = flame.FloorZ;
					flame.Args[0] = 12;
				}
				VectorRotateAroundZ(&CircularPosition, 10.0);
			}
		}
		if (deathsequence_state > 8)
		{
			TVec vec;
			AxePuffGlow	ax;
			vec.x = (Random() - 0.5) * 16.0;
			vec.y = (Random() - 0.5) * 16.0;
			vec.z = (Random()) * 16.0;
			ax = AxePuffGlow(Level.Spawn(AxePuffGlow, DeathSpot.Origin + vec));
			if (ax)
			{
				ax.bMissile = true;
				ax.bRip = true;
				ax.Velocity.z = (Random() - 0.5) * 5.0;
				ax.Velocity.z = (Random() - 0.5) * 5.0;
				ax.Velocity.z = Random() * 15.0;
			}
		}
		if (deathsequence_state >= 38)
		{
			if (deathSequencer)
			{
				RemoveSpecialThinker(deathSequencer);
				deathSequencer = none;
			}
			if (State != state_rebornsequence)
				ChangeMusic(va("%n", originalMusic));
			break;
		}
	}
	deathsequence_state++;
}

//==========================================================================
//
//	PlayBirthSequence
//
//==========================================================================

void PlayBirthSequence()
{
	plHeresiarch.MO.Velocity = vector(0.0,0.0,plHeresiarch.MO.Velocity.z);

	switch(birthsequence_state)
	{
	case 0:
		// Make heresiarch-morphing player invulnerable & immobile for the period
		// of birth sequence
		dlDelay2 = 0;
		dmDelay = 0;
		plHeresiarch.SetControllable(false);
		Actor(plHeresiarch.MO).SetState(Actor(plHeresiarch.MO).PainState);
		if (State != state_rebornsequence)
			birthsequence_state = 39;	// skip waiting for death sequence completion
		break;
	case 40:
		// Spawn Sorcerer's balls
		{
			Actor ball;
			TVec org;
			plHeresiarch.MO.Args[0] = 0;	// Currently no defense
			plHeresiarch.MO.Args[2] = Sorcerer::SORCBALL_INITIAL_SPEED;	// target speed
			plHeresiarch.MO.Args[3] = Sorcerer::SORC_NORMAL;
			plHeresiarch.MO.Args[4] = Sorcerer::SORCBALL_INITIAL_SPEED;	// Initial orbit speed
			Actor(plHeresiarch.MO).Special1f = 1.0;
			org = plHeresiarch.MO.Origin;
			org.z = plHeresiarch.MO.Origin.z - plHeresiarch.MO.FloorClip + plHeresiarch.MO.Height;
			ball = Level.Spawn(SorcererBall1, org);
			if (ball)
			{
				ball.Instigator = Actor(plHeresiarch.MO);
				ball._Special2 = Sorcerer::SORCFX4_RAPIDFIRE_TIME;
			}
			ball = Level.Spawn(SorcererBall2, org);
			if (ball)
				ball.Instigator = Actor(plHeresiarch.MO);
			ball = Level.Spawn(SorcererBall3, org);
			if (ball)
				ball.Instigator = Actor(plHeresiarch.MO);

			plHeresiarch.MO.bNoGravity = true;
			plHeresiarch.MO.Velocity.z = 8.0;
			ChangeMusic(va("%n", 'kth_mus2'));
		}
		break;
/*	case 44:
		plHeresiarch.MO.Args[2] = Sorcerer::SORCBALL_TERMINAL_SPEED;	// target speed
		plHeresiarch.MO.Args[3] = Sorcerer::SORC_ACCELERATE;	// speed mode
		break;*/
	case 70:
		plHeresiarch.MO.Velocity.z = 0.0;
		CircularPosition.x = 128.0;
		CircularPosition.y = 128.0;
		HandleGameEvent(none, event_heresiarchspawn, 0,0,0,0);
		break;
	default:
		if (birthsequence_state > 12)
		{
			if (dlDelay2)
				dlDelay2--;
			else
			{
				TVec vec;
				dlDelay2 = 7;

				vec.x = (Random() - 0.5) * 128.0;
				vec.y = (Random() - 0.5) * 128.0;
				vec.z = (Random() - 0.25) * 32.0;

				Game.SpawnDynamicLight(RGB(255, 32, 32), MobjCentre(plHeresiarch.MO) + vec, 512, 500, 5000);
			}
		}
		if (birthsequence_state > 0 && birthsequence_state < 13)
		{
			int i;
			FlameSmallTemp flame;
			for (i = 0; i < 3; i++)
			{
				VectorRotateAroundZ(&CircularPosition, -10.0);
				flame = FlameSmallTemp(Level.Spawn(FlameSmallTemp, plHeresiarch.MO.Origin + CircularPosition));
				if (flame)
				{
					flame.Origin.z = flame.FloorZ;
					flame.Args[0] = 12;
				}
				VectorRotateAroundZ(&CircularPosition, 10.0);
			}
		}
		if (birthsequence_state > 12 && birthsequence_state < 39)
		{
			DarknessMissile dm;

			if (dmDelay)
				dmDelay--;
			else
			{
				dmDelay = 2;

				dm = DarknessMissile(Level.Spawn(DarknessMissile, MobjCentre(DeathSpot)));
				if (dm)
				{
					TVec dist;
					dist = MobjCentre(plHeresiarch.MO) - MobjCentre(DeathSpot);
					dm.bColideWithWorld = false;
					dm.bMissile = true;
					dm.bRip = true;
					dm.Velocity = Normalise(dist) * 128.0;
					dm.LifeCount = ftoi((Length(dist) / Length(dm.Velocity)) / (12.0 / 35.0)) - 1;
				}
			}
		}
		if (birthsequence_state > 70 && birthsequence_state < 78)
		{
			int i;
			DarknessMissile dm;
			for (i = 0; i < 3; i++)
			{
				CircularPosition.z = (Random() - 0.25) * 32.0;
				dm = DarknessMissile(Level.Spawn(DarknessMissile, MobjCentre(plHeresiarch.MO)));
				if (dm)
				{
					dm.bMissile = true;
					dm.bRip = true;
					dm.Velocity = CircularPosition;
					dm.InitMe(Actor(plHeresiarch.MO));
				}
				VectorRotateAroundZ(&CircularPosition, Random() * 360.0);
			}
		}
		if (birthsequence_state >= 78)
		{
			if (birthSequencer)
			{
				RemoveSpecialThinker(birthSequencer);
				birthSequencer = none;
			}
			Actor(plHeresiarch.MO).MorphPlayer(HexenDefs::PCLASS_PIG, PlayerPig, false, true);
			plHeresiarch.SetControllable(true);
			ChangeMusic(va("%n", originalMusic));
			break;
		}
	}
	birthsequence_state++;
}

defaultproperties
{
}
