//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**	        ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: GameSurvival.vc 508 2006-07-10 19:02:43Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class GameSurvival : KArenaGameModel;

enum
{
	state_preparegame,
	state_countdownsequence,
	state_wave
};

enum
{
	event_wavestart		= GameModel::event_custom,
	event_waveend,
	event_countdown,
	event_wavespawn,
	num_survivalevents	= event_wavespawn - GameModel::event_custom + 1
};

acsnotifier_t	AcsNotifiersSurvival[num_survivalevents];

// monster classes in the order of growing difficulty
array< name > MonsterClasses; 		// array of monster class names
array< int > MonsterCosts;			// monster cost to be spawned (in monster counts)
array< name > BossClasses;			// array of monster boss class names

int Wave;
int LoLimit;						// lower index in monster array
int HiLimit;						// higher index in monster array
int BoostedLimit;					// highest index in monster array that allows spawning of boosted versions of monsters
int CountToSpawnMonsters;			// how many monsters to spawn
int CountToSpawnBosses;				// how many bosses to spawn
int CountMonstersAtOnce;			// how many monsters & bosses can be on the level at the same time

GameSequencer		countdownSequencer;
int					countDown;
GameSequencer		waveSequencer;

//==========================================================================
//
//	AllowedTeams
//
//==========================================================================

int AllowedTeams()
{
	return 1;
}

//==========================================================================
//
//	AllowAllies
//
//==========================================================================

int AllowAllies()
{
	return true;
}

//==========================================================================
//
//	BeginState
//
//	ACS callable
//
//==========================================================================

void BeginState(int newstate)
{
	dprint("GameSurvival::BeginState : %i", newstate);

	switch(newstate)
	{
	case state_preparegame:
		Wave = 0;
		EndCurrentState(state_countdownsequence);
		return;

	case state_countdownsequence:
		SetUpWave();
		//
		// Setup countdown sequence
		countDown = 10;
		countdownSequencer = Level.Spawn(GameSequencer);
		if (countdownSequencer)
		{
			countdownSequencer.time_limit = 1.0;
			countdownSequencer.event_id = event_countdown;
		}
		break;

	case state_wave:
		waveSequencer = Level.Spawn(GameSequencer);
		if (waveSequencer)
		{
			waveSequencer.time_limit = 1.0;
			waveSequencer.event_id = event_wavespawn;
		}
		HandleEvent(event_wavestart, none, 0, 0, 0, 0);
		break;
	};

	State = newstate;
}

//==========================================================================
//
//	EndCurrentState
//
//	ACS callable
//
//==========================================================================

void EndCurrentState(int nextstate)
{
	int i;

	switch (State)
	{
	case state_wave:
		waveSequencer.Destroy();
		waveSequencer = none;
		//
		// Kill all existing monsters, just in case
		Level.P_Massacre();
		//
		// Ressurect killed players
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Players[i] && Game.Players[i].MO && Game.Players[i].MO.Class == PlayerSpectator)
			{
				Game.Players[i].PlayerState = PST_REBORN;
				Game.Players[i].NetGameReborn();
			}
		}
		HandleEvent(event_waveend, none, 0, 0, 0, 0);
		break;

	case state_countdownsequence:
		countdownSequencer.Destroy();
		countdownSequencer = none;
		break;
	}

	::EndCurrentState(nextstate);
}

//==========================================================================
//
//	IsInPlayableState
//
//==========================================================================

bool IsInPlayableState()
{
	return State > state_preparegame;
}

//==========================================================================
//
//	TeamFactor
//
//==========================================================================

int TeamFactor(EntityEx a1, EntityEx a2)
{
	return teamfactor_coop;
}

//==========================================================================
//
//	OnActorDeath
//
//==========================================================================

void OnActorDeath(Actor a, EntityEx source)
{
	if (!a.bMonster)
	{
		return;
	}

	int mleft = (Level.TotalKills - Level.CurrentKills) + CountToSpawnMonsters + CountToSpawnBosses;
	if (mleft > 0 && mleft <= 10)
	{
		Game.BroadcastLocalSoundNamed('misc/chat', true, 0.0);
		Game.bcentreprint(va("%i monsters left!", (Level.TotalKills - Level.CurrentKills) + CountToSpawnMonsters + CountToSpawnBosses));
	}

	if (!mleft)
	{
		EndCurrentState(state_countdownsequence);
	}
}

//==========================================================================
//
//	OnPlayerSpawn
//
//==========================================================================

void OnPlayerSpawn(BasePlayer pl)
{
	// If the game hasn't been started yet and
	// if there're at least 1 player in game, begin gameplay
	if (State < 0)
	{
		BeginState(state_preparegame);
	}
}

//==========================================================================
//
//	OnPlayerDeath
//
//==========================================================================

void OnPlayerDeath(BasePlayer pl, EntityEx source)
{
	// When player is killed during the monster wave he becomes a
	// spectator until the end of the wave.
	if (State == state_wave)
	{
		Player(pl).bRespawnAsSpectator = true;
		Player(pl).bAllowEndSpectate = false;

		int i;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Players[i] && Game.Players[i].MO && Game.Players[i].MO.Class != PlayerSpectator && Game.Players[i].MO.Health > 0)
			{
				// There are still living players around, so game should continue
				//
				return;
			}
		}

		// Too bad, all players died, end the game
		End();
	}
}

//==========================================================================
//
//	HandleEvent
//
//	ACS callable
//
//==========================================================================

void HandleEvent(int Event, EntityEx A, int arg1, int arg2, int arg3, int arg4)
{
	dprint("GameSurvival::HandleEvent : %i", Event);

	switch (Event)
	{
	case event_wavestart:
		Game.BroadcastLocalSoundNamed('BellRing', false, 0.0);
		Game.bcentreprint(va("wave %i!", Wave));
		break;
	case event_waveend:
		break;
	case event_countdown:
		countDown--;
		if (!countDown)
		{
			EndCurrentState(state_wave);
		}
		else
		{
			Game.BroadcastLocalSoundNamed('ClockTick', false, 0.0);
			Game.bcentreprint(va("next wave in %i seconds", countDown));
		}
		break;
	case event_wavespawn:
		WaveSpawn();
		break;
	default:
		::HandleEvent(Event, A, arg1, arg2, arg3, arg4);
		return;
	}

	NotifyACS(Event, 0, 0, 0);
}

//==========================================================================
//
//	SetACSNotifier
//
//	ACS callable
//
//==========================================================================

void SetACSNotifier(int event, int script)
{
	if (event >= GameModel::event_custom && event < event_wavestart + num_survivalevents)
	{
		event -= GameModel::event_custom;
		AcsNotifiersSurvival[event].enabled = true;
		AcsNotifiersSurvival[event].script = script;
	}
	else
	{
		::SetACSNotifier(event, script);
	}
}

//==========================================================================
//
//	NotifyACS
//
//==========================================================================

void NotifyACS(int Event, int Arg1, int Arg2, int Arg3)
{
	dprint("GameSurvival::NotifyACS : Event = %i", Event);
	if (Event >= GameModel::event_custom && Event < event_wavestart + num_survivalevents)
	{
		Event -= GameModel::event_custom;
		if (AcsNotifiersSurvival[Event].enabled)
		{
			Level.ExecuteActionSpecial(LNSPEC_ACSExecuteAlways,
					AcsNotifiersSurvival[Event].script,
					0,
					Arg1,
					Arg2,
					Arg3,
					NULL, 0, none);
		}
	}
	else
		::NotifyACS(Event, Arg1, Arg2, Arg3);
}

//==========================================================================
//
//	SetUpWave
//
//==========================================================================

void SetUpWave()
{
	Wave++;

	int PlayerCount = Game.GetPlayerCount();
	int SpawnStarts = Level.DeathmatchStarts.Num;

	// (8 + (0 to 7)) monsters per player + (1 to 4) monsters per player per wave index
	CountToSpawnMonsters = (8 + P_Random() % 8) * PlayerCount +
							(P_Random() % (PlayerCount << 2) + 1) * Wave;

	CountToSpawnBosses = Wave / (8 - PlayerCount - 1);

	// (1 to 2) per spawn start (i.e. at least 8 - 16)
	CountMonstersAtOnce = PlayerCount + P_Random() % ((SpawnStarts << 1) + 1);

	HiLimit = 1 + Wave;
	if (HiLimit > MonsterClasses.Num)
	{
		HiLimit = MonsterClasses.Num;
	}
	LoLimit = HiLimit >= 8 ? HiLimit - 8 : 0;
	BoostedLimit = -2 + (Wave - 1) / 2; // Note, BoostedLimit may go above monster classes num
}

//==========================================================================
//
//	WaveSpawn
//
//==========================================================================

void WaveSpawn()
{
	int		mClass;
	class	<Actor> MClass;
	bool	bBoosted;
	int		place;
	Actor	monster;

	// If current number of monsters is equal or greater than this, no new monsters are spawned until some of older ones are killed
	if (CountToSpawnMonsters + CountToSpawnBosses > 0 && (Level.TotalKills - Level.CurrentKills) < CountMonstersAtOnce)
	{
		// If we are to spawn bosses, let's spawn them randomly
		if (CountToSpawnBosses > 0 && (!CountToSpawnMonsters || Random() < 0.25))
		{
			//
			// Spawn Boss monster
			//
			mClass = P_Random() % BossClasses.Num;
			MClass = class<Actor>(FindClass(BossClasses[mClass]));
			CountToSpawnBosses--;
		}
		else
		{
			if (BoostedLimit >= 0 && Random() < 0.15)
			{
				//
				// Spawn boosted monster of weaker monster class
				//
				mClass = P_Random() % (BoostedLimit < MonsterClasses.Num ? BoostedLimit + 1 : MonsterClasses.Num);
				bBoosted = true;
			}
			else
			{
				//
				// Spawn normal monster
				//
				mClass = P_Random() % HiLimit + LoLimit;
			}

			MClass = class<Actor>(FindClass(MonsterClasses[mClass]));			

			CountToSpawnMonsters--;
		}

		place = P_Random() % Level.DeathmatchStarts.Num;
		monster = Level.Spawn(MClass,,, &Level.DeathmatchStarts[place]);
		if (monster)
		{
			Level.Spawn(TeleportFog, monster.GetCentre());
			// Maybe telefrag anything?
			monster.TeleportMove(monster.Origin, true);
			if (bBoosted)
			{
				// Spawn a boosted monster with enhanced stats
				float hlth = itof(monster.Health) * 2.5 + itof(P_Random() % Wave);
				monster.Health = ftoi(hlth);
				monster.Speed *= (monster.Speed * 2.5) + (Random() * (itof(Wave) / 100.0));
			}

			Level.NoiseAlert(Game.Players[0].MO, monster);
		}
	}
}

defaultproperties
{
	MonsterClasses.Num = 23;
	MonsterClasses[0] = 'KArenaHereticImp';
	MonsterClasses[1] = 'HereticMummy';
	MonsterClasses[2] = 'KArenaKnight';
	MonsterClasses[3] = 'HereticImpLeader';
	MonsterClasses[4] = 'HereticMummyLeader';
	MonsterClasses[5] = 'KArenaFireDemon';
	MonsterClasses[6] = 'KArenaWizard';
	MonsterClasses[7] = 'HereticMummyGhost';
	MonsterClasses[8] = 'KArenaKnightGhost';
	MonsterClasses[9] = 'HereticMummyLeaderGhost';
	MonsterClasses[10] = 'KArenaClink';
	MonsterClasses[11] = 'KArenaCentaur';
	MonsterClasses[12] = 'KArenaBeast';
	MonsterClasses[13] = 'KArenaSnake';
	MonsterClasses[14] = 'KArenaDemon1';
	MonsterClasses[15] = 'KArenaDemon2';
	MonsterClasses[16] = 'KArenaIceGuy';
	MonsterClasses[17] = 'KArenaCentaurLeader';
	MonsterClasses[18] = 'KArenaBishop';
	MonsterClasses[19] = 'Wraith';
	MonsterClasses[20] = 'KArenaCentaurMash';
	MonsterClasses[21] = 'KArenaDemon1Mash';
	MonsterClasses[22] = 'KArenaDemon2Mash';

	BossClasses.Num = 9;
	BossClasses[0] = 'KArenaDragon';
	BossClasses[1] = 'KArenaIronlich';
	BossClasses[2] = 'Minotaur';
	BossClasses[3] = 'MageBoss';
	BossClasses[4] = 'FighterBoss';
	BossClasses[5] = 'ClericBoss';
	BossClasses[6] = 'KArenaSorcerer1';
	BossClasses[7] = 'Heresiarch';
	BossClasses[8] = 'Korax';
}
