//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// Main bot class
class BotPlayer : Object;

Player player;		// Points to reference player
Actor botmo;

// Destinations
Actor item;			// Item (roam towards weapon, etc)
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal;			// Teamgame goal spot
Actor node;			// Node we're heading towards
Actor prev;			// Previous node we were at
TVec posdest;			// Position of our destination (doesn't have to be an actor)
bool posdest_valid;
Actor enemy;			// The dead meat.
TVec lastpos;			// Last place we saw our enemy
bool lastpos_valid;
Actor missile;			// A threathing missile that got to be avoided.

Actor ally;			// Ally to tag along with
float t_strafe;
float t_react;
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;

float forwardmove;	// For building ucmd
float sidemove;

// Misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

botinfo_t info;			// Aiming, name, perfection, yadda yadda

int angerlevel;

float combatdist[NUMWEAPONS * NUMCLASSES]; //different for each weapon.

float angle;			// The wanted angle that the bot tries to get every tic.

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//==========================================================================

void BotTick(float deltaTime)
{
	botmo = player.MO;

	player.ForwardMove = 0.0;
	player.SideMove = 0.0;
	player.FlyMove = 0.0;
	player.Buttons = 0;

	// We're dead, so hit space to respawn
	if (!player.Health)
	{
		player.Buttons |= BT_USE;
		return;
	}

	// Weed out any bad destinations/enemies
	CheckStuff();

	// Destination setting...
	SetEnemy();
	Scan();

	// Turning towards destination...
	BotAim();
	Turn();

	// Moving towards destination
	Attack();
	Move(deltaTime);

	Pitch();

	// Only walk if we're on skill 0
	if (!botskill)
	{
		if (forwardmove == FORWARDRUN)
			forwardmove = FORWARDWALK;
		if (forwardmove == -FORWARDRUN)
			forwardmove = -FORWARDWALK;
		if (sidemove == SIDERUN)
			sidemove = SIDEWALK;
		if (sidemove == -SIDERUN)
			sidemove = -SIDEWALK;
	}

	player.SideMove = sidemove;
	player.ForwardMove = forwardmove;

#define DECT(var) \
	var -= deltaTime; \
	if (var <= 0.0) \
	{ \
		var = 0.0; \
	}
	DECT(t_react)
	DECT(t_anticip)
#undef DECT
}

//==========================================================================
//
//	AngleTo
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	CheckItem
// 
//	Determines if we should bother picking up an item or not
//
//==========================================================================

bool CheckItem(Actor item)
{
	int weapon;
	int piece;
	int mana;

	bNewItemIsWeapon = false;
	bNewItemIsPowerup = false;
//?????
    if (!item)
		return false;
	if (!item.bSpecial)
		return false;

	weapon = WeapFromItem(item);
	if (weapon != -1)
	{
		bNewItemIsWeapon = true;

		if ((weapon>WP_FOURTH && player.exp_level<3) ||
			(weapon==WP_EIGHTH && player.exp_level<5)) {
			return false;
		}

		// If we don't have the weapon, pick it up
		if (!player.WeaponOwned[weapon])
			return true;

		// If we have no more room for the mana it gives
		if (//(weapon == WP_SECOND && player.Mana[MANA_1] == MAX_MANA) ||
			(weapon == WP_THIRD && player.Mana[MANA_2] == MAX_MANA) ||
			(weapon == WP_FOURTH && player.Mana[MANA_3] == MAX_MANA) ||
			(weapon == WP_FIFTH && player.Mana[MANA_1] == MAX_MANA) ||
			(weapon == WP_SIXTH && player.Mana[MANA_2] == MAX_MANA) ||
			(weapon == WP_SEVENTH && player.Mana[MANA_3] == MAX_MANA) ||
			(weapon == WP_EIGHTH && 
			((player.Mana[MANA_1] == MAX_MANA)&&
			(player.Mana[MANA_2] == MAX_MANA)&&
			(player.Mana[MANA_3] == MAX_MANA))))
			return false;
	}

/*	piece = WeapPieceFromItem(item);
	if (piece != -1)
	{
		bNewItemIsWeapon = true;

		// If we don't have the weapon, pick it up
//[Korax]
/*		if (!(player.Pieces & piece))
			return true;

		// If we have no more room for the mana it gives
		if (player.Mana[MANA_1] == MAX_MANA &&
			player.Mana[MANA_2] == MAX_MANA)
			return false;
*/
	if (WeaponPiece(item))
	{
		if (player.Mana[MANA_3] == MAX_MANA)
			return false;
	}

	mana = ManaFromItem(item);
	if (mana != -1)
	{
		// If we have no more room for the mana it gives
		if (mana == MANA_1 && player.Mana[MANA_1] == MAX_MANA)
			return false;
		if (mana == MANA_2 && player.Mana[MANA_2] == MAX_MANA)
			return false;
		if (mana == MANA_3 && player.Mana[MANA_3] == MAX_MANA)
			return false;
	}

	if ((item.Class == ItemHealingBottle ||
		 item.Class == ArtifactHealthFlask ||
		 item.Class == ArtifactSuperHeal)
		&& (player.MO.Health >= player.max_health))
		return false;

	if (Artifact(item) && !ArtifactBoostArmor(item) &&
		!ArtifactInvulnerability(item) && !ArtifactSpeedBoots(item))
		return false;
	if (Key(item) && deathmatch)
		return false;
	// Guess we're okay
	return true;
}

//==========================================================================
//
//	SetEnemy
//
//==========================================================================

void SetEnemy(void)
{
	if (enemy && enemy.Health > 0 && player.MO &&
		player.MO.CanSee(enemy))
	{
		return;
	}

	bAllRound = !!enemy;
	enemy = FindEnemy();

	if (!enemy)
		return;
	
	// Double check the validity of the enemy
	if (!enemy.bShootable)
		enemy = none;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if an location is reachable
//
//==========================================================================

bool CheckTo(TVec pos)
{
	float dist;
	float an;

	dist = Length(botmo.Origin - pos);
	an = GetAngle();

	if (!CheckPath(an, dist))
		return false;
	
	return true;
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff(void)
{
	if (item)
	{
		if (!item.bSpecial || item.IsDestroyed() || // somebody picked
				!CheckTo(item.Origin)) // Can't reach
			item = none;
	}

	if (missile)
	{
		if (!missile.bMissile || missile.IsDestroyed())
			missile = none;
	}

	if (node)
	{
		if (!CheckTo(node.Origin) || (MobjDist2(botmo, node) < botmo.Radius))
		{
			prev = node;
			node = none;
		}
	}

	if (posdest_valid)
	{
		TVec dir;
		dir = posdest - botmo.Origin;
		dir.z = 0.0;
		if ((Length(dir) < botmo.Radius) || !CheckTo(posdest))
		{
			posdest_valid = false;
		}
	}

	if (lastpos_valid)
	{
		TVec dir;
		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if ((Length(dir) < botmo.Radius) || !CheckTo(lastpos))
		{
			lastpos_valid = false;
		}
	}

	if (enemy)
	{
		if (enemy.Health <= 0 || !enemy.bShootable)
			enemy = none;
	}
}

//==========================================================================
//
//	Scan
//
//	Scan all mobj's visible to the bot for incoming missiles, enemies, and
// various items to pick up.
//
//==========================================================================

void Scan(void)
{
	Actor actor;

	FOREACH(Actor, actor)
	{
		if (!actor.bSpecial && !actor.bMissile)
		{
			// Not interested in this one
			continue;
		}
		if (Check_LOS(actor, 90.0))
		{
			// Look for special items
			if (!item && actor.bSpecial)
			{
				if (CheckItem(actor))
				{
					item = actor;
					bItemIsWeapon = bNewItemIsWeapon;
					bItemIsPowerup = bNewItemIsPowerup;
				}
			}
			else if (!missile && actor.bMissile &&
				(MobjDist(botmo, actor) < AVOID_DIST))
			{
				missile = actor;
			}
		}
	}
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
		return skill;

	skill -= num;
	if (skill < 0)
		skill = 0;

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
	angle = AngleMod360(an);
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle(void)
{
	return angle;
}

//==========================================================================
//
//	WeapFromItem
//
//	Returns a weapon type from an actor
//
//==========================================================================

int WeapFromItem(Actor item)
{
	if (WeaponPickup(item))
	{
		return WeaponPickup(item).WeaponType;
	}
/*	switch (player.PClass)
	{
	case PCLASS_FIGHTER:
		switch (item.Class)
		{
		case WeaponFAxe:
			return WP_THIRD;
		case WeaponFHammer:
			return WP_FOURTH;
		}
		break;
	case PCLASS_CLERIC:
		switch (item.Class)
		{
		case WeaponCSerpentStaff:
			return WP_FIFTH;
		case WeaponCFlame:
			return WP_SIXTH;
		}
		break;
	case PCLASS_MAGE:
		switch (item.Class)
		{
		case WeaponMCone:
			return WP_SEVENTH;
		case WeaponMLightning:
			return WP_EIGHTH;
		}
		break;
	}*/
	return -1;
}

//==========================================================================
//
//	WeapPieceFromItem
//
//	Returns a weapon type from an actor
//
//==========================================================================

int WeapPieceFromItem(Actor item)
{
	switch (player.PClass)
	{
	case PCLASS_FIGHTER:
		switch (item.Class)
		{
		case WeaponFSwordPiece1:
			return WPIECE1;
		case WeaponFSwordPiece2:
			return WPIECE2;
		case WeaponFSwordPiece3:
			return WPIECE3;
		}
		break;
	case PCLASS_CLERIC:
		switch (item.Class)
		{
		case WeaponCHolyPiece1:
			return WPIECE1;
		case WeaponCHolyPiece2:
			return WPIECE2;
		case WeaponCHolyPiece3:
			return WPIECE3;
		}
		break;
	case PCLASS_MAGE:
		switch (item.Class)
		{
		case WeaponMStaffPiece1:
			return WPIECE1;
		case WeaponMStaffPiece2:
			return WPIECE2;
		case WeaponMStaffPiece3:
			return WPIECE3;
		}
		break;
	}
	return -1;
}

//==========================================================================
//
//	ManaFromItem
//
//
// Returns an mana type from an actor
//
//==========================================================================

int ManaFromItem(Actor item)
{
	if (Mana(item))
	{
		return Mana(item).ManaType;
	}
/*	switch (item.Class)
	{
	case ItemManaBlue:
		return MANA_1;
	case ItemManaGreen:
		return MANA_2;
	case ItemManaCombined:
		return MANA_3;
	}*/
	return -1;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	bottracedir.z = 0.0;
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + dist * bottracedir.x;
 	y2 = y1 + dist * bottracedir.y;
	usething = botmo;

	P_UseLines(player);

	if (!P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS, 'PTR_BotPathTraverse'))
		return false;
	else
		return true;
}

//==========================================================================
//
//	Check_LOS
//
//	Doesnt check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(Actor to, float vangle)
{
	if (!botmo.CanSee(to))
		return false; // out of sight
	if (vangle == 360.0)
		return true;
	if (vangle == 0.0)
		return false; //Looker seems to be blind.

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	BotAim
//
//==========================================================================

void BotAim(void)
{
	float dist;
	bool right;
	float an;

	if (!enemy)
		return;

	if (t_react)
		return;

	// Distance to enemy.
	dist = MobjDist2(botmo, enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [BC] Cajun prediction... maybe use this somewhere
	/*
			{
			//Here goes the prediction.
			dist = P_AproxDistance(MO->x - enemy->x, MO->y - enemy->y);
			fixed_t m = (dist/FRACUNIT) / mobjinfo[MT_PLASMA].speed;
			bot->SetAngle(R_PointToAngle2(MO->x,
											MO->y,
											enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
											enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));
			}
	*/

	// Fix me: Implement botskill, accuracy, and intelligence
	if ((player.PClass == PCLASS_FIGHTER && player.ReadyWeapon >= WP_FIFTH || WP_SIXTH || WP_EIGHTH) ||
		(player.PClass == PCLASS_CLERIC && player.ReadyWeapon >= WP_SECOND || WP_SEVENTH || WP_EIGHTH) ||
		(player.PClass == PCLASS_MAGE && player.ReadyWeapon >= WP_FOURTH || WP_FIFTH || WP_SIXTH || WP_SEVENTH || WP_EIGHTH) ||
		(player.PClass == PCLASS_HERETIC && player.ReadyWeapon >= WP_THIRD || WP_FIFTH || WP_SIXTH || WP_EIGHTH) ||
		(player.PClass == PCLASS_MARINE && player.ReadyWeapon >= WP_FIFTH || WP_SEVENTH || WP_EIGHTH) || 
		(player.PClass == PCLASS_WITCHAVEN && player.ReadyWeapon >= WP_THIRD || WP_FOURTH || WP_SIXTH || WP_SEVENTH))
	if (combatdist[player.PClass * NUMWEAPONS + player.ReadyWeapon]>48.0)
	{
		// Projectile weapons
		switch (info.intelect)
		{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			// Aim right at the enemy
			SetAngle(an);
			break;
		case bsk_medium:
		case bsk_high:
		case bsk_excellent:
		case bsk_supreme:
			if (right)
				SetAngle(an + Random() * 20.0);
			else
				SetAngle(an - Random() * 20.0);
			break;

		default:
			Error("Unknown bot skill level: %d", info.accuracy);
			return;
		}
	}
	else
	{
		// Instant weapons
		switch (info.accuracy)
		{
		case bsk_verypoor:
			if (right)
				SetAngle(an + Random() * 60.0);
			else
				SetAngle(an - Random() * 60.0);
			break;
		case bsk_poor:
			if (right)
				SetAngle(an + Random() * 45.0);
			else
				SetAngle(an - Random() * 45.0);
			break;
		case bsk_low:
			if (right)
				SetAngle(an + Random() * 30.0);
			else
				SetAngle(an - Random() * 30.0);
			break;
		case bsk_medium:
			if (right)
				SetAngle(an + Random() * 15.0);
			else
				SetAngle(an - Random() * 15.0);
			break;
		case bsk_high:
			SetAngle(an);
			break;
		case bsk_excellent:
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		case bsk_supreme://FIXME
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		default:
			Error("Unknown bot skill level: %d", info.accuracy);
			return;
		}
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy(void)
{
	float closest_dist, temp;
	Actor target;
	float vangle;
	int i;

	//Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
		vangle = 360.0;
	else
		vangle = ENEMY_SCAN_FOV;
	bAllRound = false;

	target = none;
	closest_dist = 99999.0;

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (svvars->Players[i] && svvars->Players[i].MO &&
			svvars->Players[i].MO.Health > 0 && botmo != svvars->Players[i].MO)
		{
			if (deathmatch==2)
			{
				if (svvars->Players[i].Color==player.Color)
					continue;
			}
			 //Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always returns false. tought it should be the same checksight as below but.. (below works) something must be fuckin wierd screded up. 
			if (Check_LOS(svvars->Players[i].MO, vangle))
			{
				if (botmo.CanSee(svvars->Players[i].MO))
				{
					temp = MobjDist(svvars->Players[i].MO, botmo);
					if (temp < closest_dist)
					{
						closest_dist = temp;
						target = svvars->Players[i].MO;
					}
				}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	Roam
//
//	Handle non-attack/dodging movement
//
//==========================================================================

void Roam(void)
{
	TVec dest;

	if (lastpos_valid)
	{
		TVec dir;

		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if (Length(dir) <= 32.0)
		{
			lastpos_valid = false;
		}
	}

	// Order of item response precedence:
	if (goal)
	{
		dest = goal.Origin;
	}
	else if (lastpos_valid)
	{
		dest = lastpos;
	}
	else if (item)
	{
		dest = item.Origin;
	}
	else if (node)
	{
		dest = node.Origin;
	}
	else if (posdest_valid)
	{
		dest = posdest;
	}
	else
	{
		// No target, so just run around until we find something
		int r = P_Random();
		float an = GetAngle();
		float dist;

		for (dist = 256.0; dist >= 64.0; dist -= 64.0)
		{
			if (CheckPath(an, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an);
				posdest.y = botmo.Origin.y + dist * sin(an);
				posdest.z = botmo.Origin.z;
				SetAngle(an);
				break;
			}

			if (CheckPath(an + 45.0, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an + 45.0);
				posdest.y = botmo.Origin.y + dist * sin(an + 45.0);
				posdest.z = botmo.Origin.z;
				SetAngle(an + 45.0);
				break;
			}

			// Left is no good, try right
			if (CheckPath(an - 45.0, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an - 45.0);
				posdest.y = botmo.Origin.y + dist * sin(an - 45.0);
				posdest.z = botmo.Origin.z;
				SetAngle(an - 45.0);
				break;
			}
		}
		if (posdest_valid)
		{
			dest = posdest;
		}
		else
		{
			SetAngle(GetAngle() + 45.0 / 3.0);
			forwardmove = -FORWARDWALK;
			return;
		}
	}

	forwardmove = FORWARDRUN;
	SetAngle(AngleTo(dest));
}

//==========================================================================
//
//	Move
//
//	Main bot movement function.
//	Dodging/attacking movement is also handled here
//
//==========================================================================

void Move(float deltaTime)
{
	float dist;
	
	// Worry about missiles above all else
	if (missile)
	{
		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (!t_strafe)
			{
				// Don't change direction while dodging missiles (that could be bad)
				//bot->sidemove = -bot->sidemove;
				t_strafe = 2.0;
			}
		}

		// Look at the missle and sidestep it
		SetAngle(AngleTo(missile.Origin));
		forwardmove = -FORWARDRUN;
		return;
	}

	// Anticipate a shot: time to dodge!
	if (enemy && t_anticip <= 0.25)
	{
		if (!sidemove)
			sidemove = SIDERUN;

		switch (info.anticip)
		{
		case bsk_verypoor:
			// Deer caught in the headlights
			sidemove = 0.0;
			return;

		case bsk_poor:
			// Always walk right
			sidemove = SIDEWALK;
			break;

		case bsk_low:
			// Always run right
			sidemove = SIDERUN;
			break;

		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe)
			{
				t_strafe -= deltaTime;
				if (t_strafe <= 0.0)
				{
					sidemove = -sidemove;
					t_strafe = 2.0;
				}
			}
			break;

		case bsk_high:
			// Switch directions when we think our opponent will fire
			if (!t_anticip)
				sidemove = -sidemove;
			break;

		case bsk_excellent:
			// Move in a somewhat random direction when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;

				if (Random() < 0.5)
				{
					forwardmove = -FORWARDWALK;
				}
			}
			break;

		case bsk_supreme:
			// What a squirmy little fucker!
			if (!t_anticip)
			{
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}
			break;

		default:
			Error("Unknown bot skill level: %d", info.anticip);
			return;
		}
	}

	// Now handle attack movement
	if (enemy)
	{
		bool noforward;
		bool noside;
		float an;

		noforward = false;
		noside = false;
		if (!sidemove )
			sidemove = SIDERUN;

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		dist = MobjDist(botmo, enemy);

		// Remember where we saw him last in case he gets away
		lastpos = enemy.Origin;
		lastpos_valid = true;

		// Check if we'd rather pick up something than fight
		if (item)
		{
			if (bItemIsPowerup ||
				(bItemIsWeapon && player.ReadyWeapon == WP_FIRST || WP_SECOND))
			{
				Roam();
				return;
			}
		}

		an = botmo.Angles.yaw;
		if (sidemove < 0.0)
			an -= 90.0;
		else
			an += 90.0;

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
		{
			an += (an>180.0?-180.0:180.0);
			if (CheckPath(an, 48.0))
				sidemove = -sidemove;
			else
				sidemove = 0.0;
		}

		if (CheckTo(enemy.Origin) && dist >
			combatdist[player.PClass * NUMWEAPONS + player.ReadyWeapon])
		{
			//if (combatdist[player.PClass * NUMWEAPONS + player.ReadyWeapon] == 48.0)
			//print("Going forward %d %d", forwardmove, sidemove);
			forwardmove = FORWARDRUN;
		}
		else
			forwardmove = -FORWARDRUN;

		return;
	}

	if (t_strafe)
	{
		t_strafe -= deltaTime;
		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}
	}

	// Roam after an item
	Roam();
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack(void)
{
	// Still reacting to something or we don't have an enemy to fight
	if (t_react || !enemy)
		return;

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
		return;

	player.Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//
//==========================================================================

void Turn(void)
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

	if (!enemy)
	{
		player.ViewAngles.yaw = GetAngle();
		return;
	}

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
	case bsk_verypoor:
	case bsk_poor:
	case bsk_low:
		if (distance > 7.5)
			distance = 7.5;
		if (distance < -7.5)
			distance = -7.5;
		break;
	case bsk_medium:
		if (distance > 15.0)
			distance = 15.0;
		if (distance < -15.0)
			distance = -15.0;
		break;
	case bsk_high:
		if (distance > 22.5)
			distance = 22.5;
		if (distance < -22.5)
			distance = -22.5;
		break;
	case bsk_excellent:
		if (distance > 30.0)
			distance = 30.0;
		if (distance < -30.0)
			distance = -30.0;
		break;
	case bsk_supreme:
		if (distance > 37.5)
			distance = 37.5;
		if (distance < -37.5)
			distance = -37.5;
		break;
	}
	player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch(void)
{
	if (enemy)
	{
		TVec dir;
		TAVec ang;

		dir = enemy.Origin - botmo.Origin;
		VectorAngles(&dir, &ang);
		botmo.Angles.pitch = ang.pitch;
	}
	else
	{
		botmo.Angles.pitch = 0.0;
	}
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(Actor victim)
{
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;

	// [BC] Don't need to worry about following him anymore
	lastpos_valid = false;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(Actor killer)
{
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay(void)
{
	int botskill = 2;
	int bottype = 0;
	botinfo_t *binfo;
	int i;

	if (strcmp(ARR2STR(player.PlayerName), ""))
	{
		for (i = 0; i < NUMTOTALBOTS; i++)
		{
			if (!stricmp(botinfo[i].Name, ARR2STR(player.PlayerName)))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % NUMBOTTYPES;
	}

	binfo = &botinfo[bottype];

	t_strafe = 1.0;

	if (botskill > 4)
		botskill = 4;
	if (botskill < 0)
		botskill = 0;

	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - botskill);
	info.evade = SkillLower(binfo->evade, 4 - botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - botskill);
	strcpy(ARR2STR(player.UserInfo), binfo->userinfo);

	// Setup combat distance tables
	//[Korax]
	//[FB] What a terrible mess!!
	if (deathmatch)
	{
		float mod = 1.0;
		/* FIGHTER */
		combatdist[WP_FIRST]			= 48.0;
		combatdist[WP_SECOND]			= 48.0;
		combatdist[WP_THIRD]			= 48.0;
		combatdist[WP_FOURTH]			= 256.0 / mod;
		combatdist[WP_FIFTH]			= 384.0 / mod;
		combatdist[WP_SIXTH]			= 192.0 / mod;
		combatdist[WP_SEVENTH]			= 48.0;
		combatdist[WP_EIGHTH]			= 256.0 / mod;
		/* CLERIC */
		combatdist[4 + WP_FIRST]		= 48.0;
		combatdist[4 + WP_SECOND]		= 192.0 / mod;
		combatdist[4 + WP_THIRD]		= 48.0;
		combatdist[4 + WP_FOURTH]		= 256.0 / mod;
		combatdist[4 + WP_FIFTH]		= 192.0 / mod;
		combatdist[4 + WP_SIXTH]		= 1.0;
		combatdist[4 + WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[4 + WP_EIGHTH]		= 384.0 / mod;
		/* MAGE */
		combatdist[8 + WP_FIRST]		= 48.0;
		combatdist[8 + WP_SECOND]		= 192.0 / mod;
		combatdist[8 + WP_THIRD]		= 192.0 / mod;
		combatdist[8 + WP_FOURTH]		= 256.0 / mod;
		combatdist[8 + WP_FIFTH]		= 384.0 / mod;
		combatdist[8 + WP_SIXTH]		= 192.0 / mod;
		combatdist[8 + WP_SEVENTH]		= 384.0 / mod;
		combatdist[8 + WP_EIGHTH]		= 384.0 / mod;
		/* HERETIC */
		combatdist[16 + WP_FIRST]		= 48.0;
		combatdist[16 + WP_SECOND]		= 256.0 / mod;
		combatdist[16 + WP_THIRD]		= 192.0 / mod;
		combatdist[16 + WP_FOURTH]		= 256.0 / mod;
		combatdist[16 + WP_FIFTH]		= 256.0 / mod;
		combatdist[16 + WP_SIXTH]		= 384.0 / mod;
		combatdist[16 + WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0;
		combatdist[16 + WP_EIGHTH]		= 384.0 / mod;
		/* MARINE */
		combatdist[24 + WP_FIRST]		= 48.0;
		combatdist[24 + WP_SECOND]		= 192.0 / mod;
		combatdist[24 + WP_THIRD]		= 256.0 / mod;
		combatdist[24 + WP_FOURTH]		= 256.0 / mod;
		combatdist[24 + WP_FIFTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[24 + WP_SIXTH]		= 256.0 / mod;
		combatdist[24 + WP_SEVENTH]		= 384.0 / mod;
		combatdist[24 + WP_EIGHTH]		= 192.0 / mod;
		/* WITCHAVEN */
		combatdist[28 + WP_FIRST]		= 48.0;
		combatdist[28 + WP_SECOND]		= 48.0;
		combatdist[28 + WP_THIRD]		= 256.0 / mod;
		combatdist[28 + WP_FOURTH]		= 384.0 / mod;
		combatdist[28 + WP_FIFTH]		= 48.0;
		combatdist[28 + WP_SIXTH]		= 256.0 / mod;
		combatdist[28 + WP_SEVENTH]		= 256.0;
		combatdist[28 + WP_EIGHTH]		= 256.0 / mod;


		/*combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_SECOND]	= 192.0;
		combatdist[4 + WP_THIRD]	= 256.0;
		combatdist[4 + WP_FOURTH]	= 384.0;
		combatdist[8 + WP_FIRST]	= 192.0;
		combatdist[8 + WP_SECOND]	= 256.0;
		combatdist[8 + WP_THIRD]	= 384.0;
		combatdist[8 + WP_FOURTH]	= 384.0;*/
	}
	else
	{

		float mod = 1.0;
		/* FIGHTER */
		combatdist[WP_FIRST]			= 48.0;
		combatdist[WP_SECOND]			= 48.0;
		combatdist[WP_THIRD]			= 48.0;
		combatdist[WP_FOURTH]			= 256.0 / mod;
		combatdist[WP_FIFTH]			= 384.0 / mod;
		combatdist[WP_SIXTH]			= 192.0 / mod;
		combatdist[WP_SEVENTH]			= 48.0;
		combatdist[WP_EIGHTH]			= 256.0 / mod;
		/* CLERIC */
		combatdist[4 + WP_FIRST]		= 48.0;
		combatdist[4 + WP_SECOND]		= 192.0 / mod;
		combatdist[4 + WP_THIRD]		= 48.0;
		combatdist[4 + WP_FOURTH]		= 256.0 / mod;
		combatdist[4 + WP_FIFTH]		= 192.0 / mod;
		combatdist[4 + WP_SIXTH]		= 1.0;
		combatdist[4 + WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[4 + WP_EIGHTH]		= 384.0 / mod;
		/* MAGE */
		combatdist[8 + WP_FIRST]		= 48.0;
		combatdist[8 + WP_SECOND]		= 192.0 / mod;
		combatdist[8 + WP_THIRD]		= 192.0 / mod;
		combatdist[8 + WP_FOURTH]		= 256.0 / mod;
		combatdist[8 + WP_FIFTH]		= 384.0 / mod;
		combatdist[8 + WP_SIXTH]		= 192.0 / mod;
		combatdist[8 + WP_SEVENTH]		= 384.0 / mod;
		combatdist[8 + WP_EIGHTH]		= 384.0 / mod;
		/* HERETIC */
		combatdist[16 + WP_FIRST]		= 48.0;
		combatdist[16 + WP_SECOND]		= 256.0 / mod;
		combatdist[16 + WP_THIRD]		= 192.0 / mod;
		combatdist[16 + WP_FOURTH]		= 256.0 / mod;
		combatdist[16 + WP_FIFTH]		= 256.0 / mod;
		combatdist[16 + WP_SIXTH]		= 384.0 / mod;
		combatdist[16 + WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0;
		combatdist[16 + WP_EIGHTH]		= 384.0 / mod;
		/* MARINE */
		combatdist[24 + WP_FIRST]		= 48.0;
		combatdist[24 + WP_SECOND]		= 192.0 / mod;
		combatdist[24 + WP_THIRD]		= 256.0 / mod;
		combatdist[24 + WP_FOURTH]		= 256.0 / mod;
		combatdist[24 + WP_FIFTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[24 + WP_SIXTH]		= 256.0 / mod;
		combatdist[24 + WP_SEVENTH]		= 384.0 / mod;
		combatdist[24 + WP_EIGHTH]		= 192.0 / mod;
		/* WITCHAVEN */
		combatdist[28 + WP_FIRST]		= 48.0;
		combatdist[28 + WP_SECOND]		= 48.0;
		combatdist[28 + WP_THIRD]		= 256.0 / mod;
		combatdist[28 + WP_FOURTH]		= 384.0 / mod;
		combatdist[28 + WP_FIFTH]		= 48.0;
		combatdist[28 + WP_SIXTH]		= 256.0 / mod;
		combatdist[28 + WP_SEVENTH]		= 256.0;
		combatdist[28 + WP_EIGHTH]		= 256.0 / mod;


/*		combatdist[WP_FIRST]		= 48.0;
		combatdist[WP_SECOND]		= 48.0;
		combatdist[WP_THIRD]		= 192.0 / 2.0;
		combatdist[WP_FOURTH]		= 256.0 / 2.0;
		combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_SECOND]	= 192.0 / 2.0;
		combatdist[4 + WP_THIRD]	= 256.0 / 2.0;
		combatdist[4 + WP_FOURTH]	= 384.0 / 2.0;
		combatdist[8 + WP_FIRST]	= 192.0 / 2.0;
		combatdist[8 + WP_SECOND]	= 256.0 / 2.0;
		combatdist[8 + WP_THIRD]	= 384.0 / 2.0;
		combatdist[8 + WP_FOURTH]	= 384.0 / 2.0;*/
	}
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn(void)
{
	enemy = none;
}

//==========================================================================
//
//	GaveMana
//
//==========================================================================

void GaveMana(int mana)
{
	int i;
	if (player.ReadyWeapon == WP_FIRST)
	{
		for (i=NUMWEAPONS-1;i>-1;i--)
		{
			if (player.WeaponOwned[i]) 
			{
				player.PendingWeapon = i;
				return;
			}
		}
	}
}

defaultproperties
{
}
    
//**************************************************************************
//
//  $Log$
//  Revision 1.2  2005/05/12 20:54:06  firebrand_kh
//  Fixed and made a small check for the combat distance for bots
//
//  Revision 1.1  2004/11/16 13:33:21  dj_jl
//  Initial import.
//
//  Revision 1.3  2003/11/12 16:50:47  dj_jl
//  Changed player structure into a class
//
//  Revision 1.2  2003/07/11 16:47:39  dj_jl
//  Made array of players with pointers
//
//  Revision 1.1  2002/10/26 16:32:26  dj_jl
//  New style of defining classes.
//
//**************************************************************************
