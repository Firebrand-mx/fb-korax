//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The
//  main bot AI loop, B_Think, is called every tic.
//  Also included are various bot decision-making
//  procedures, such as B_CheckStuff and B_SetEnemy.
//
//**************************************************************************

// Main bot class
class BotPlayer : Object;

Player player;			// Points to reference player
Actor botmo;

// Destinations
Actor item;			// Item (roam towards weapon, etc)
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal;			// Teamgame goal spot
Actor node;			// Node we're heading towards
Actor prev;			// Previous node we were at
TVec posdest;			// Position of our destination (doesn't have to be an actor)
bool posdest_valid;
Actor enemy;			// The dead meat.
TVec lastpos;			// Last place we saw our enemy
bool lastpos_valid;
Actor missile;			// A threathing missile that got to be avoided.

Actor ally;			// Ally to tag along with
Actor last_mate;		// If bots mate dissapeared (not if died) that mate is
				// pointed to by this. Allows bot to roam to it if
				// necessary.

enemyinfo_t enemyinfo;		// Things we know about our enemy

//botstate_t state;		// What we're doing in teamgame mode

float	lastx;			// Last known x location of bot's enemy (go there if enemy goes out of sight)
float	lasty;			// Last known y location of bot's enemy

// Tickers

float t_respawn;
float t_strafe;
float t_react;
float t_fight;
float t_rocket;
float t_turn;
float t_pissed;
float t_frust;
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;
float t_chat;			// Tics left until bots completes "typing" in what he's saying.
				// Bot also doesn't do anything during this time.

float forwardmove;		// For building ucmd
float sidemove;

// Misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

chatline_t	*chatline;	// For when t_chat expires

/*bottype_t	bottype;	// Bot type*/
botinfo_t info;			// Aiming, name, perfection, yadda yadda

int angerlevel;

float combatdist[HexenDefs::NUMWEAPONS * HexenDefs::NUMCLASSES]; //different for each weapon.

float angle;			// The wanted angle that the bot tries to get every tic.

float count;			// [FB] Roam Count

float bottracerange;
TVec bottracedir;

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//==========================================================================

void BotTick(float deltaTime)
{
	botmo = player.MO;

	player.ForwardMove = 0.0;
	player.SideMove = 0.0;
	player.FlyMove = 0.0;
	player.Buttons = 0;

	// Don't do anything if we're talking
//	if (B_Chat())
//		return;

	// We're dead, so hit space to respawn
	if (!player.Health)
	{
		player.Buttons |= BT_USE;
		return;
	}

	// Periodically let out some anger
	if (!(player.Level.Game.level->time == 255.0))
	{
		if (angerlevel)
			angerlevel--;
		else if (angerlevel < 0)
			angerlevel = 0;
	}

	// [FB] Set an ally if we're in a mode that has one
	if (!player.Level.Game.deathmatch || player.Level.Game.deathmatch == 2 ||
		player.Level.Game.deathmatch == 3 || player.Level.Game.deathmatch == 4 || player.Level.Game.deathmatch == 5)
		ally = B_SetAlly();
	else
		ally = none;

	// [FB] Tag with our allies
	if (ally || (ally && !enemy))
	{
		Ally_Tag(deltaTime);
	}

	// Weed out any bad destinations/enemies
	CheckStuff();

	// Destination setting...
	SetEnemy();
	Scan();

	// Turning towards destination...
	BotAim();
	Turn();

	B_ChooseWeapon(); // [FB] Decide our weapon if we have an enemy

	Attack();
	Move(deltaTime);

	Pitch();

	// Only walk if we're on skill 0
	if (!MainGameInfo(player.Level.Game).botskill || player.Level.Game.gameskill == sk_baby)
	{
		if (forwardmove == FORWARDRUN)
			forwardmove = FORWARDWALK;
		if (forwardmove == -FORWARDRUN)
			forwardmove = -FORWARDWALK;
		if (sidemove == SIDERUN)
			sidemove = SIDEWALK;
		if (sidemove == -SIDERUN)
			sidemove = -SIDEWALK;
	}

	player.SideMove = sidemove;
	player.ForwardMove = forwardmove;

#define DECT(var) \
	var -= deltaTime; \
	if (var <= 0.0) \
	{ \
		var = 0.0; \
	}
	DECT(t_react)
	DECT(t_anticip)
#undef DECT
}

//==========================================================================
//
//	AngleTo
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	CheckItem
// 
//	Determines if we should bother picking up an item or not
//
//==========================================================================

bool CheckItem(Actor item)
{
	int weapon;
	int piece;
	int mana;

	bNewItemIsWeapon = false;
	bNewItemIsPowerup = false;
//?????
	if (!item)
		return false;
	if (!item.bSpecial)
		return false;

	weapon = WeapFromItem(item);
	if (weapon != -1)
	{
		bNewItemIsWeapon = true;

		/*if ((weapon > WP_FOURTH && player.exp_level < 2) ||
		      (weapon == WP_EIGHTH && player.exp_level < 3))
		{
			return false;
		}*/

		// If we don't have the weapon, pick it up
		if (!player.WeaponOwned[weapon])
			return true;

		// If we have no more room for the mana it gives
		if (//(weapon == WP_SECOND && player.Mana[MANA_1] == MAX_MANA) ||
			(weapon == HexenDefs::WP_THIRD && player.Mana[HexenDefs::MANA_2] == HexenDefs::MAX_MANA) ||
			(weapon == HexenDefs::WP_FOURTH && player.Mana[HexenDefs::MANA_3] == HexenDefs::MAX_MANA) ||
			(weapon == HexenDefs::WP_FIFTH && player.Mana[HexenDefs::MANA_1] == HexenDefs::MAX_MANA) ||
			(weapon == HexenDefs::WP_SIXTH && player.Mana[HexenDefs::MANA_2] == HexenDefs::MAX_MANA) ||
			(weapon == HexenDefs::WP_SEVENTH && player.Mana[HexenDefs::MANA_3] == HexenDefs::MAX_MANA) ||
			(weapon == HexenDefs::WP_EIGHTH && ((player.Mana[HexenDefs::MANA_1] == HexenDefs::MAX_MANA) &&
			(player.Mana[HexenDefs::MANA_2] == HexenDefs::MAX_MANA) &&
			(player.Mana[HexenDefs::MANA_3] == HexenDefs::MAX_MANA))))
			return false;
	}

/*	piece = WeapPieceFromItem(item);
	if (piece != -1)
	{
		bNewItemIsWeapon = true;

		// If we don't have the weapon, pick it up
//[Korax]
/*		if (!(player.Pieces & piece))
			return true;

		// If we have no more room for the mana it gives
		if (player.Mana[MANA_1] == MAX_MANA &&
			player.Mana[MANA_2] == MAX_MANA)
			return false;
*/
	if (WeaponPiece(item))
	{
		if (player.Mana[HexenDefs::NUMMANA] == HexenDefs::MAX_MANA)
			return false;
	}

	mana = ManaFromItem(item);
	if (mana != -1)
	{
		// If we have no more room for the mana it gives
		if (mana == HexenDefs::MANA_1 && player.Mana[HexenDefs::MANA_1] == HexenDefs::MAX_MANA)
			return false;
		if (mana == HexenDefs::MANA_2 && player.Mana[HexenDefs::MANA_2] == HexenDefs::MAX_MANA)
			return false;
		if (mana == HexenDefs::MANA_3 && player.Mana[HexenDefs::MANA_3] == HexenDefs::MAX_MANA)
			return false;
		if (mana == HexenDefs::MANA_4 && player.Mana[HexenDefs::MANA_4] == HexenDefs::MAX_MANA)
			return false;
		if (mana == HexenDefs::MANA_5 && player.Mana[HexenDefs::MANA_5] == HexenDefs::MAX_MANA)
			return false;
	}

	if ((item.Class == ItemHealingBottle ||
		 item.Class == ArtifactHealthFlask ||
		 item.Class == ArtifactSuperHeal)
		&& (player.MO.Health >= player.max_health))
		return false;

	if (Artifact(item) && !ArtifactBoostArmor(item) &&
		!ArtifactInvulnerability(item) && !ArtifactSpeedBoots(item)
		&& !ArtifactBoostMana(item) && !ArtifactInvisibility(item)
		&& !ArtifactPIDamage(item) && !ArtifactTorch(item))
		return false;

	if (Key(item) && player.Level.Game.deathmatch)
		return false;

	// [FB] Guess we're okay
	return true;
}

//==========================================================================
//
//	CheckPNodes
// 
//	[FB] Determines if the bot should get to a Path Node
//
//==========================================================================

bool CheckPNodes(Actor node)
{
#if 0 // [FB] This is all we will need to check for team games! WOW!!
			else if (!bot->node && actor->flags3 & MF3_NODE)// && P_CheckSight(MO, actor, false) && (bot->prev != actor && P_AproxDistance(MO->x - actor->x, MO->y - actor->y) <= 32*FRACUNIT))
			{
				if (actor->Class == MT_BOTPATH || actor->Class == MT_BOTSNIPE)
					bot->node = actor;
				else if (teamgame.value && bot->player->team != TM_NONE)
				{
					if (bot->player->team == TM_BLUE)
					{
						if (bot->state == BST_DEFENSE && ((int)actor->Class == (int)MT_BOTBLUEGUARD))
						{
							bot->node = actor;
						}
						else if (bot->state == BST_OFFENSE && ((int)actor->Class == (int)MT_BOTBLUEPATH))
						{
							bot->node = actor;
						}
						else if (bot->state == BST_RETURN && actor->Class == MT_BOTBLUEGOAL)
						{
							bot->node = actor;
						}
					}
					if (bot->player->team == TM_RED)
					{
						if (bot->state == BST_DEFENSE && ((int)actor->Class == (int)MT_BOTREDGUARD))
	
						{
							bot->node = actor;
						}
						else if (bot->state == BST_OFFENSE && ((int)actor->Class == MT_BOTREDPATH))
						{
							bot->node = actor;
						}
						else if (bot->state == BST_RETURN && ((int)actor->Class == MT_BOTREDGOAL))
						{
							bot->node = actor;
						}
					}
				}
			}
#endif
	// [FB] Just check if the actor is really a Path Node and it's reachable
	if (node.Class == PathNode && player.MO.CanSee(node) && prev != node && botmo.DistTo(node) < 32.0)
	{
			return true;
	}
	else // [FB] Don't use it if it's not a PathNode then...
	{
		return false;
	}
}

//==========================================================================
//
//	SetEnemy
//
//==========================================================================

void SetEnemy()
{
	if (enemy && enemy.Health > 0 && player.MO &&
		player.MO.CanSee(enemy))
	{
		return;
	}

	bAllRound = !!enemy;
	enemy = FindEnemy();

	if (!enemy)
		return;
	
	// Double check the validity of the enemy
	if (!enemy.bShootable)
		enemy = none;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if a location is reachable
//
//==========================================================================

bool CheckTo(TVec pos)
{
	float dist;
	float an;

	dist = Length(botmo.Origin - pos);
	an = GetAngle();

	if (!CheckPath(an, dist))
		return false;
	
	return true;
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff()
{
	if (item)
	{
		if (!item.bSpecial || item.IsDestroyed() || // somebody picked
				!CheckTo(item.Origin)) // Can't reach
			item = none;
	}

	if (missile)
	{
		if (!missile.bMissile || missile.IsDestroyed())
			missile = none;
	}

	if (node)
	{
		if (!CheckTo(node.Origin) || (botmo.DistTo(node) < botmo.Radius))
		{
			node = prev;
			prev = none;
		}
	}

	if (posdest_valid)
	{
		TVec dir;
		dir = posdest - botmo.Origin;
		dir.z = 0.0;
		if ((Length(dir) < botmo.Radius) || !CheckTo(posdest))
		{
			posdest_valid = false;
		}
	}

	if (lastpos_valid)
	{
		TVec dir;
		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if ((Length(dir) < botmo.Radius) || !CheckTo(lastpos))
		{
			lastpos_valid = false;
		}
	}

	if (enemy)
	{
		if (enemy.Health <= 0 || !enemy.bShootable)
			enemy = none;
	}
}

//==========================================================================
//
//	Scan
//
//	Scan all mobj's visible to the bot for incoming missiles, enemies, and
// various items to pick up.
//
//==========================================================================

void Scan()
{
	Actor actor;

	FOREACH(Actor, actor)
	{
		if (!actor.bSpecial && !actor.bMissile)
		{
			// Not interested in this one
			continue;
		}
		if (Check_LOS(actor, 90.0))
		{
			// Look for special items
			if (!item && actor.bSpecial)
			{
				if (CheckItem(actor))
				{
					item = actor;
					bItemIsWeapon = bNewItemIsWeapon;
					bItemIsPowerup = bNewItemIsPowerup;
				}
			}
			else if (!missile && actor.bMissile &&
				(botmo.DistTo(actor) < AVOID_DIST))
			{
				missile = actor;
			}
			else if(!node)
			{
				if (CheckPNodes(actor))
				{
					node = actor;
					prev = node;
				}
			}
		}
	}
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
		return skill;

	skill -= num;
	if (skill < 0)
		skill = 0;

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
	angle = AngleMod360(an);
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle()
{
	return angle;
}

//==========================================================================
//
//	WeapFromItem
//
//	Returns a weapon type from an actor
//
//==========================================================================

int WeapFromItem(Actor item)
{
	if (WeaponPickup(item))
	{
		return WeaponPickup(item).WeaponType;
	}
	return -1;
}

//==========================================================================
//
//	WeapPieceFromItem
//
//	Returns a weapon type from an actor
//
//==========================================================================

int WeapPieceFromItem(Actor item)
{
	if (WeaponPiece(item) &&
		WeaponPiece(item).PieceClass == player.PClass)
	{
		return WeaponPiece(item).PieceValue;
	}
	return -1;
}

//==========================================================================
//
//	ManaFromItem
//
//
// Returns a mana type from an actor
//
//==========================================================================

int ManaFromItem(Actor item)
{
	if (Mana(item))
	{
		return Mana(item).ManaType;
	}
	return -1;
}

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	switch (sec->special & ~SECSPEC_SECRET_MASK)
	{
	case 4:		// Scroll_EastLavaDamage
	case 5:		// Damage_LavaWimpy
	case 7:		// Damage_Sludge
	case 16:	// Damage_LavaHefty
		return true;
	}

	return false;
}

//==========================================================================
//
//	PTR_BotPathTraverse
//
//	[BC] For the bots
//	[FB] Additions for 3d floor checks
//
//==========================================================================

bool PTR_BotPathTraverse(intercept_t *in)
{
	Actor th;
	line_t *ld;
	TVec hit_point;

	if (in->bIsALine)
	{
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight;

		ld = in->line;	// This linedef
		hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

		// Line is impassible
		if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING))
			return false;

		// Line isn't two sided
		if (!ld->backsector)
			return false;

		if (!PointOnPlaneSide(botmo.Origin, ld))
		{
			back = ld->backsector;
			front = ld->frontsector;
		}
		else
		{
			back = ld->frontsector;
			front = ld->backsector;
		}

		// Sector is dangerous
		if (IsDangerous(back))
			return false;

		// [FB] Opening isn't big enough on the other side
		if (back->ceilingheight - front->floorheight <= botmo.Height)
		{
			return false;
		}

		// [FB] Ceiling is too low
		if (back->ceilingheight - back->floorheight <= botmo.Height)
		{
			return false;
		}

		// --- Special Cases ---

		// [FB] Columns on the front sector
		if (front->ceilingheight == front->floorheight)
		{
			return false;
		}

		// [FB] Columns on the back sector
		if (back->ceilingheight == back->floorheight)
		{
			return false;
		}

		// [FB] Now, let's check the 3d Floors!!
		if(front->bHasExtrafloors)
		{
			if(botmo.WaterLevel < 2)
			{
				// [FB] Opening isn't big enough on the other side
				if (back->ceilingheight - front->floorheight <= botmo.Height)
				{
					return false;
				}

				// [FB] Ceiling is too low
				if (back->ceilingheight - back->floorheight <= botmo.Height)
				{
					return false;
				}
			}

			// --- Special Cases For Extra Floors ---

			if(botmo.WaterLevel < 2)
			{
				// [FB] When the floor height of the floor in an extra floor
				// in the back sector is equal to the ceiling height of the
				// front sector with no extra floor
				if (front->ceilingheight - back->floorheight <= botmo.Height)
				{
					return false;
				}
	
				// [FB] When the floor height of the floor in an extra floor
				// in the front sector is equal to the ceiling height of the
				// back sector with no extra floor
				if (back->ceilingheight - front->floorheight <= botmo.Height)
				{
					return false;
				}
			}
		}

		// crosses a two sided line
		open = LineOpenings(ld, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);
		// No valid openings
		if (!open)
		{
			return false;
		}

		// No cliff jumping unless we're going after something
		if ((front->floorheight - back->floorheight) > 32.0 && !enemy)
		{
			return false;
		}

		diffheight = back->floorheight - front->floorheight;

		// [FB] What, diffheight is negative? Make it positive here
		if (diffheight < 0.0)
		{
			diffheight = -1.0 * diffheight;
		}
		else if (diffheight > 0.0)
		{
			if (diffheight > 48.0)
			{
			/*	if (front->SSpecial == ThrustThingZ || front->springpadzone)
				{
					return true;
				}
				else*/
					return false;
			}
			else if (diffheight >= 24.0 && diffheight <= 48.0)
			{
				botmo.Player.Buttons |= BT_JUMP;
			}
		}

		return true;
	}

	th = Actor(in->Thing);

	if (th == botmo)
		return true;

	if (th.bSolid)
		return false;

	// [FB] What's this, huh?
/*	float dheight;
	dheight = abs(th.Origin.z - shoot_thing.Origin.z);

	if (dheight > 0.0)
	{
		if (dheight >= 24.0 && dheight <= 48.0)
		{
			botmo.Player.Buttons |= BT_JUMP;
			return true;
		}
		else if (dheight <= 24.0)
			return true;
		else
			return false;
				
	}*/

	return true;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + dist * bottracedir.x;
 	y2 = y1 + dist * bottracedir.y;

	player.P_UseLines();

	if (!P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS, self, 'PTR_BotPathTraverse'))
		return false;
	else
		return true;
}

//==========================================================================
//
//	Check_LOS
//
//	Doesn't check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(Actor to, float vangle)
{
	if (!botmo.CanSee(to))
		return false; // out of sight
	if (vangle == 360.0)
		return true;
	if (vangle == 0.0)
		return false; // Looker seems to be blind.

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	BotAim
//
//==========================================================================

void BotAim()
{
	float dist;
	bool right;
	float an;

	if (!enemy)
		return;

	if (t_react)
		return;

	// Distance to enemy.
	dist = botmo.DistTo2(enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [BC] Cajun prediction... maybe use this somewhere
	/*
			{
			//Here goes the prediction.
			dist = P_AproxDistance(MO->x - enemy->x, MO->y - enemy->y);
			fixed_t m = (dist/FRACUNIT) / mobjinfo[MT_PLASMA].speed;
			bot->SetAngle(R_PointToAngle2(MO->x,
						      MO->y,
						      enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
						      enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));
			}
	*/

	// Fix me: Implement botskill, accuracy, and intelligence
	if (((player.PClass == HexenDefs::PCLASS_FIGHTER && player.ReadyWeapon == HexenDefs::WP_FIFTH || player.ReadyWeapon == HexenDefs::WP_SIXTH || player.ReadyWeapon == HexenDefs::WP_EIGHTH) ||
	    (player.PClass == HexenDefs::PCLASS_CLERIC && player.ReadyWeapon == HexenDefs::WP_SECOND || player.ReadyWeapon == HexenDefs::WP_SEVENTH || player.ReadyWeapon == HexenDefs::WP_EIGHTH) ||
	    (player.PClass == HexenDefs::PCLASS_MAGE && player.ReadyWeapon == HexenDefs::WP_FOURTH || player.ReadyWeapon == HexenDefs::WP_FIFTH || player.ReadyWeapon == HexenDefs::WP_SIXTH || player.ReadyWeapon == HexenDefs::WP_SEVENTH ||  player.ReadyWeapon == HexenDefs::WP_EIGHTH) ||
	    (player.PClass == HexenDefs::PCLASS_HERETIC && player.ReadyWeapon == HexenDefs::WP_THIRD || player.ReadyWeapon == HexenDefs::WP_FIFTH || player.ReadyWeapon == HexenDefs::WP_SIXTH || player.ReadyWeapon == HexenDefs::WP_EIGHTH) ||
	    (player.PClass == HexenDefs::PCLASS_MARINE && player.ReadyWeapon == HexenDefs::WP_FIFTH || player.ReadyWeapon == HexenDefs::WP_SEVENTH || player.ReadyWeapon == HexenDefs::WP_EIGHTH) ||
	    (player.PClass == HexenDefs::PCLASS_WITCHAVEN && player.ReadyWeapon == HexenDefs::WP_THIRD || player.ReadyWeapon == HexenDefs::WP_FOURTH || player.ReadyWeapon == HexenDefs::WP_SIXTH || player.ReadyWeapon == HexenDefs::WP_SEVENTH)))
	{
		// Projectile weapons
		switch (info.intelect)
		{
			case bsk_verypoor:
			case bsk_poor:
			case bsk_low:
				// Aim right at the enemy
				SetAngle(an);
				break;
			case bsk_medium:
			case bsk_high:
			case bsk_excellent:
			case bsk_supreme:
			if (right)
				SetAngle(an + Random() * 20.0);
			else
				SetAngle(an - Random() * 20.0);
			break;
			default:
				Error("Unknown bot skill level: %d", info.intelect);
			return;
		}
	}
	else
	{
		// Instant weapons
		switch (info.accuracy)
		{
			case bsk_verypoor:
				if (right)
					SetAngle(an + Random() * 60.0);
				else
					SetAngle(an - Random() * 60.0);
				break;
			case bsk_poor:
				if (right)
					SetAngle(an + Random() * 45.0);
				else
					SetAngle(an - Random() * 45.0);
				break;
			case bsk_low:
				if (right)
					SetAngle(an + Random() * 30.0);
				else
					SetAngle(an - Random() * 30.0);
				break;
			case bsk_medium:
				if (right)
					SetAngle(an + Random() * 15.0);
				else
					SetAngle(an - Random() * 15.0);
				break;
			case bsk_high:
				SetAngle(an);
				break;
			case bsk_excellent:
				SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
				break;
			case bsk_supreme://FIXME
				SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
				break;
			default:
				Error("Unknown bot skill level: %d", info.accuracy);
				return;
		}
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy()
{
	float closest_dist, dist;
	Actor target;
	float vangle;
	int i, light;
	Actor actor;


	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
		vangle = 360.0;
	else
		vangle = ENEMY_SCAN_FOV;
	bAllRound = false;


	// [FB] Look for monster enemy
	FOREACH(Actor, actor)
	{
		dist = botmo.DistTo(actor);

		if (!(actor.bEnemy))
			continue;
		if (!Check_LOS(actor, vangle))
			continue;
		if (!botmo.CanSee(actor))
			continue;
		// [FB] Don't attack our friendly minotaur in all these cases
		if (!player.Level.Game.deathmatch)
		{
			// [FB] For some gameplay modes, we just only check if it's a minotaur
			if (actor.Class == Minotaur)
				continue;
		}
		else if (player.Level.Game.deathmatch == 2 || player.Level.Game.deathmatch == 3 || 
			player.Level.Game.deathmatch == 4 || player.Level.Game.deathmatch == 5)
		{
			// [FB] Check if the minotaur's instigator is same colored as we are
			for(i=0; i < MAXPLAYERS; i++)
			{
				if (actor.Class == Minotaur && actor.Instigator == player.Level.Game.Players[i] && player.Level.Game.Players[i].Color == player.Color)
					continue;
			}
		}

		// [FB] We spawned the minotaur? we shouldn't attack him then!
		if (actor.bEnemy && actor.Class == Minotaur && actor.Instigator == botmo)
			continue;

		if (dist > MAX_MONSTER_TARGET_DIST)
			continue;

		target = none;
		closest_dist = 99999.0;

		 //Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always returns false. tought it should be the same checksight as below but.. (below works) something must be fuckin wierd screded up. 
		if (Check_LOS(actor, vangle))
		{
			if (botmo.CanSee(actor))
			{
				dist = botmo.DistTo(actor);
				light = actor.Sector->params.lightlevel; // [FB] Detect the light level

				// [FB] Too dark?
				if (dist > DARK_DIST && light < WHATS_DARK && !player.Powers[pw_infrared])
					continue;

				if (dist < closest_dist)
				{
					closest_dist = dist;
					target = actor;
				}
			}
		}

		return actor;
	}

	target = none;
	closest_dist = 99999.0;

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
			player.Level.Game.Players[i].MO.Health > 0 && botmo != player.Level.Game.Players[i].MO)
		{
			// [FB] Are we on a Team gameplay mode?
			if (player.Level.Game.deathmatch == 2 || player.Level.Game.deathmatch == 3 || 
				player.Level.Game.deathmatch == 4 || player.Level.Game.deathmatch == 5)
			{
				// [FB] Don't attack same team players
				if (player.Level.Game.Players[i].Color == player.Color)
					continue;
			}
			if (!player.Level.Game.deathmatch)
			{
				// [FB] Don't attack fellow players in some gameplay modes
				if (player.Level.Game.Players[i])
					continue;
			}
			//Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always
			//returns false. tought it should be the same checksight as below but.. (below works) something
			//must be fuckin wierd screded up. 
			if (Check_LOS(player.Level.Game.Players[i].MO, vangle))
			{
				if (botmo.CanSee(player.Level.Game.Players[i].MO))
				{
					dist = botmo.DistTo(player.Level.Game.Players[i].MO);
					light = player.Level.Game.Players[i].MO.Sector->params.lightlevel; // [FB] Detect the light level

					// [FB] Too dark?
					if (dist > DARK_DIST && light < WHATS_DARK && !player.Powers[pw_infrared])
						continue;

					if (dist < closest_dist)
					{
						closest_dist = dist;
						target = player.Level.Game.Players[i].MO;
					}
				}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	B_ChooseWeapon
//
//	[FB] Decide which weapon would be best to use in our situation
//
//==========================================================================

int B_ChooseWeapon()
{
	float dist;

	if (!enemy)
		return player.ReadyWeapon;

	if (enemy)
	{
		dist = botmo.DistTo(enemy);

		if (dist <= MELEERANGE)
		{
			switch(player.PClass)
			{
				case HexenDefs::PCLASS_FIGHTER:
				{
					if (player.WeaponOwned[HexenDefs::WP_FIRST])
						return HexenDefs::WP_FIRST;
			
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 5)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 5)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 5)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 50)
						return HexenDefs::WP_SEVENTH;
			
					// Didn't find anything good
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_CLERIC:
				{
					if (player.WeaponOwned[HexenDefs::WP_FIRST])
						return HexenDefs::WP_FIRST;

					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 5)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 5
					     && player.MO.Health < player.max_health)
						return HexenDefs::WP_SIXTH;

					// Didn't find anything good
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_MAGE:
				{
					if (player.WeaponOwned[HexenDefs::WP_FIRST])
						return HexenDefs::WP_FIRST;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					// Didn't find anything good
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_HERETIC:
				{
					if (player.WeaponOwned[HexenDefs::WP_FIRST])
						return HexenDefs::WP_FIRST;
			
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 15)
						return HexenDefs::WP_FOURTH;

					// Didn't find anything good
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_MARINE:
				{
					if (player.WeaponOwned[HexenDefs::WP_FIRST])
						return HexenDefs::WP_FIRST;
			
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 10)
						return HexenDefs::WP_THIRD;

					// Didn't find anything good			
					return player.ReadyWeapon;
					break;
				}
				if (player.PClass == HexenDefs::PCLASS_WITCHAVEN)
				{
					if (player.WeaponOwned[HexenDefs::WP_FIRST])
						return HexenDefs::WP_FIRST;
			
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 5)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 15)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					// Didn't find anything good
					return player.ReadyWeapon;
					break;
				}
			}
		}
		else if (dist <= 512.0)
		{
			switch(player.PClass)
			{
				case HexenDefs::PCLASS_FIGHTER:
				{
					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 5)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;
			
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_CLERIC:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 5)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 5)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 5
					     && player.MO.Health < player.max_health)
						return HexenDefs::WP_SIXTH;

					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_MAGE:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 3)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 3)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 7)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 15)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 20)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					return player.ReadyWeapon;
				}
				case HexenDefs::PCLASS_HERETIC:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 10)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 15)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 15)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 25)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_MARINE:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 10)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 3)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 10)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 25)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 8)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;
			
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_WITCHAVEN:
				{
					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 10)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 30)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 20)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					return player.ReadyWeapon;
					break;
				}
			}
		}
		else
		{
			switch(player.PClass)
			{
				case HexenDefs::PCLASS_FIGHTER:
				{
					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 5)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;
			
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_CLERIC:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 5)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 5)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 5
					     && player.MO.Health < player.max_health)
						return HexenDefs::WP_SIXTH;

					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_MAGE:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 3)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 3)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 7)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 15)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 20)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_HERETIC:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 10)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 15)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 15)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 25)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_MARINE:
				{
					if (player.WeaponOwned[HexenDefs::WP_SECOND] && player.Mana[HexenDefs::MANA_1] >= 2)
						return HexenDefs::WP_SECOND;

					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 10)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 3)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_FIFTH] && player.Mana[HexenDefs::MANA_1] >= 10)
						return HexenDefs::WP_FIFTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 25)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 8)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;
			
					return player.ReadyWeapon;
					break;
				}
				case HexenDefs::PCLASS_WITCHAVEN:
				{
					if (player.WeaponOwned[HexenDefs::WP_THIRD] && player.Mana[HexenDefs::MANA_2] >= 20)
						return HexenDefs::WP_THIRD;

					if (player.WeaponOwned[HexenDefs::WP_FOURTH] && player.Mana[HexenDefs::MANA_3] >= 10)
						return HexenDefs::WP_FOURTH;

					if (player.WeaponOwned[HexenDefs::WP_SIXTH] && player.Mana[HexenDefs::MANA_2] >= 30)
						return HexenDefs::WP_SIXTH;

					if (player.WeaponOwned[HexenDefs::WP_SEVENTH] && player.Mana[HexenDefs::MANA_3] >= 20)
						return HexenDefs::WP_SEVENTH;

					if (player.WeaponOwned[HexenDefs::WP_EIGHTH] && player.Mana[HexenDefs::NUMMANA] >= 100)
						return HexenDefs::WP_EIGHTH;

					return player.ReadyWeapon;
					break;
				}
				return player.ReadyWeapon;
			}
		}
	}
	return player.ReadyWeapon;
}

//==========================================================================
//
//	B_SetAlly
//
//	[FB] This function is called every tick (for each bot) to set the
//	     mate (teammate coop mate).
//
//==========================================================================

Actor B_SetAlly()
{
	float closest_dist, test;
	Actor target;
	int i, j;

	//is mate alive?
	if (ally)
	{
		if (ally.Health <= 0)
		{
			ally = none;
			return ally;
		}
		else
		{
			last_mate = ally;
			return ally;
		}
	}

	//Check old_mates status.
	if (!ally && last_mate)
	{
		if (last_mate.Health <= 0)
		{
			last_mate = none;
			ally = last_mate;
			return ally;
		}
		else
		{
			ally = last_mate;
			return ally;
		}

	}

	for (i = 0; i < MAXPLAYERS; i++)
	{
		// [FB] Set an ally for team game modes
		if (player.Level.Game.deathmatch == 2 || player.Level.Game.deathmatch == 3 || 
			player.Level.Game.deathmatch == 4 || player.Level.Game.deathmatch == 5)
		{
			if (player.Level.Game.Players[i] && player.Level.Game.Players[i].Color == player.Color)
			{
				ally = player.Level.Game.Players[i].MO;
				break;
			}
		}
		else if (!player.Level.Game.deathmatch) // [FB] Set an ally if we're in a mode that has one
		{
			if (player.Level.Game.Players[i])
			{
				ally = player.Level.Game.Players[i].MO;
				break;
			}
		}
	}

	closest_dist = 99999.0;

	//Check for player friends
	for (j = 0; j < MAXPLAYERS; j++)
	{
		// [FB] Team game modes
		if (player.Level.Game.deathmatch == 2 || player.Level.Game.deathmatch == 3 || 
			player.Level.Game.deathmatch == 4 || player.Level.Game.deathmatch == 5)
		{
			if ((player.Level.Game.Players[j])
			    && (botmo != player.Level.Game.Players[j].MO)
			    && (player.Level.Game.Players[j].Color == player.Color)
			    && (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2))
			{
				if (botmo.CanSee(player.Level.Game.Players[j].MO))
				{
					test = botmo.DistTo(player.Level.Game.Players[j].MO);

					if (test < closest_dist)
					{
						closest_dist = test;
						target = player.Level.Game.Players[j].MO;
						ally = target;
						break;
					}
				}
			}
		}
		else if(!player.Level.Game.deathmatch) // [FB] Other ally gameplay modes (no player color checking)
		{
			if ((player.Level.Game.Players[j])
			    && (botmo != player.Level.Game.Players[j].MO)
			    && (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2))
			{
				if (botmo.CanSee(player.Level.Game.Players[j].MO))
				{
					test = botmo.DistTo(player.Level.Game.Players[j].MO);

					if (test < closest_dist)
					{
						closest_dist = test;
						target = player.Level.Game.Players[j].MO;
						ally = target;
						break;
					}
				}
			}
		}
	}

	return none;
}

//==========================================================================
//
//	Roam
//
//	Handle non-attack/dodging movement
//
//==========================================================================

void Roam()
{
	TVec dest;

	if (lastpos_valid)
	{
		TVec dir;

		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if (Length(dir) <= 32.0)
		{
			lastpos_valid = false;
		}
	}

	// Order of item response precedence:
	if (goal)
	{
		dest = goal.Origin;
	}
	else if (lastpos_valid)
	{
		dest = lastpos;
	}
	else if (node)
	{
		dest = node.Origin;
	}
	else if (item)
	{
		dest = item.Origin;
	}
	else if (posdest_valid)
	{
		dest = posdest;
	}
	else
	{
		// No target, so just run around until we find something
		int r = P_Random();
		float an = GetAngle();
		float dist;

		for (dist = 256.0; dist >= 64.0; dist -= 64.0)
		{
			if (CheckPath(an, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an);
				posdest.y = botmo.Origin.y + dist * sin(an);
				posdest.z = botmo.Origin.z;
				SetAngle(an);
				break;
			}

			if (CheckPath(an + 45.0, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an + 45.0);
				posdest.y = botmo.Origin.y + dist * sin(an + 45.0);
				posdest.z = botmo.Origin.z;
				SetAngle(an + 45.0);
				break;
			}

			// Left is no good, try right
			if (CheckPath(an - 45.0, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an - 45.0);
				posdest.y = botmo.Origin.y + dist * sin(an - 45.0);
				posdest.z = botmo.Origin.z;
				SetAngle(an - 45.0);
				break;
			}
		}

		if (posdest_valid)
		{
			dest = posdest;
		}
		else
		{
			SetAngle(GetAngle() + 45.0 / 3.0);
			forwardmove = -FORWARDWALK;
			return;
		}
	}

	forwardmove = FORWARDRUN;
	SetAngle(AngleTo(dest));
}

//==========================================================================
//
//	Move
//
//	Main bot movement function.
//	Dodging/attacking movement is also handled here
//
//==========================================================================

void Move(float deltaTime)
{
	float dist;

	// Worry about missiles above all else
	if (missile)
	{
		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (!t_strafe)
			{
				// Don't change direction while dodging missiles (that could be bad)
				//bot->sidemove = -bot->sidemove;
				t_strafe = 2.0;
			}
		}

		// Look at the missile and sidestep it
		SetAngle(AngleTo(missile.Origin));
		forwardmove = -FORWARDRUN;
		return;
	}

	// Anticipate a shot: time to dodge!
	if (enemy && t_anticip <= 0.25)
	{
		if (!sidemove)
			sidemove = SIDERUN;

		switch (info.anticip)
		{
		case bsk_verypoor:
			// Deer caught in the headlights
			sidemove = 0.0;
			return;

		case bsk_poor:
			// Always walk right
			sidemove = SIDEWALK;
			break;

		case bsk_low:
			// Always run right
			sidemove = SIDERUN;
			break;

		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe)
			{
				t_strafe -= deltaTime;
				if (t_strafe <= 0.0)
				{
					sidemove = -sidemove;
					t_strafe = 2.0;
				}
			}
			break;

		case bsk_high:
			// Switch directions when we think our opponent will fire
			if (!t_anticip)
				sidemove = -sidemove;
			break;

		case bsk_excellent:
			// Move in a somewhat random direction when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;

				if (Random() < 0.5)
				{
					forwardmove = -FORWARDWALK;
				}
			}
			break;

		case bsk_supreme:
			// What a squirmy little fucker!
			if (!t_anticip)
			{
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}
			break;

		default:
			Error("Unknown bot skill level: %d", info.anticip);
			return;
		}
	}

	// Now handle attack movement
	if (enemy)
	{
		bool noforward;
		bool noside;
		float an;

		noforward = false;
		noside = false;
		if (!sidemove)
			sidemove = SIDERUN;

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		dist = botmo.DistTo(enemy);

		// Remember where we saw him last in case he gets away
		lastpos = enemy.Origin;
		lastpos_valid = true;

		// Check if we'd rather pick up something than fight
		if (item)
		{
			float itemdist;

			itemdist = botmo.DistTo(item);

			if (bItemIsPowerup ||
				(bItemIsWeapon && player.ReadyWeapon == HexenDefs::WP_FIRST || player.ReadyWeapon == HexenDefs::WP_SECOND)
				|| (enemy.bIsPlayer && bItemIsWeapon && player.ReadyWeapon < enemy.Player.ReadyWeapon)
				|| ((item.Class == ItemHealingBottle || item.Class == ArtifactHealthFlask
				|| item.Class == ArtifactSuperHeal) && (botmo.Health <= (player.max_health / 2)))
				&& itemdist <= GETINCOMBAT)
			{
				Roam();
				return;
			}
		}

		an = botmo.Angles.yaw;
		if (sidemove < 0.0)
			an -= 90.0;
		else
			an += 90.0;

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
		{
			an += (an>180.0?-180.0:180.0);
			if (CheckPath(an, 48.0))
				sidemove = -sidemove;
			else
				sidemove = 0.0;
		}

		if (CheckTo(enemy.Origin) && dist >
			combatdist[player.PClass * HexenDefs::NUMWEAPONS + player.ReadyWeapon])
		{
			//if (combatdist[player.PClass * NUMWEAPONS + player.ReadyWeapon] == 48.0)
			//print("Going forward %d %d", forwardmove, sidemove);
			forwardmove = FORWARDRUN;
		}
		else
			forwardmove = -FORWARDRUN;

		return;
	}

	// [FB] Follow our buddy if we're tagging along
	if (ally || (ally && !enemy))
	{
		Ally_Tag(deltaTime);
		return;
	}

	if (t_strafe)
	{
		t_strafe -= deltaTime;
		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}
	}

	// Roam after an item
	Roam();
}

//==========================================================================
//
//	Ally_Tag
//
// 	[FB] Follow our buddy if we're tagging along
//
//==========================================================================

void Ally_Tag(float deltaTime)
{
	float matedist, an;

	if (t_strafe)
	{
		t_strafe -= deltaTime;
		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}
	}

	matedist = botmo.DistTo(ally);

	SetAngle(AngleTo(ally.Origin));

	if (matedist > (FRIEND_DIST * 2.0))
		forwardmove = FORWARDRUN;
	else if (matedist > FRIEND_DIST)
		forwardmove = FORWARDWALK;
	else if (matedist < FRIEND_DIST - (FRIEND_DIST / 3.0)) // [FB] Got too close, so move away.
		forwardmove = -FORWARDWALK;
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack()
{
	// Still reacting to something or we don't have an enemy to fight
	if (t_react || !enemy)
		return;

	// [FB] Check if our allies are out of the way of the attack
	if (ally && Check_LOS(ally, SHOOTFOV))
		return;

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
		return;

	player.Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//
//==========================================================================

void Turn()
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

	if (!enemy)
	{
		player.ViewAngles.yaw = GetAngle();
		return;
	}

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
	case bsk_verypoor:
	case bsk_poor:
	case bsk_low:
		if (distance > 7.5)
			distance = 7.5;
		if (distance < -7.5)
			distance = -7.5;
		break;
	case bsk_medium:
		if (distance > 15.0)
			distance = 15.0;
		if (distance < -15.0)
			distance = -15.0;
		break;
	case bsk_high:
		if (distance > 22.5)
			distance = 22.5;
		if (distance < -22.5)
			distance = -22.5;
		break;
	case bsk_excellent:
		if (distance > 30.0)
			distance = 30.0;
		if (distance < -30.0)
			distance = -30.0;
		break;
	case bsk_supreme:
		if (distance > 37.5)
			distance = 37.5;
		if (distance < -37.5)
			distance = -37.5;
		break;
	}
	player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch()
{
	if (enemy)
	{
		TVec dir;
		TAVec ang;

		dir = enemy.Origin - botmo.Origin;
		VectorAngles(&dir, &ang);
		botmo.Angles.pitch = ang.pitch;
	}
	else
	{
		botmo.Angles.pitch = 0.0;
	}
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(Actor victim)
{
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;

	// [BC] Don't need to worry about following him anymore
	lastpos_valid = false;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(Actor killer)
{
}

//==========================================================================
//
//	BotSkill
//
//	[FB] Determine the bot skills depending the game skill, heh!
//
//==========================================================================

int BotSkill() // [FB] Select the right skill for the player
{
	if(player.Level.Game.gameskill == sk_nightmare)
	{
		return 4;
	}
	else if(player.Level.Game.gameskill == sk_hard)
	{
		return 3;
	}
	else if(player.Level.Game.gameskill == sk_medium)
	{
		return 2;
	}
	else if(player.Level.Game.gameskill == sk_easy)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay()
{
	int bottype;
	botinfo_t *binfo;
	int i;

	if (strcmp(ARR2STR(player.PlayerName), ""))
	{
		for (i = 0; i < NUMTOTALBOTS; i++)
		{
			if (!stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, ARR2STR(player.PlayerName)))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % NUMBOTTYPES;
	}

	binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];

	t_strafe = 1.0;

	MainGameInfo(player.Level.Game).botskill = BotSkill();

	if (MainGameInfo(player.Level.Game).botskill > 4)
		MainGameInfo(player.Level.Game).botskill = 4;
	if (MainGameInfo(player.Level.Game).botskill < 0)
		MainGameInfo(player.Level.Game).botskill = 0;

	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - MainGameInfo(player.Level.Game).botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - MainGameInfo(player.Level.Game).botskill);
	info.evade = SkillLower(binfo->evade, 4 - MainGameInfo(player.Level.Game).botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - MainGameInfo(player.Level.Game).botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - MainGameInfo(player.Level.Game).botskill);
	strcpy(ARR2STR(player.UserInfo), binfo->userinfo);

	// Setup combat distance tables
	//[Korax]
	//[FB] What a terrible mess!!
	if (player.Level.Game.deathmatch)
	{
		float mod = 1.0;
		/* FIGHTER */
		combatdist[HexenDefs::WP_FIRST]			= 1.0;
		combatdist[HexenDefs::WP_SECOND]			= 1.0;
		combatdist[HexenDefs::WP_THIRD]			= 1.0;
		combatdist[HexenDefs::WP_FOURTH]			= 256.0 / mod;
		combatdist[HexenDefs::WP_FIFTH]			= 384.0 / mod;
		combatdist[HexenDefs::WP_SIXTH]			= 192.0 / mod;
		combatdist[HexenDefs::WP_SEVENTH]			= 1.0;
		combatdist[HexenDefs::WP_EIGHTH]			= 256.0 / mod;
		/* CLERIC */
		combatdist[8 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[8 + HexenDefs::WP_SECOND]		= 192.0 / mod;
		combatdist[8 + HexenDefs::WP_THIRD]		= 1.0;
		combatdist[8 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[8 + HexenDefs::WP_FIFTH]		= 192.0 / mod;
		combatdist[8 + HexenDefs::WP_SIXTH]		= 1.0;
		combatdist[8 + HexenDefs::WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[8 + HexenDefs::WP_EIGHTH]		= 384.0 / mod;
		/* MAGE */
		combatdist[16 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[16 + HexenDefs::WP_SECOND]		= 192.0 / mod;
		combatdist[16 + HexenDefs::WP_THIRD]		= 192.0 / mod;
		combatdist[16 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[16 + HexenDefs::WP_FIFTH]		= 384.0 / mod;
		combatdist[16 + HexenDefs::WP_SIXTH]		= 192.0 / mod;
		combatdist[16 + HexenDefs::WP_SEVENTH]		= 384.0 / mod;
		combatdist[16 + HexenDefs::WP_EIGHTH]		= 384.0 / mod;
		/* HERETIC */
		combatdist[24 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[24 + HexenDefs::WP_SECOND]		= 256.0 / mod;
		combatdist[24 + HexenDefs::WP_THIRD]		= 192.0 / mod;
		combatdist[24 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[24 + HexenDefs::WP_FIFTH]		= 256.0 / mod;
		combatdist[24 + HexenDefs::WP_SIXTH]		= 384.0 / mod;
		combatdist[24 + HexenDefs::WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0;
		combatdist[24 + HexenDefs::WP_EIGHTH]		= 384.0 / mod;
		/* MARINE */
		combatdist[32 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[32 + HexenDefs::WP_SECOND]		= 192.0 / mod;
		combatdist[32 + HexenDefs::WP_THIRD]		= 256.0 / mod;
		combatdist[32 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[32 + HexenDefs::WP_FIFTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[32 + HexenDefs::WP_SIXTH]		= 256.0 / mod;
		combatdist[32 + HexenDefs::WP_SEVENTH]		= 384.0 / mod;
		combatdist[32 + HexenDefs::WP_EIGHTH]		= 192.0 / mod;
		/* WITCHAVEN */
		combatdist[40 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[40 + HexenDefs::WP_SECOND]		= 1.0;
		combatdist[40 + HexenDefs::WP_THIRD]		= 256.0 / mod;
		combatdist[40 + HexenDefs::WP_FOURTH]		= 384.0 / mod;
		combatdist[40 + HexenDefs::WP_FIFTH]		= 1.0;
		combatdist[40 + HexenDefs::WP_SIXTH]		= 256.0 / mod;
		combatdist[40 + HexenDefs::WP_SEVENTH]		= 256.0;
		combatdist[40 + HexenDefs::WP_EIGHTH]		= 256.0 / mod;


/*		combatdist[WP_FIRST]		= 48.0;
		combatdist[WP_SECOND]		= 48.0;
		combatdist[WP_THIRD]		= 192.0;
		combatdist[WP_FOURTH]		= 256.0;
		combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_SECOND]	= 192.0;
		combatdist[4 + WP_THIRD]	= 256.0;
		combatdist[4 + WP_FOURTH]	= 384.0;
		combatdist[8 + WP_FIRST]	= 192.0;
		combatdist[8 + WP_SECOND]	= 256.0;
		combatdist[8 + WP_THIRD]	= 384.0;
		combatdist[8 + WP_FOURTH]	= 384.0;*/
	}
	else
	{
		float mod = 2.0;
		/* FIGHTER */
		combatdist[HexenDefs::WP_FIRST]			= 1.0;
		combatdist[HexenDefs::WP_SECOND]			= 1.0;
		combatdist[HexenDefs::WP_THIRD]			= 1.0;
		combatdist[HexenDefs::WP_FOURTH]			= 256.0 / mod;
		combatdist[HexenDefs::WP_FIFTH]			= 384.0 / mod;
		combatdist[HexenDefs::WP_SIXTH]			= 192.0 / mod;
		combatdist[HexenDefs::WP_SEVENTH]			= 1.0;
		combatdist[HexenDefs::WP_EIGHTH]			= 256.0 / mod;
		/* CLERIC */
		combatdist[8 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[8 + HexenDefs::WP_SECOND]		= 192.0 / mod;
		combatdist[8 + HexenDefs::WP_THIRD]		= 1.0;
		combatdist[8 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[8 + HexenDefs::WP_FIFTH]		= 192.0 / mod;
		combatdist[8 + HexenDefs::WP_SIXTH]		= 1.0;
		combatdist[8 + HexenDefs::WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[8 + HexenDefs::WP_EIGHTH]		= 384.0 / mod;
		/* MAGE */
		combatdist[16 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[16 + HexenDefs::WP_SECOND]		= 192.0 / mod;
		combatdist[16 + HexenDefs::WP_THIRD]		= 192.0 / mod;
		combatdist[16 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[16 + HexenDefs::WP_FIFTH]		= 384.0 / mod;
		combatdist[16 + HexenDefs::WP_SIXTH]		= 192.0 / mod;
		combatdist[16 + HexenDefs::WP_SEVENTH]		= 384.0 / mod;
		combatdist[16 + HexenDefs::WP_EIGHTH]		= 384.0 / mod;
		/* HERETIC */
		combatdist[24 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[24 + HexenDefs::WP_SECOND]		= 256.0 / mod;
		combatdist[24 + HexenDefs::WP_THIRD]		= 192.0 / mod;
		combatdist[24 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[24 + HexenDefs::WP_FIFTH]		= 256.0 / mod;
		combatdist[24 + HexenDefs::WP_SIXTH]		= 384.0 / mod;
		combatdist[24 + HexenDefs::WP_SEVENTH]		= SAFE_SELF_MISDIST * 2.0;
		combatdist[24 + HexenDefs::WP_EIGHTH]		= 384.0 / mod;
		/* MARINE */
		combatdist[32 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[32 + HexenDefs::WP_SECOND]		= 192.0 / mod;
		combatdist[32 + HexenDefs::WP_THIRD]		= 256.0 / mod;
		combatdist[32 + HexenDefs::WP_FOURTH]		= 256.0 / mod;
		combatdist[32 + HexenDefs::WP_FIFTH]		= SAFE_SELF_MISDIST * 2.0 / mod;
		combatdist[32 + HexenDefs::WP_SIXTH]		= 256.0 / mod;
		combatdist[32 + HexenDefs::WP_SEVENTH]		= 384.0 / mod;
		combatdist[32 + HexenDefs::WP_EIGHTH]		= 192.0 / mod;
		/* WITCHAVEN */
		combatdist[40 + HexenDefs::WP_FIRST]		= 1.0;
		combatdist[40 + HexenDefs::WP_SECOND]		= 1.0;
		combatdist[40 + HexenDefs::WP_THIRD]		= 256.0 / mod;
		combatdist[40 + HexenDefs::WP_FOURTH]		= 384.0 / mod;
		combatdist[40 + HexenDefs::WP_FIFTH]		= 1.0;
		combatdist[40 + HexenDefs::WP_SIXTH]		= 256.0 / mod;
		combatdist[40 + HexenDefs::WP_SEVENTH]		= 256.0;
		combatdist[40 + HexenDefs::WP_EIGHTH]		= 256.0 / mod;


/*		combatdist[WP_FIRST]		= 48.0;
		combatdist[WP_SECOND]		= 48.0;
		combatdist[WP_THIRD]		= 192.0 / 2.0;
		combatdist[WP_FOURTH]		= 256.0 / 2.0;
		combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_SECOND]	= 192.0 / 2.0;
		combatdist[4 + WP_THIRD]	= 256.0 / 2.0;
		combatdist[4 + WP_FOURTH]	= 384.0 / 2.0;
		combatdist[8 + WP_FIRST]	= 192.0 / 2.0;
		combatdist[8 + WP_SECOND]	= 256.0 / 2.0;
		combatdist[8 + WP_THIRD]	= 384.0 / 2.0;
		combatdist[8 + WP_FOURTH]	= 384.0 / 2.0;*/
	}
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn()
{
	enemy = none;
}

//==========================================================================
//
//	GaveMana
//
//==========================================================================

void GaveMana(int mana)
{
	int i;
	if (player.ReadyWeapon == HexenDefs::WP_FIRST)
	{
		for (i = HexenDefs::NUMWEAPONS - 1; i > -1; i--)
		{
			if (player.WeaponOwned[i]) 
			{
				player.PendingWeapon = i;
				return;
			}
		}
	}
}

defaultproperties
{
}
    
//**************************************************************************
//
//  $Log$
//  Revision 1.20  2006/02/28 02:50:46  firebrand_kh
//  Fixed checks for PTR_BotTransverse
//
//  Revision 1.19  2006/02/17 19:17:50  dj_jl
//  Moved common defs to classes.
//
//  Revision 1.18  2006/02/15 23:37:45  dj_jl
//  Moved all server progs global variables to classes.
//
//  Revision 1.17  2006/02/13 18:44:38  dj_jl
//  Moved all server progs global functions to classes.
//
//  Revision 1.16  2006/02/05 18:57:00  dj_jl
//  Moved common utils to level info class or built-in.
//
//  Revision 1.15  2006/01/12 16:33:11  firebrand_kh
//  Lots of fixes and improvements
//
//  Revision 1.14  2005/12/15 19:22:04  firebrand_kh
//  Fixed some bot skill checks and functions to calculate it
//
//  Revision 1.13  2005/12/11 21:37:29  dj_jl
//  Made path traversal callbacks class members.
//
//  Revision 1.12  2005/11/30 23:53:37  dj_jl
//  Switch statement requires integer.
//
//  Revision 1.11  2005/10/16 22:43:33  firebrand_kh
//  Fixed ally tracking and added more checks for it
//
//  Revision 1.10  2005/09/15 16:24:08  firebrand_kh
//  Made bots able to recognize allies and monster enemies, some other fixes
//
//  Revision 1.9  2005/08/27 14:11:51  firebrand_kh
//  Some fixes
//
//  Revision 1.8  2005/08/26 14:29:24  firebrand_kh
//  Bots now recognize and follow path nodes
//
//  Revision 1.7  2005/08/14 16:57:17  firebrand_kh
//  Made bots pickup new artifacts
//
//  Revision 1.6  2005/08/12 16:17:14  firebrand_kh
//  Fixes for bot skills depending the game skill of the game
//
//  Revision 1.5  2005/07/29 13:39:47  firebrand_kh
//  Changed level requirements for the weapon pickups
//
//  Revision 1.4  2005/07/27 21:17:13  firebrand_kh
//  Added lots of code and fixed some other
//
//  Revision 1.3  2005/05/18 15:41:41  firebrand_kh
//  Fixed bad definition for the new classes on the combat distance
//
//  Revision 1.2  2005/05/12 20:54:06  firebrand_kh
//  Fixed and made a small check for the combat distance for bots
//
//  Revision 1.1  2004/11/16 13:33:21  dj_jl
//  Initial import.
//
//  Revision 1.3  2003/11/12 16:50:47  dj_jl
//  Changed player structure into a class
//
//  Revision 1.2  2003/07/11 16:47:39  dj_jl
//  Made array of players with pointers
//
//  Revision 1.1  2002/10/26 16:32:26  dj_jl
//  New style of defining classes.
//
//**************************************************************************
