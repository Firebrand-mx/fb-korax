//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		    ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: BotPlayer.vc 1133 2007-11-26 23:13:04Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The main bot AI loop, BotTick,
//	is called every tic. Also included are various bot decision-making
//  procedures, such as CheckStuff, SetAction and ProcessPriorities.
//
//**************************************************************************

// Main bot class
class BotPlayer : Object;

const float
	//
	// Movement constants
	FORWARDWALK				= 200.0,
	FORWARDRUN				= 400.0,
	SIDEWALK				= 192.0,
	SIDERUN					= 320.0,

	//
	// Distance Constants
	MAX_TRAVERSE_DIST		= 307.2,		// 3 meters, used within b_func.c -> 1 meter = 102.4 units
	AVOID_DIST				= 512.0,		// Try avoid incoming missiles once they reached this close
	// [CW] CHECKME -- not used!
	SAFE_SELF_MISDIST		= 128.0,		// Distance from self to target where it's safe to pull a rocket.
	DARK_DIST				= 256.0,		// Distance that bot can see enemies in the dark from.
	MAX_MONSTER_TARGET_DIST	= 1024.0,		// 10 meters, used within b_func.c -> 1 meter = 102.4 units
	ENEMY_SCAN_FOV			= 120.0,
	MAXSTEPHEIGHT			= 32.0,
	MAXJUMPHEIGHT			= 56.0,
	MAXMOVEHEIGHT			= MAXJUMPHEIGHT,
	MAXDROPHEIGHT			= 384.0,
	GETINCOMBAT				= 512.0,		// Max distance to item if it's due to be picked up in a combat situation.
	SHOOTFOV				= 60.0,
	// [CW] CHECKME -- not used!
	MAXROAM					= (5.0 * 35.0);	// When this time is elapsed the bot will roam after something else.

const int
	WHATS_DARK		= 64,					// light value thats classed as dark.
	WHATS_VERYDARK	= 24;

/*

  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.

*/

// [FB] Bot Difficulty/skill settings/filters.
enum
{
	bsk_verypoor,
	bsk_poor,
	bsk_low,
	bsk_medium,
	bsk_high,
	bsk_excellent,
	bsk_supreme
};

struct botinfo_t
{
	string Name;		// Bot's name
	int accuracy;		// Accuracy with "instant" weapons (this includes "leading")
	int intelect;		// Accuracy with "missile" weapons (rocket launcher, etc.)
	int evade;			// Ability to dodge incoming missiles
	int anticip;		// Ability to anticipate "instant" shots
	int reaction;		// Overall reaction time (lower is "better")
	int pisschance;		// Chance the bot will get pissed when his threshold is reached
	int threshold;		// How much it takes to frustrate/piss off the bot
	int dangerlevel;	// When health is below this, we need some health
/*	int wpfav;			// Favorite weapon
	int chatinfo;		// Bot's chat strings
	int chattime;		// How long it takes us to type a line
	int chatty;			// How talkative the bot is
	char *colour;		// Colour (in form of a string)
	char *gender;		// Male/female/it :)
	char *skin;			// Skin
	int railcolour;		// Railgun trail colour
	bool revealed;		// Hidden bots must be revealed*/
	string userinfo;
};
/*
struct chatline_t
{
//	string		*string;
//	chattype_t  bot;
	chatline_t	*line;
};

struct chatinfo_t
{
	chatline_t		intro[5];
	chatline_t		inter[5];
	chatline_t		rare[5];
	chatline_t		frag[15];
	chatline_t		died[10];
	chatline_t		roam[10];
	chatline_t		pissed[5];
	chatline_t		frustrated[5];
	chatline_t		special[20];
};
*/
enum { NUMTOTALBOTS = 24 };
enum { NUMBOTTYPES = 24 };


//
// Bot states
//

//
// [CW] Priority counters: basically speaking, the one with larger value
//		determine what this Bot should aim to
//
enum
{
	priort_Weapons,		// tells how much Bot needs a new weapon
	priort_Ammo,		// tells how much Bot needs an ammo
	priort_AltAmmo,		// tells how much Bot needs an alternative ammo
	priort_Health,		// tells how much Bot needs health
	priort_Armor,		// tells how much Bot needs armor
	priort_Artifacts,	// tells how much Bot needs an artifact... not sure this would be useful, but let's have it
	priort_Special,		// tells how much Bot needs something special (e.g. special equipment)
	priort_Enemy,		// tells how much Bot needs to fight the enemy, ignoring all other things for awhile
	priort_Nemesis,		// tells how much Bot needs to fight the hated enemy, in particular
	priort_Evade,		// tells how much Bot needs to get away from enemies
	priort_Support,		// tells how much Bot needs to support his buddy in combat
	priort_Objective,	// tells how much Bot needs to take care of game objective
	priort_Wander,		// tells how much Bot needs to wander around the map
	NUM_PRIORITIES
						// those evening bells, those evening bells, so many things this priority tells...
};

int Priority[NUM_PRIORITIES];		// current priority values
int Prior_Targets[NUM_PRIORITIES];	// prioritised list of actions

// [CW] Priority additive values (by categories)
enum
{
	priorv_Weapons_BadEquipment		= 24,	// has only low level weapons (1,2)
	priorv_Weapons_HeavyOffence		= 16,	// opponent wields more poweful weapon (currently)
	priorv_Weapons_HeavyOpponent	= 12,	// opponent has more powerful weapons
	priorv_Weapons_HeavyEnemies		= 10,	// enemies have more powerful weapons
	priorv_Weapons_NotTheBest		= 8,
	priorv_Weapons_LooserBonus		= 8,

	priorv_Ammo_Null				= 32,	// need ammo ...NOW!!
	priorv_Ammo_Low					= 12,	// overall ammo is low
	priorv_Ammo_ThisWeaponLow		= 8,	// ammo for selected weapon is low
	priorv_Ammo_NotMaximum			= 4,	// you can never be sure you have enouph
	priorv_Ammo_UnderFireBonus		= 16,	// can see enemy while ammo low (x2 if ammo null)
	priorv_Ammo_LooserBonus			= 8,

	priorv_AltAmmo_Null				= 24,	// need alt-ammo
	priorv_AltAmmo_Low				= 12,	// overall alt-ammo is low
	priorv_AltAmmo_NotMaximum		= 4,	// you can never be sure you have enouph
	priorv_AltAmmo_UnderFireBonus	= 16,	// can see enemy while ammo low (x2 if ammo null)
	priorv_AltAmmo_LooserBonus		= 8,

	priorv_Health_Dying				= 48,	// need health ...now!!... NO, FASTER THAN NOW!!
	priorv_Health_Low				= 24,	// health is low
	priorv_Health_NotMaximum		= 8,	// this won't last for long
	priorv_Health_UnderFireBonus	= 32,	// can see enemy while health low (x2 if dying)
	priorv_Health_LooserBonus		= 32,

	priorv_Armor_None				= 32,
	priorv_Armor_Low				= 12,
	priorv_Armor_Half				= 8,
	priorv_Armor_NotMaximum			= 4,
	priorv_Armor_LowHealthBonus		= 16,	// health is low, so some armor will be useful too
	priorv_Armor_UnderFireBonus		= 24,
	priorv_Armor_LooserBonus		= 24,

	priorv_Artifacts_WantSome		= 4,	// ..huh.. (TODO)

	priort_Special_XmasHavocFireWpn	= 24,	// Xmas Havoc is unplayable without fire weapons

	priorv_Enemy_Frustrated			= 24,	// arghh! arghh!! argh!!!
	priorv_Enemy_Pissed				= 18,	// arghh! I want to kill everyone!
	priorv_Enemy_Normal				= 8,	// just a normal urge to whack someone
	priorv_Enemy_HitMeBonus			= 12,	// enemy just hit me, I want revenge!

	priorv_Nemesis_Frustrated		= 48,
	priorv_Nemesis_Pissed			= 24,

	priorv_Evade					= 0,	// TODO

	priorv_Support					= 0,	// TODO

	priorv_Objective_Last			= 64,
	priorv_Objective_Loosing		= 48,
	priorv_Objective_NotFirst		= 32,
	priorv_Objective_Normal			= 24,
	priorv_Objective_NoScoreBonus	= 4,	// x1 if Not First, x2 if Loosing and x4 if last

	// both for Objective and Wander priority types
	priorv_Wander_Last				= 20,
	priorv_Wander_Loosing			= 16,
	priorv_Wander_NotFirst			= 12,
	priorv_Wander_Normal			= 8,
	priorv_Wander_NoScoreBonus		= 4,	// x1 if Not First, x2 if Loosing and x3 if last

	priorv_Game_FlagLostBonus		= 4
};
//
// [CW] So, idea is, that bot summarize its current situation periodically and decides what he should do next
//

const float AI_TIME_DELAY	= 5.0;	// in seconds
float AITime;

//
// Bot states
//
enum
{
	bst_decide,	// 	Bot is deciding what to do
	bst_offense,	// 	Bot is "fetching" something (offense)
	bst_defense,	// 	Bot is defending something
	bst_scoring		// 	Bot is heading to scoring place
};

struct botstate_t
{
	int BState;
	bool flag_lost;
};

Player player;			// Points to reference player
KArenaPlayerPawn botmo;
MainGameInfo gameInfo;

// [CW] try this...
Actor FTarget;			// final target (goal) ----- currently UNUSED
Actor ITarget;			// immediate target (where to go)
//TVec ITargetPos;		// immediate target position (valid in specific situations)
int IPriorityType;		// current ITarget priority type
TVec AttackOffset;		// basically, a point to get to just before heading to target
PathNode node_current;
array<PathNode> nodes;  // list of visited nodes (to make bot move freely along the map)

Actor enemy;			// The dead meat.
Actor nemesis;			// Prefered enemy to chase when pissed off

Actor ally;				// Ally to tag along with
Actor last_mate;		// If bots mate dissapeared (not if died) that mate is
						// pointed to by this. Allows bot to roam to it if
						// necessary.
Actor missile;			// A threathing missile that got to be avoided.

botstate_t botstate;	// What we're doing in teamgame mode

// Tickers
float t_respawn;
float t_strafe;
float t_react;
/* float t_fight;
float t_rocket;*/
float t_turn;
float t_hitme;			// someone hit me!!
float t_pissed;
float t_frust;
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;
//float t_chat;				// Tics left until bots completes "typing" in what he's saying.
						// Bot also doesn't do anything during this time.
float t_evade;			// evade missile ticker
float t_dodge;			// dodge enemy fire ticker

float forwardmove;		// For building ucmd
float sidemove;

// Flags, controlling movement
// regarding ITarget:
bool bSoftContact;			// ITarget is something that could be passed through without slowing down
bool bCanReachNoCare;		// Do not care if bot can reach destination
// regarding ITarget = enemy (or nemesis)
bool bMeleeUrge;			// Must come closer to enemy as quickly as possible
bool bKeepDistant;			// Enemy should be attacked from distance
bool bAttackOffsetValid;	// Use AttackOffset


// Misc booleans
bool bAllRound;

/* chatline_t	*chatline;	// For when t_chat expires

bottype_t	bottype;		// Bot type*/
botinfo_t info;				// Aiming, name, perfection, yadda yadda

int angerlevel;

float angle;			// The wanted angle (yaw) that the bot tries to get every tic.

// -----------------------------------------------------------
//
// Darkness Stats Update
//
// -----------------------------------------------------------

// [FB] Copy of certain affected stats for Darkness
int old_intelect;
int old_anticip;
int old_evade;
int old_accuracy;

// [FB] Used to determine if stats have been reduced
bool accuracy_r;
bool intelect_r;
bool evade_r;
bool anticip_r;

// -----------------------------------------------------------
//
// Pissed off Stats Update
//
// -----------------------------------------------------------

// [FB] Copy of certain affected stats for Darkness
int n_anticip;
int n_evade;
int n_accuracy;

// [FB] Used to determine if stats have been updated when pissed off
bool p_init;

//==========================================================================
//
//	AngleTo
//
//	Returns yaw angle to a certain location
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	PitchTo
//
//	Returns pitch angle to a certain location
//
//==========================================================================

float PitchTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.pitch;
}

//==========================================================================
//
//	SetAction
//
//	Decide what to do in teamgame (defend, whatever)
//
//==========================================================================

void SetAction()
{
	int i;
	int defenders = 0;
	int attackers = 0;

	// [FB] Run this routine only in some gameplay modes
	if (gameInfo.GameType != HexenDefs::game_ctf &&
		gameInfo.GameType != HexenDefs::game_football)
	{
		return;
	}

	// [CW] Moved from GetGameModeGoal --
	if (gameInfo.GameType == HexenDefs::game_ctf)
	{
		CTFBanner Banner;
		for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
		{
			Banner = GameCTF(gameInfo.GameModel).Banners[i];
			if (CTFBanner(Banner).Status == CTFBanner::BANNER_STATUS__CARRIED &&
				CTFBanner(Banner).Capturer == player)
			{
				// [FB] We are carrying, set our state to scoring to change our goal
				botstate.BState = bst_scoring;
			}
		}
	}

	// [FB] We are deciding what to do
	if (botstate.BState == bst_decide)
	{
		// Let's see what the other bots on our
		// team are doing, and decide our action based
		// off on that
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO && 
			    Player(player.Level.Game.Players[i]).bIsBot && 
			    Player(player.Level.Game.Players[i]).Team == player.Team)
			{
				// [FB] Is this bot in Offense?
				if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == bst_offense)
				{
					attackers++;
				}
				// [FB] Is this bot in Defense?
				else if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == bst_defense)
				{
					defenders++;
				}
			}
		}

#ifdef DEBUG_BOT_AI_TARGET
		print("BOT %s : Defenders: %d", player.PlayerName, defenders);
		print("BOT %s : Attackers: %d", player.PlayerName, attackers);
#endif
		// Defense wins championships...
		if ((!botstate.flag_lost || P_Random() < 128)
			&& defenders < attackers)
		{
			// [FB] Then get on defense
			botstate.BState = bst_defense;
#ifdef DEBUG_BOT_AI_TARGET
			print("BOT %s : Got defense", player.PlayerName);
#endif
		}
		else
		{
			// [FB] Then get on offense
			botstate.BState = bst_offense;
#ifdef DEBUG_BOT_AI_TARGET
			print("BOT %s : Got offense", player.PlayerName);
#endif
		}
	}
}

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	switch (sec->special & ~SECSPEC_SECRET_MASK)
	{
		case 4:		// Scroll_EastLavaDamage
		case 5:		// Damage_LavaWimpy
		case 7:		// Damage_Sludge
		case 16:	// Damage_LavaHefty
			return true;
	}

	return false;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//	[CW] keep in mind that this method is now used only during short move
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;
	intercept_t* in;
	float bottracerange;
	TVec bottracedir;
	float distance_passed;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	bottracedir.z = 0.0;	
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + botmo.Radius + dist * bottracedir.x;
 	y2 = y1 + botmo.Radius + dist * bottracedir.y;

	//	[BC] For the bots
	//	[FB] Additions for 3d floor checks
	foreach botmo.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS)
	{
		EntityEx th;
		line_t *ld;
		TVec hit_point;
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight, dheight;

		distance_passed = dist * in->frac;

		if (in->bIsALine)
		{
			ld = in->line;	// This linedef
			hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

			// [CW]
			if (distance_passed <= Player::USERANGE &&
				(in->line->SpacFlags & SPAC_UseThrough || in->line->SpacFlags & SPAC_Use))
			{
				// [FB] Use lines
				EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');
			}

			// Line is impassible
			if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING) ||
				(ld->flags & ML_BLOCKEVERYTHING))
			{
				return false;
			}

			// Line isn't two sided
			if (!ld->backsector)
			{
				return false;
			}

			if (!PointOnPlaneSide(botmo.Origin, ld))
			{
				back = ld->backsector;
				front = ld->frontsector;
			}
			else
			{
				back = ld->frontsector;
				front = ld->backsector;
			}

			// Sector is dangerous
			if (IsDangerous(back))
			{
				return false;
			}

			// crosses a two sided line
			open = LineOpenings(ld, hit_point);
			open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);

			// No valid openings
			if (!open || open->range <= botmo.Height)
			{
				return false;
			}
			else
			{
				// [FB] No cliff jumping unless we're going after something
				if ((open->lowfloor - open->bottom) >= MAXMOVEHEIGHT &&
					(open->lowfloor - open->bottom) <= MAXDROPHEIGHT && !(enemy && enemy == ITarget))
				{
					return false;
				}

				// [FB] Determine if it's wise to jump up to a floor
				diffheight = open->bottom - open->lowfloor;

				if (diffheight > 0.0)
				{
					if (diffheight >= MAXSTEPHEIGHT && diffheight <= MAXJUMPHEIGHT)
					{
						if (distance_passed <= 48.0)
						{
							player.Buttons |= BT_JUMP;
						}
						continue;
					}
					else if (diffheight >= MAXJUMPHEIGHT)
					{
						// CHECKME!!
					/*	if (front->SSpecial == ThrustThingZ || front->springpadzone)
						{
							return true;
						}
						else*/
							return false;
					}
				}
			}
		}
		else
		{
			th = EntityEx(in->Thing);

			if (Actor(th) == botmo)
			{
				continue;
			}

			if (th.bSolid && th != enemy)
			{
				// [FB] Jump to avoid something
				dheight = th.Origin.z + th.Height - botmo.Origin.z;

				if (dheight >= MAXSTEPHEIGHT && dheight <= MAXJUMPHEIGHT)
				{
					player.Buttons |= BT_JUMP;
					continue;
				}

				return false;
			}

			// [FB] Jump to reach something
			dheight = th.Origin.z + th.Height - botmo.Origin.z;

			if (dheight >= MAXSTEPHEIGHT && dheight <= MAXJUMPHEIGHT)
			{
				player.Buttons |= BT_JUMP;
				continue;
			}
		}
		
		// [CW] Since this method is for short distances only, we should
		//      break the procedure after certain distance is reached
		if (distance_passed >= MAX_TRAVERSE_DIST)
			break;
	}

	return true;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if a location is reachable
//
//==========================================================================

bool CheckTo(TVec pos, optional EntityEx TargetEntity)
{
	if (!specified_TargetEntity)
	{
		TargetEntity = none;
	}

	return botmo.CanReach(pos, TargetEntity, MAXJUMPHEIGHT, MAXDROPHEIGHT, botmo.Height);
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff()
{
	if (enemy)
	{
		if (!enemy.bShootable || enemy.bDormant || enemy.Health <= 0 ||
			!EntityEx(botmo).CanSee(enemy) ||
			// Special cases
			enemy.IsA('ZXmasHavocTree') &&
			(KArenaWeapon(player.ReadyWeapon).DamageTypeHint != 'Fire' ||
			!player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Either, false)))
		{
			enemy = none;
			t_dodge = 0.0;
		}
	}

	if (missile)
	{
		if (missile.IsDestroyed())
		{
			missile = none;
			t_evade = 0.0;
		}
	}

	// [CW]
	if (ITarget)
	{
		if (ITarget.IsA('Inventory'))
		{
			if (!enemy || enemy && botmo.DistTo(ITarget) <= GETINCOMBAT)
			{
				if (ITarget.Owner || ITarget.bInvisible)
				{
					ITarget = none;
					return;
				}
				else if (Length(botmo.Origin - ITarget.Origin) <= EntityEx::MELEERANGE)
				{
					if (!player.IsOKToPickupItem(Inventory(ITarget)))
					{
						// [FB] We can't actually pick up this
						ITarget = none;
						return;
					}
				}
			}
		}

		//
		// Special cases
		if (ITarget.IsA('DominationSigil') && DominationSigil(ITarget).Team == player.Team)
		{
			// [CW] Domination Sigil already captured
			ITarget = none;
			return;
		}
		// TODO -- think out same specials for CTF banner
		
		if (((ITarget == node_current) && (Length(botmo.Origin - ITarget.Origin) <= EntityEx::MELEERANGE)) ||
			!CheckTo(ITarget.Origin, ITarget))
		{
			#ifdef DEBUG_BOT_AI_TARGET
				print("reset target");
			#endif
			ITarget = none;
			return;
		}
	}
}

//==========================================================================
//
//	Check_LOS
//
//	Doesn't check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(EntityEx to, float vangle)
{
	if (!botmo.CanSee(to))
	{
		return false; // out of sight
	}
	if (vangle == 360.0)
	{
		return true;
	}
	if (vangle == 0.0)
	{
		return false; // Looker seems to be blind.
	}

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
	{
		return skill;
	}

	skill -= num;
	if (skill < 0)
	{
		skill = 0;
	}

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
	if (t_turn)
	{
		return;
	}

	angle = AngleMod360(an);
//	angle = an;

	if (!enemy)
	{
		return;
	}

	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
			t_turn = 4.0 / 3.0;
			break;
		case bsk_low:
			t_turn = 2.0 / 3.0;
			break;
		case bsk_medium:
			t_turn = 1.0 / 2.0;
			break;
		case bsk_high:
			t_turn = 1.0 / 4.0;
			break;
		case bsk_excellent:
			t_turn = 1.0 / 8.0;
			break;
		case bsk_supreme:
			break;
	}
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle()
{
	return angle;
}

//==========================================================================
//
//	AimProjectile
//
// 	[FB] Projectile weapons
//
//==========================================================================

void AimProjectile(float dist, bool right, float an)
{
	// [BC] Cajun prediction
	// Here goes the prediction.
	float m = (dist / 875.0); // FIXME Determine current weapon's missile speed
	float px = enemy.Origin.x + (/*enemy.Origin.x +*/ (enemy.Velocity.x * m * 2.0));
	float py = enemy.Origin.y + (/*enemy.Origin.y +*/ (enemy.Velocity.y * m * 2.0));

	switch (info.intelect)
	{
		case bsk_verypoor:
		case bsk_poor:
			if (MainGameInfo(player.Level.Game).botskill > 3 && Random() < 0.01)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
/*				SetAngle(R_PointToAngle2(MO->x,
					     MO->y,
					     enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
					     enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));*/	
			}
			else
			{
				// Aim right at the enemy
				SetAngle(an);
			}
			break;
		case bsk_low:
			if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.03)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				// Aim right at the enemy
				SetAngle(an);
			}
			break;
		case bsk_medium:
			if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.09)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		case bsk_high:
			if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.9)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		case bsk_excellent:
			if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.3)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		case bsk_supreme:
			if (MainGameInfo(player.Level.Game).botskill > 0 && Random() < 0.1)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		default:
			Error("BotPlayer::AimProjectile::Unknown bot accuracy skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	AimInstant
//
// 	[FB] Instant weapons
//
//==========================================================================

void AimInstant(float dist, bool right, float an)
{
	// [CW]
	if (info.accuracy > bsk_verypoor && info.accuracy <= bsk_high && dist <= EntityEx::MELEERANGE * 2.0)
	{
		SetAngle(an);
		return;
	}

	// FIXME: Implement botskill, accuracy, and intelligence
	switch (info.accuracy)
	{
		case bsk_verypoor:
			if (right)
			{
				SetAngle(an + Random() * 60.0);
			}
			else
			{
				SetAngle(an - Random() * 60.0);
			}
			break;
		case bsk_poor:
			if (right)
			{
				SetAngle(an + Random() * 45.0);
			}
			else
			{
				SetAngle(an - Random() * 45.0);
			}
			break;
		case bsk_low:
			if (right)
			{
				SetAngle(an + Random() * 30.0);
			}
			else
			{
				SetAngle(an - Random() * 30.0);
			}
			break;
		case bsk_medium:
			if (right)
			{
				SetAngle(an + Random() * 15.0);
			}
			else
			{
				SetAngle(an - Random() * 15.0);
			}
			break;
		case bsk_high:
			SetAngle(an);
			break;
		case bsk_excellent:
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		case bsk_supreme://FIXME
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		default:
			Error("BotPlayer::AimInstant::Unknown bot accuracy skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	Aim
//
//==========================================================================

void Aim()
{
	float dist;
	bool right;
	float an;
	int i;

	if (!enemy)
	{
		// [CW] ITarget can be other object, simply face its direction
		if (ITarget)
		{
			SetAngle(AngleTo(ITarget.Origin));
		}
		// [CW] Just look around
		else
		{
			SetAngle(GetAngle() + (Random() * 2.0 - 1.0) * 35.0);
		}
		return;
	}

	if (t_react > 4.0)
	{
		#ifdef DEBUG_BOT_AI_ATTACK
			print("BOT %s : my t_react = %f", player.PlayerName, t_react);
		#endif
		return;
	}

	// Distance to enemy.
	dist = botmo.DistTo(enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [FB] Set fire time
	t_fire = KArenaWeapon(player.ReadyWeapon).fire_tics;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		// [FB] Set t_anticip for our enemies
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
			player.Level.Game.Players[i].bIsBot &&
			Player(player.Level.Game.Players[i]).Bot.enemy && 
			Player(player.Level.Game.Players[i]).Bot.enemy == botmo)
		{
			Player(player.Level.Game.Players[i]).Bot.t_anticip = 
					KArenaWeapon(player.ReadyWeapon).refire_tics;
		}
	}

	// [FB] set pitch accordingly...
	Pitch();
	
	// [FB] ...and Decide which kind of aiming the bot will use
	if (KArenaWeapon(player.ReadyWeapon).bInstantRanged ||
		!(KArenaWeapon(player.ReadyWeapon).bBotProjectileMedium || KArenaWeapon(player.ReadyWeapon).bBotProjectile))
	{
		AimInstant(dist, right, an);
	}
	else
	{
		AimProjectile(dist, right, an);
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy(optional bool bReachable)
{
	float closest_dist, dist;
	Actor target;
	float vangle;
	int i, light;
	Actor actor;

	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
	{
		vangle = 360.0;
	}
	else
	{
		vangle = ENEMY_SCAN_FOV;
	}
	bAllRound = false;

	closest_dist = 99999.0;

	// [CW] no need to pass through this if there are no monsters on map 
	if (!GetCvar('NoMonsters'))
	{
		// [FB] Search for monster enemies
		foreach botmo.AllThinkers(Actor, actor)
		{
			dist = botmo.DistTo(actor);

			if (!(actor.bMonster))
			{
				continue;
			}

			if (actor.Health <= 0)
			{
				continue;
			}
			// [FB] We spawned the minotaur? we shouldn't attack him then!
			if (actor.Class == MinotaurFriend)
			{
				if (actor.Tracer == botmo)
				{
					continue;
				}
				// [FB] Don't attack a friendly minotaur in all these cases
				if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
					MainGameInfo(player.Level.Game).GameType == HexenDefs::game_survival)
				{
					continue;
				}
				else if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
				{
					bool SameTeam = false;
					// [FB] Check if an advanced game mode is active
					if (MainGameInfo(player.Level.Game).GameModel)
					{
						int teamfactor;

						teamfactor = KArenaGameModel(MainGameInfo(player.Level.Game).GameModel).TeamFactor(actor.Tracer,
									Actor(botmo));
						// [FB] We've got a team factor, just check if it's an ally or not
						if (teamfactor != KArenaGameModel::teamfactor_any &&
							teamfactor != KArenaGameModel::teamfactor_enemy)
						{
							continue;
						}
					}
					// [FB] Check if the minotaur's instigator is in the same team we are on
					for(i = 0; i < MAXPLAYERS; i++)
					{						
						if (actor.Tracer == player.Level.Game.Players[i] && 
							Player(player.Level.Game.Players[i]).Team == player.Team)
						{
							SameTeam = true;
							break;
						}
					}
					if (SameTeam)
					{
						continue;
					}					
				}
			}
			if (dist > MAX_MONSTER_TARGET_DIST)
			{
				continue;
			}

			 // Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always
			 // returns false. tought it should be the same checksight as below but.. (below works) something
			 // must be fuckin wierd screded up.
			if (dist <= EntityEx::MELEERANGE || Check_LOS(actor, vangle) && EntityEx(botmo).CanSee(actor))
			{
				light = actor.Sector->params.lightlevel; // [FB] Detect the light level
				if (actor.Sector->floor.LightSourceSector)
				{
					//[FB] Add static or dynamic lights?
					light += actor.Sector->floor.LightSourceSector;
				}
				// [FB] Too dark?
				// [CW] enhance this a bit, still human players usually CAN see in dark
				if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
				{
					if (light <= WHATS_VERYDARK)
					{
						if (P_Random() < 196)
						{
							continue;
						}
					}
					else if (P_Random() < 128)
					{
						continue;
					}
				}

				if (bReachable && !CheckTo(actor.Origin, actor))
				{
					continue;
				}

				if (dist < closest_dist)
				{
					closest_dist = dist;
					target = actor;
				}
			}
			return target;
		}
	}

	// [CW] Don't waste time searching enemy players if this is coop game mode
	if (MainGameInfo(player.Level.Game).bIsCoopGame[MainGameInfo(player.Level.Game).GameType])
	{
		return none;
	}

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
		    player.Level.Game.Players[i].MO.Health > 0 && !Player(player.Level.Game.Players[i]).bUnControllable && 
			botmo != player.Level.Game.Players[i].MO)
		{
			// [CW] Check if an advanced game mode is active
			if (MainGameInfo(player.Level.Game).GameModel)
			{
				int teamfactor;

				teamfactor = KArenaGameModel(MainGameInfo(player.Level.Game).GameModel).TeamFactor(Actor(botmo),
					     Actor(player.Level.Game.Players[i].MO));
				// [CW] We've got a team factor, check if it can be an enemy
				if (teamfactor != KArenaGameModel::teamfactor_any &&
				    teamfactor != KArenaGameModel::teamfactor_enemy)
				{
					continue;
				}
			}
			// [FB] Are we on a Team gameplay mode?
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				// [FB] Don't attack same team players
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
				{
					continue;
				}
			}
			// Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost
			// always returns false. tought it should be the same checksight as below but.. (below
			// works) something must be fuckin wierd screded up.
			// [CW] ok... let's see what is here...
			dist = botmo.DistTo(player.Level.Game.Players[i].MO);

			if (dist <= EntityEx::MELEERANGE ||
				((botmo.Sector->SoundTarget == player.Level.Game.Players[i].MO)
				  || Check_LOS(EntityEx(player.Level.Game.Players[i].MO), vangle)) &&
				  EntityEx(botmo).CanSee(player.Level.Game.Players[i].MO))
			{
				// [FB] Detect the light level
				light = player.Level.Game.Players[i].MO.Sector->params.lightlevel;
				if (player.Level.Game.Players[i].MO.Sector->floor.LightSourceSector)
				{
					//[FB] Add static or dynamic lights?
					light += player.Level.Game.Players[i].MO.Sector->floor.LightSourceSector;
				}
				// [FB] Too dark?
				// [CW] enhance this a bit, still human players usually CAN see in dark
				if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
				{
					if (light <= WHATS_VERYDARK)
					{
						if (P_Random() < 196)
						{
							continue;
						}
					}
					else if (P_Random() < 128)
					{
						continue;
					}
				}

				if (bReachable && !CheckTo(player.Level.Game.Players[i].MO.Origin,
												EntityEx(player.Level.Game.Players[i].MO)))
				{
					continue;
				}

				if (dist < closest_dist)
				{
					closest_dist = dist;
					target = Actor(player.Level.Game.Players[i].MO);
				}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	FindMissile
//
//	[FB] Check for Missiles to avoid
//
//==========================================================================

Actor FindMissile()
{
	Actor actor;

	foreach botmo.AllThinkers(Actor, actor)
	{
		if (actor.bMissile && !FastProjectile(actor) /*too little chance to avoid blaster missile*/
			&& actor.PInstigator != player && actor.Target != botmo &&
			(botmo.DistTo(actor) <= AVOID_DIST))
		{
			if (Check_LOS(actor, 90.0))
			{
				return actor;
			}
		}
	}

	return none;
}

//==========================================================================
//
//	PrepareWeapon
//
//==========================================================================

void PrepareWeapon()
{
	float dist;
	
	if (enemy)
		dist = botmo.DistTo(enemy);
	else
		dist = 99999.0; // [CW] be ready for anything

	// [FB] Decide our weapon if we have an enemy
	if (player.ReadyWeapon.bWimpyWeapon ||
		// Special cases
		(enemy && enemy.IsA('ZXmasHavocTree') &&
		 KArenaWeapon(player.ReadyWeapon).DamageTypeHint != 'Fire')
		)
	{
		Weapon Best = ChooseWeapon(dist);
		if (Best && Best != player.ReadyWeapon)
		{
			player.PendingWeapon = Best;
		}
	}
}

//==========================================================================
//
//	ChooseWeapon
//
//	[FB] Decide which weapon would be best to use in our situation
//
//==========================================================================

Weapon ChooseWeapon(float dist)
{
	Inventory		Item;
	KArenaWeapon	Wpn;
	Weapon			Best = none;

	//if (enemy)
	//{
		for (Item = botmo.Inventory; Item; Item = Item.Inventory)
		{
			Wpn = KArenaWeapon(Item);
			if (!Wpn)
			{
				//	Not a weapon.
				continue;
			}
			if (enemy && enemy.IsA('ZXmasHavocTree'))
			{
				// [FB] We only want to use weapons that do fire damage in XMAS Havoc!
				if (Wpn.DamageTypeHint != 'Fire')
				{
					continue;
				}
			}
			if (dist <= Actor::MELEERANGE)
			{
				if (!Wpn.bBotMelee)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else if (dist <= 512.0)
			{
				if (!Wpn.bBotProjectileMedium)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else
			{
				if (!Wpn.bBotProjectile)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			if (!Wpn.CheckAmmo(Wpn.FireMode, false))
			{
				//	Not enough ammo.
				continue;
			}
			Best = Wpn;
		}
		if (Best)
		{
			return Best;
		}
	//}
	// Didn't find anything good
	return player.ReadyWeapon;
}

//==========================================================================
//
//	ChooseBlastRadiusMode
//
//	[FB] Decide which blast radius mode would be best to use in our situation
//
//==========================================================================

bool ChooseBlastRadiusMode(float dist, int amount)
{
	if (dist <= Actor::MELEERANGE)
	{
		// [FB] We've got several choices here so we'll cycle them
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_BLASTRADIUS])
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS_INSTANT:
			case HexenDefs::ALTFIRE_BLASTRADIUS_BOMB:
				if (amount >= 10)
				{
					// [FB] We can keep this alternate weapon
					return true;
				}
				break;
		}
	}
	else if (dist <= 512.0)
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_BLASTRADIUS])
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS_MISSILE:
			case HexenDefs::ALTFIRE_BLASTRADIUS_BOMB:
			case HexenDefs::ALTFIRE_BLASTRADIUS_INSTANT:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	else
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_BLASTRADIUS])
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS_MISSILE:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	return false;
}

//==========================================================================
//
//	ChoosePoisonBagMode
//
//	[FB] Decide which flechette mode would be best to use in our situation
//
//==========================================================================

bool ChoosePoisonBagMode(float dist, int amount)
{
	if (dist <= Actor::MELEERANGE)
	{
		// [FB] We've got several choices here so we'll cycle them
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_POISONBAG])
		{
			case HexenDefs::ALTFIRE_POISONBAG_BOMB:
			case HexenDefs::ALTFIRE_POISONBAG_CLOUD:
				if (amount >= 10)
				{
					// [FB] We can keep this alternate weapon
					return true;
				}
				break;
		}
	}
	else if (dist <= 512.0)
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_POISONBAG])
		{
			case HexenDefs::ALTFIRE_POISONBAG_GRENADE:
			case HexenDefs::ALTFIRE_POISONBAG_CLOUD:
			case HexenDefs::ALTFIRE_POISONBAG_BOMB:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	else
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_POISONBAG])
		{
			case HexenDefs::ALTFIRE_POISONBAG_GRENADE:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	return false;
}

//==========================================================================
//
//	ChooseAltWeapon
//
//	[FB] Decide which alternate weapon would be best to use in our situation
//
//==========================================================================

bool ChooseAltWeapon()
{
	Ammo AltWpn;

	if (!!P_Random() & 1)
	{
		AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));

		if (ChooseBlastRadiusMode(botmo.DistTo(enemy), AltWpn ? AltWpn.Amount : 0))
		{
			player.Impulse = HexenDefs::IMPULSE__TOGGLE_BLASTRAD;
			return true;
		}
	}
	else
	{
		AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));

		if (ChoosePoisonBagMode(botmo.DistTo(enemy), AltWpn ? AltWpn.Amount : 0))
		{
			player.Impulse = HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
			return true;
		}
	}

	return false;
}

//==========================================================================
//
//	SetAlly
//
//	[FB] This function is called every tick (for each bot) to set the
//	     mate (teammate coop mate).
//
//==========================================================================

Actor SetAlly()
{
	float closest_dist, test;
	Actor target;
	int i, j;

	//is mate alive?
	if (ally)
	{
		if (ally.Health <= 0)
		{
			ally = none;
		}
		else
		{
			last_mate = ally;
		}
	}

	//Check old_mates status.
	if (!ally && last_mate)
	{
		if (last_mate.Health <= 0)
		{
			last_mate = none;
			ally = last_mate;
		}
		else
		{
			ally = last_mate;
		}
	}

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if ((player.Level.Game.Players[i]) && (player.Level.Game.Players[i].MO) &&
			(botmo != player.Level.Game.Players[i].MO))
		{
			if (MainGameInfo(player.Level.Game).GameModel) // [FB] Check if an advanced game mode is active
			{
				int teamfactor;

				teamfactor = KArenaGameModel(MainGameInfo(player.Level.Game).GameModel).TeamFactor(Actor(botmo),
							 Actor(player.Level.Game.Players[i].MO));
				// [FB] We've got a team factor, just check if it's an ally or not
				if (teamfactor != KArenaGameModel::teamfactor_any &&
					teamfactor != KArenaGameModel::teamfactor_enemy)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
				}
			}

			// [FB] Set an ally for team game modes
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
				}
			}
			else if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
				MainGameInfo(player.Level.Game).GameType == HexenDefs::game_survival) // [FB] Set an ally if we're in a mode that has one
			{
				ally = Actor(player.Level.Game.Players[i].MO);
			}
		}
	}

	closest_dist = 99999.0;

	//Check for player friends
	for (j = 0; j < MAXPLAYERS; j++)
	{
		if ((player.Level.Game.Players[j]) && (player.Level.Game.Players[j].MO) &&
			(botmo != player.Level.Game.Players[j].MO))
		{
			// [FB] Team game modes
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				if ((Player(player.Level.Game.Players[j]).Team == player.Team))
				{
					int HealthDanger = Player(player.Level.Game.Players[j]).bIsBot ?
									   Player(player.Level.Game.Players[j]).Bot.info.dangerlevel : 
									   Player(player.Level.Game.Players[j]).max_health / 2;
					if (player.Level.Game.Players[j].MO.Health <= HealthDanger)
					{
						if (botmo.CanSee(player.Level.Game.Players[j].MO))
						{
							test = botmo.DistTo(player.Level.Game.Players[j].MO);

							if (test < closest_dist)
							{
								closest_dist = test;
								target = Actor(player.Level.Game.Players[j].MO);
								ally = target;
							}
						}
					}
				}
			}
			else if(MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
				MainGameInfo(player.Level.Game).GameType == HexenDefs::game_survival) // [FB] Other ally gameplay modes (no player colour checking)
			{
				if (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2)
				{
					if (botmo.CanSee(player.Level.Game.Players[j].MO))
					{
						test = botmo.DistTo(player.Level.Game.Players[j].MO);

						if (test < closest_dist)
						{
							closest_dist = test;
							target = Actor(player.Level.Game.Players[j].MO);
							ally = target;
						}
					}
				}
			}
		}
	}

	return ally;
}

//==========================================================================
//
//	Roam
//
//	Handle direct movement to target
//
//==========================================================================

void Roam(TVec dest)
{
	// [CW] let it be only for 2d first
	float yaw_delta = botmo.Angles.yaw - AngleTo(dest);
	float distance = fabs(Length(dest - botmo.Origin));
	float distance_bak = distance;

	if (bSoftContact || bMeleeUrge)
	{
		distance *= 100.0;	// to ensure bot will reach as quickly as possible
	}

	// if there's an enemy around, bot should sometimes make zig-zags when running to target
	// TODO check bot skill here
	if (enemy && distance_bak >= 128.0 && (Random() < 0.5 || t_strafe <= 0.5))
	{
		yaw_delta += 45.0 * (Random() * 2.0) - 1.0;
	}

	float fw_delta = distance * cos(yaw_delta);
	float side_delta = distance * sin(yaw_delta);
		
	if (fw_delta > 0.0)
	{
		forwardmove = FORWARDRUN > fw_delta ? fw_delta : FORWARDRUN;
	}
	else
	{
		forwardmove = -FORWARDRUN < fw_delta ? fw_delta : -FORWARDRUN;
	}
	if (side_delta > 0.0)
	{
		sidemove = SIDERUN > side_delta ? side_delta : SIDERUN;
	}
	else
	{
		sidemove = -SIDERUN < side_delta ? side_delta : -SIDERUN;
	}

	TVec short_dest = botmo.Origin;
	short_dest.x += forwardmove * cos(botmo.Angles.yaw) + sidemove * cos(botmo.Angles.yaw - 90.0);
	short_dest.y += forwardmove * sin(botmo.Angles.yaw) + sidemove * sin(botmo.Angles.yaw - 90.0);
	CheckPath(AngleTo(short_dest), Length(short_dest - botmo.Origin));
}

//==========================================================================
//
//	Move
//
//	Main bot movement function.
//	Dodging/attacking movement is also handled here
//
//==========================================================================

void Move(float deltaTime)
{
	TVec dest;

	// [CW] Set a real destination for movement
	if (bMeleeUrge && enemy && (ITarget != enemy) && CheckTo(enemy.Origin, enemy))
	{
		dest = enemy.Origin;
	}
	else if (ITarget)
	{
		if (bAttackOffsetValid)
		{
			TAVec anglesFromOffset, anglesFromMO;
			TVec vOff = ITarget.Origin - AttackOffset;
			TVec vMO = ITarget.Origin - botmo.Origin;

			VectorAngles(&vOff, &anglesFromOffset);
			VectorAngles(&vMO, &anglesFromMO);
			
			// TODO: count accuracy level here maybe
			if (P_Random() < 64 && anglesFromMO.yaw >= anglesFromOffset.yaw - 5.0 &&
				anglesFromMO.yaw <= anglesFromOffset.yaw + 5.0)
			{
				dest = ITarget.Origin;
			}
			else
			{
				dest = AttackOffset;
			}
		}
		else
		{
			dest = ITarget.Origin;
		}
	}
	else
	{
		dest = botmo.Origin;
	}

	// Worry about missiles above all else
	if (missile && t_evade <= 0.0)
	{
		bool DoEvade = false;
		TVec crosspt;
		TVec missile_vel = missile.Velocity;
		missile_vel = Normalise(missile_vel);
		TVec missile_progression = missile.Origin + missile_vel * AVOID_DIST;
		float distto = botmo.DistTo(missile);

		if (missile.bSeekerMissile)
		{
			DoEvade = true;
		}
		// Check if the missile crosses our planned movement line in flight
		else if (LinesCross(botmo.Origin.x, botmo.Origin.y, dest.x, dest.y,
				 missile.Origin.x, missile.Origin.y, missile_progression.x, missile_progression.y,
				 &crosspt))
		{
			// Roughly calculate expected bot Z when at crosspt
			float rough_time = FMax(crosspt.x - botmo.Origin.x, crosspt.y - botmo.Origin.y) / FMax(FORWARDRUN, SIDERUN);
			if ((dest.x - botmo.Origin.x != 0.0) && (dest.y - botmo.Origin.y != 0.0))
			{
				crosspt.z = (botmo.Origin.z + (fabs(crosspt.x - botmo.Origin.x) * (dest.z - botmo.Origin.z) / fabs(dest.x - botmo.Origin.x))
							 +
							 botmo.Origin.z + (fabs(crosspt.y - botmo.Origin.y) * (dest.z - botmo.Origin.z) / fabs(dest.y - botmo.Origin.y))
							) / 2.0;
			}
			else
			{
				crosspt.z = dest.z;
			}

			TVec missile_at_rough_time = missile.Origin + missile.Velocity * rough_time;
			
			// Check roughly if missile will be dangerously close when bot is at crosspt
			if (Length(crosspt - missile_at_rough_time) <= 128.0)
			{
				DoEvade = true;
			}
		}

		// Do evasive action
		// TODO: check bot reaction and skill
		if (DoEvade)
		{
			if (!sidemove)
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;
			t_evade = 0.5;
		}
	}

	if (missile && t_evade > 0.0)
	{
		t_evade -= deltaTime;
		// TODO: check bot skill
		// Look at the missile to continue strafing around it
		SetAngle(AngleTo(missile.Origin));
		if (Random() < 0.33)
			player.Buttons |= BT_JUMP;
		return;
	}

	t_strafe -= deltaTime;

	// Try to dodge anticipated enemy fire
	if (enemy && enemy.bIsPlayer && t_dodge <= 0.0)
	{
		bool DoEvade = false;

		//
		// Anticipation time depends on skill
		switch (info.anticip)
		{
		case bsk_verypoor:
			// this guy does not dodge at all
			break;

		case bsk_poor:
			if (t_anticip <= 0.5)
				DoEvade = true;
			break;

		case bsk_low:
			if (t_anticip <= 0.4)
				DoEvade = true;
			break;

		case bsk_medium:
			if (t_anticip <= 0.25)
				DoEvade = true;
			break;

		case bsk_high:
			if (t_anticip <= 0.2)
				DoEvade = true;
			break;

		case bsk_excellent:
			if (t_anticip <= 0.15)
				DoEvade = true;
			break;

		case bsk_supreme:
			if (t_anticip <= 0.1) //[CW] CHECKME -- I wonder if BotTick is called often enough
				DoEvade = true;
			break;

		default:
			Error("BotPlayer::Move::Unknown bot anticipation skill level: %d", info.anticip);
			return;
		}

		// Anticipate a shot: time to dodge!
		if (DoEvade)
		{
			if (!sidemove)
			{
				sidemove = SIDERUN;
			}

			switch (info.anticip)
			{
			case bsk_poor:
				// Always walk right
				sidemove = SIDEWALK;
				break;

			case bsk_low:
				// Always run right
				sidemove = SIDERUN;
				break;

			case bsk_medium:
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;
				// More actions follow below
				break;

			case bsk_high:
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;
				// More actions follow below
				break;

			case bsk_excellent:
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;
				if (Random() < 0.5)
				{
					forwardmove = Random() < 0.5 ? FORWARDWALK : -FORWARDWALK;
				}
				break;

			case bsk_supreme:
				// What a squirmy little fucker!
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}

			// TODO: check bot reaction
			t_dodge = 0.5;
		}
	}
	
	if (enemy && enemy.bIsPlayer && t_dodge > 0.0)
	{
		switch (info.anticip)
		{
		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
			}
			break;
		case bsk_high:
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				if (Random() < 0.33)
				{
					forwardmove = -forwardmove;
				}
			}
			break;
		case bsk_excellent:
			if (t_strafe <= 0.5)
			{
				sidemove -= sidemove;
				forwardmove = -forwardmove;
				t_strafe = 0.0;
			}
		}

		t_dodge -= deltaTime;
		return; // continue with chosen evasion method
	}

	// If enemy is our target, do not rush things, use some combat tactics instead
	if (enemy && enemy == ITarget && !bMeleeUrge /* Melee Urge is handled differently */)
	{
		float an;

		if (!sidemove)
		{
			sidemove = SIDERUN;
		}

		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}

		an = GetAngle(); //botmo.Angles.yaw;
		if (sidemove < 0.0)
		{
			an -= 90.0;
		}
		else
		{
			an += 90.0;
		}

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
		{
			an += (an > 180.0 ? -180.0 : 180.0);
			if (CheckPath(an, 48.0))
			{
				sidemove = -sidemove;
			}
			else
			{
				sidemove = 0.0;
			}
		}
		return;
	}

	// And in the last (but not least) case, simply roam to the target
	if(dest != botmo.Origin)
		Roam(dest);
	else
	{
		// do nothing?
		SetAngle(GetAngle() + 15.0);
		forwardmove = -FORWARDWALK;
	}

	if (t_strafe <= 0.0)
	{
		t_strafe = 2.0;
	}
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack()
{
	// Intelligent bots don't attack if the enemy is invulnerable
	if (enemy.bInvulnerable)
	{
		if (info.intelect == bsk_medium && Random() < 0.15)
		{
			return;
		}
		else if (info.intelect == bsk_high && Random() < 0.3)
		{
			return;
		}
		else if (info.intelect == bsk_excellent && Random() < 0.45)
		{
			return;
		}
		else if (info.intelect == bsk_supreme && Random() < 0.5)
		{
			return;
		}
	}

	// Still reacting to something or we don't have an enemy to fight
	if (t_react > 2.0 || !enemy)
	{
		return;
	}

	// [FB] Check if our allies are out of the way of the attack
	if (ally && Check_LOS(ally, SHOOTFOV))
	{
		return;
	}

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
	{
		return;
	}

/*	// [FB] We are still shooting
	if (t_fire)
	{
		return;
	}*/
	
	// [FB] Don't attack if the distance is not the right one for this weapon
	float combatdist = player.ReadyWeapon.BotCombatDist;
	if ((MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
		MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweepteam ||
		MainGameInfo(player.Level.Game).GameType == HexenDefs::game_survival) &&
		combatdist > Actor::MELEERANGE)
	{
		combatdist /= 2.0;
	}
	if (botmo.DistTo(enemy) > combatdist)
	{
		return;
	}

	// [CW] Don't attack if incompatible damage type
	if (enemy.IsA('ZXmasHavocTree') && KArenaWeapon(player.ReadyWeapon).DamageTypeHint != 'Fire')
	{
		return;
	}

	player.Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	React
//
//	[FB] Called when bot receives damage
//
//==========================================================================

void React(EntityEx inflictor)
{
	bAllRound = true;

	// [CW]
	t_hitme += AI_TIME_DELAY + 1.0; // to make sure this will affect priority recalculations

	// [BC] 
	if (inflictor && inflictor != botmo && ally != inflictor)
	{
		if (!enemy)
		{
			enemy = Actor(inflictor);
//			t_react = player.DamageFlash + itof(info.reaction) * 2.0;
		}
		// [FB] Set reaction time
		switch (info.reaction)
		{
			case bsk_verypoor:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.6;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.6;
				}
				else
				{
					t_react = player.DamageFlash * 1.6;
				}
				break;
			case bsk_poor:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.5;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.5;
				}
				else
				{
					t_react = player.DamageFlash * 1.5;
				}
				break;
			case bsk_low:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.2;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.2;
				}
				else
				{
					t_react = player.DamageFlash * 1.2;
				}
				break;
			case bsk_medium:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.1;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.1;
				}
				else
				{
					t_react = player.DamageFlash * 1.1;
				}
				break;
			case bsk_high:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.0;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.0;
				}
				else
				{
					t_react = player.DamageFlash * 1.0;
				}
				break;
			case bsk_excellent:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 0.8;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 0.8;
				}
				else
				{
					t_react = player.DamageFlash * 0.8;
				}
				break;
			case bsk_supreme:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 0.6;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 0.6;
				}
				else
				{
					t_react = player.DamageFlash * 0.6;
				}
				break;
			default:
				Error("BotPlayer::React::Unknown bot reaction skill level: %d", info.reaction);
				return;
		}
	}
}

//==========================================================================
//
//	Alternate_Attack
//
//	[FB] Similar to Attack, but using alternate weapons
//
//==========================================================================

void Alternate_Attack()
{
	Ammo type;

	// Still reacting to something or we don't have an enemy to fight
	if (t_react > 2.0 || !enemy)
	{
		return;
	}

	// [FB] Have we chosen an alternate weapon?
	if (ChooseAltWeapon())
	{
		player.PlayerImpulse();

		// [FB] We just simply check which weapon is active and do what it's needed for it to work
		switch (player.altWeapon)
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS:
				type = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));
				if (type && type.Amount >= 10)
				{
					// No point in firing if we won't hit them
					if (!Check_LOS(enemy, 255.0))
					{
						return;
					}
					// [FB] Check if our allies are out of the way of the attack
					if (ally && Check_LOS(ally, 255.0))
					{
						return;
					}
					if (botmo.DistTo(enemy) > 255.0)
					{
						return;
					}

					// [FB] We've got enough ammo
					player.AlternateAttack();
				}
				break;
			case HexenDefs::ALTFIRE_POISONBAG:
				type = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));
				if (type && type.Amount >= 10)
				{
					// No point in firing if we won't hit them
					if (!Check_LOS(enemy, SHOOTFOV))
					{
						return;
					}
					// [FB] Check if our allies are out of the way of the attack
					if (ally && Check_LOS(ally, SHOOTFOV))
					{
						return;
					}

					// [FB] We've got enough ammo
					player.AlternateAttack();
				}
				break;
		}
	}
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//	[CW] Added turning in closest direction; disabled immediate turning
//	     when seeing no enemy.
//
//==========================================================================

void Turn()
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

#ifdef DEBUG_BOT_AI_TURN
	dprint("Turn: now %f to %f; d = %f", botmo.Angles.yaw, angle, distance);
#endif

	if (distance > 180.0)
	{
		distance -= 360.0;
	}
	else if (distance < -180.0)
	{
		distance += 360.0;
	}

#ifdef DEBUG_BOT_AI_TURN
	dprint("final d = %f", distance);
#endif

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			if (distance > 7.5)
			{
				distance = 7.5;
			}
			if (distance < -7.5)
			{
				distance = -7.5;
			}
			break;
		case bsk_medium:
			if (distance > 15.0)
			{
				distance = 15.0;
			}
			if (distance < -15.0)
			{
				distance = -15.0;
			}
			break;
		case bsk_high:
			if (distance > 22.5)
			{
				distance = 22.5;
			}
			if (distance < -22.5)
			{
				distance = -22.5;
			}
			break;
		case bsk_excellent:
			if (distance > 30.0)
			{
				distance = 30.0;
			}
			if (distance < -30.0)
			{
				distance = -30.0;
			}
			break;
		case bsk_supreme:
			if (distance > 37.5)
			{
				distance = 37.5;
			}
			if (distance < -37.5)
			{
				distance = -37.5;
			}
			break;
	}

#ifdef DEBUG_BOT_AI_TURN
	dprint("yaw was = %f", player.ViewAngles.yaw);
#endif

	player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);

#ifdef DEBUG_BOT_AI_TURN
	dprint("yaw now = %f", player.ViewAngles.yaw);
#endif
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch()
{
	TVec dir;
	TAVec ang;

	// [FB] Set pitch for underwater areas
	if (player.MO.WaterLevel > 2)
	{
		if (enemy)
		{
			if (enemy.Origin.z > botmo.Origin.z)
			{
				botmo.Angles.pitch = -PitchTo(enemy.Origin);
			}
			else if (enemy.Origin.z < botmo.Origin.z)
			{
				botmo.Angles.pitch = PitchTo(enemy.Origin);
			}
			return;
		}

		// [FB] Follow our buddy if we're tagging along
		if (ally || (ally && !enemy))
		{
			if (ally.Origin.z > botmo.Origin.z)
			{
				botmo.Angles.pitch = -PitchTo(ally.Origin);
			}
			else if (ally.Origin.z < botmo.Origin.z)
			{
				botmo.Angles.pitch = PitchTo(ally.Origin);
			}
			return;
		}
	}
	else
	{
		if (enemy)
		{
			if (enemy.Origin.z > botmo.Origin.z)
			{
				botmo.Angles.pitch = -PitchTo(enemy.Origin);
			}
			else if (enemy.Origin.z < botmo.Origin.z)
			{
				botmo.Angles.pitch = PitchTo(enemy.Origin);
			}
			return;
		}
	}

	botmo.Angles.pitch = 0.0;
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(EntityEx victim)
{
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx killer)
{
	// [FB] Accumulate anger
	angerlevel += 10;

	if(angerlevel > info.threshold)
	{
		//[FB] There's a chance that we can get pissed off
		if(P_Random() < info.pisschance && !t_pissed)
		{
			//[FB] Now we are pissed off!
			//	this actor will temporarily become our main target now....
			nemesis = Actor(killer);
			//FIXME Determine which value would be the best here
			t_pissed = 120.0;
		}
		else if(t_pissed)
		{
			//[FB] Nope, we are now pissed and frustrated
			//FIXME Determine which value would be the best here
			t_frust = 120.0;
		}
		angerlevel = 0;
	}
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay()
{
	int bottype;
	botinfo_t *binfo;
	int i;

	if (strcmp(player.PlayerName, ""))
	{
		for (i = 0; i < MainGameInfo::NUMTOTALBOTS; i++)
		{
			if (!stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % MainGameInfo::NUMBOTTYPES;
	}

	binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];

	// [CW] Moved this initialization to MainGameInfo::InitLevel
	// to make it not repeat each time a bot is spawned
	/*
	MainGameInfo(player.Level.Game).botskill = player.Level.World.GameSkill;

	if (MainGameInfo(player.Level.Game).botskill > 4)
	{
		MainGameInfo(player.Level.Game).botskill = 4;
	}
	if (MainGameInfo(player.Level.Game).botskill < 0)
	{
		MainGameInfo(player.Level.Game).botskill = 0;
	}
	*/

	t_strafe = 1.0;
	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - MainGameInfo(player.Level.Game).botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - MainGameInfo(player.Level.Game).botskill);
	info.evade = SkillLower(binfo->evade, 4 - MainGameInfo(player.Level.Game).botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - MainGameInfo(player.Level.Game).botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - MainGameInfo(player.Level.Game).botskill);
	player.UserInfo = binfo->userinfo;
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn()
{
	botstate.BState = bst_decide;

	// [CW] Reset some stats in case we were REspawned
	AITime = 0.0;

	ITarget = none;
	enemy = none;
	node_current = none;
	nodes.Num = 0;

	t_react = 0.0;
	t_strafe = 1.0;
	t_turn = 0.0;
	t_evade = 0.0;
	t_dodge = 0.0;
}

//==========================================================================
//
//	AffectStat
//
//  [FB] Check if we are blind by darkness!!
//
//==========================================================================

void AffectStat()
{
	if (!accuracy_r)
	{
		old_accuracy = info.accuracy;
		accuracy_r = true;
	}
	if (!intelect_r)
	{
		old_intelect = info.intelect;
		intelect_r = true;
	}
	if (!evade_r)
	{
		old_evade = info.evade;
		evade_r = true;
	}
	if (!anticip_r)
	{
		old_anticip = info.anticip;
		anticip_r = true;
	}
	if (accuracy_r && player.BlindCount <= 50)
	{
		if (info.accuracy)
		{
			info.accuracy--;
		}
		// [FB] Make sure this stat isn't less than zero
		else if (info.accuracy < bsk_verypoor)
		{
			info.accuracy = bsk_verypoor;
		}
	}
	else if (intelect_r && (player.BlindCount > 50 && player.BlindCount <= 100))
	{
		if (info.intelect)
		{
			info.intelect--;
		}
		else if (info.intelect < bsk_verypoor)
		{
			info.intelect = bsk_verypoor;
		}
	}
	else if (evade_r && (player.BlindCount > 100 && player.BlindCount <= 150))
	{
		if (info.evade)
		{
			info.evade--;
		}
		else if (info.evade < bsk_verypoor)
		{
			info.evade = bsk_verypoor;
		}
	}
	else if (anticip_r && (player.BlindCount > 150 && player.BlindCount <= 200))
	{
		if (info.anticip)
		{
			info.anticip--;
		}
		else if (info.anticip < bsk_verypoor)
		{
			info.anticip = bsk_verypoor;
		}
	}
}

//==========================================================================
//
//	SetPissedStats
//
//  [FB] We are pissed off, so certain stats are boosted
//
//==========================================================================

void SetPissedStats()
{
	if (!p_init)
	{
		n_accuracy = info.accuracy;
		n_evade = info.evade;
		n_anticip = info.anticip;
	}
	info.accuracy++;
	info.evade++;
	info.anticip++;

	// [FB] Make sure stats don't go beyond
	if (info.accuracy > bsk_supreme)
	{
		info.accuracy = bsk_supreme;
	}
	else if (info.evade > bsk_supreme)
	{
		info.evade = bsk_supreme;
	}
	else if (info.anticip > bsk_supreme)
	{
		info.anticip = bsk_supreme;
	}
}

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//	[CW] Enhanced version since 2007/12/12.
//
//==========================================================================

void BotTick(float deltaTime)
{
	// ---------------------------
	// Initialization
	// ---------------------------
	gameInfo = MainGameInfo(player.Level.Game);
	botmo = KArenaPlayerPawn(player.MO);

	player.ForwardMove = 0.0;
	player.SideMove = 0.0;
	player.FlyMove = 0.0;
	player.Buttons = 0;

	// [CW]
	if (!botmo)
	{
		return;
	}

	// Weed out any bad destinations/enemies
	CheckStuff();

	// ---------------------------
	// Chat
	// ---------------------------
	// Don't do anything if we're talking
	//	if (B_Chat())
	//		return;

	// ---------------------------
	// Death
	// ---------------------------
	if (player.PlayerState == PST_DEAD)
	{
		if (player.respawn_counter <= 0.0)
		{
			player.Buttons |= BT_USE;
		}
		return;
	}

	// ---------------------------
	// Timed effects
	// ---------------------------
	UpdateTimedEffects(deltaTime);

	// ---------------------------
	// General DECIDE
	// ---------------------------
	// [CW] I propose using AI_TIME_DELAY for this stuff thus giving some free time to engine
	AITime -= deltaTime;
	if (AITime <= 0.0)
	{
		AITime = AI_TIME_DELAY + (Random() - 0.5) * AI_TIME_DELAY / 4.0;

		CheckSituation();
		// [FB] Decide what action we'll take
		SetAction();

		// [FB] Set an ally if we're in a mode that has one
		// [CW] this may change by time in some game modes
		if (!ally && (gameInfo.bIsCoopGame[gameInfo.GameType] ||
			gameInfo.GameModel && KArenaGameModel(gameInfo.GameModel).AllowAllies()))
		{
			ally = SetAlly();
		}
		else
		{
			ally = none;
		}

		ProcessPriorities();
	}

	ProcessImmediate();

	//
	// [CW] assuming we have have what to do, or decided just to roam around
	// ---------------------------
	// Immediate action
	// ---------------------------
	
	PrepareWeapon();
	// Turning towards destination...
	Aim();
	Turn();
	if (enemy)
	{
		Attack();
		Alternate_Attack();
	}
	Move(deltaTime);

	// Only walk if we're on skill 0
	if (!gameInfo.botskill || !player.Level.World.GameSkill)
	{
		if (forwardmove > FORWARDWALK)
		{
			forwardmove = FORWARDWALK;
		}
		if (forwardmove < -FORWARDWALK)
		{
			forwardmove = -FORWARDWALK;
		}
		if (sidemove > SIDEWALK)
		{
			sidemove = SIDEWALK;
		}
		if (sidemove < -SIDEWALK)
		{
			sidemove = -SIDEWALK;
		}
	}

	player.SideMove = sidemove;
	player.ForwardMove = forwardmove;
}

//==========================================================================
//
//	UpdateTimedEffects
//
//==========================================================================

void UpdateTimedEffects(float deltaTime)
{
	// [FB] Apply blind status
	if(player.BlindCount)
	{
		AffectStat();
	}
	else if (player.BlindCount <= 0)
	{
		//[FB] Darkness effects faded out, now restore everything back!
		if (anticip_r)
		{
			info.anticip = old_anticip;
			anticip_r = false;
		}
		if (evade_r)
		{
			info.evade = old_evade;
			evade_r = false;
		}
		if (intelect_r)
		{
			info.intelect = old_intelect;
			intelect_r = false;
		}
		if (accuracy_r)
		{
			info.accuracy = old_accuracy;
			accuracy_r = false;
		}
	}

	// Periodically let out some anger
	if (!(player.Level.XLevel.Time == 255.0))	// [CW] seriously,.. what the # is this 255.0?
	{
		if (angerlevel)
		{
			angerlevel--;
		}
		else if (angerlevel <= 0)
		{
			angerlevel = 0;
		}
	}

	//--------------------------------------------------------
	//--------------------------------------------------------

	t_react -= deltaTime;
	if (t_react <= 0.0)
	{
		t_react = 0.0;
	}

	t_anticip -= deltaTime;
	if (t_anticip <= 0.0)
	{
		t_anticip = 0.0;
	}

/*	t_fight -= deltaTime;
	if (t_fight <= 0.0)
	{
		t_fight = 0.0;
	}

	t_rocket -= deltaTime;
	if (t_rocket <= 0.0)
	{
		t_rocket = 0.0;
	}*/

	t_turn -= deltaTime;
	if (t_turn <= 0.0)
	{
		t_turn = 0.0;
	}

	t_hitme -= deltaTime;
	if (t_hitme < 0.0)
	{
		t_hitme = 0.0;
	}

	t_pissed -= deltaTime;
	if (t_pissed <= 0.0)
	{
		t_pissed = 0.0;

		//[FB] Stop chasing our main target
		if(nemesis)
		{
			nemesis = none;
		}

		//[FB] Return stats to their original
		if(p_init)
		{
			info.accuracy = n_accuracy;
			info.evade = n_evade;
			info.anticip = n_anticip;
			p_init = false;
		}
	}

	t_frust -= deltaTime;
	if (t_frust <= 0.0)
	{
		t_frust = 0.0;
	}

	t_fire -= deltaTime;
	if (t_fire <= 0.0)
	{
		t_fire = 0.0;
	}

	// [FB] Apply pissed off stats
	if (t_pissed && !p_init)
	{
		SetPissedStats();
	}
}


//==========================================================================
//
//	CheckSituation
//
//==========================================================================
void CheckSituation()
{
	int i;
	botstate.flag_lost= false;

	switch (gameInfo.GameType)
	{
	case HexenDefs::game_ctf:

		{
			CTFBanner Banner;
			for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
			{
				Banner = GameCTF(gameInfo.GameModel).Banners[i];
				if (Banner.Team == player.Team && Banner.Status != CTFBanner::BANNER_STATUS__BASE)
				{
					botstate.flag_lost = true;
				}
			}
		}
		break;
	}
}

//==========================================================================
//
//	ProcessPriorities
//
//==========================================================================

void ProcessPriorities()
{
	int i, j, k;
	int looser = 0;
	bool scorezero;

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		Priority[i] = 0;
	}

	// [CW] Long way deciding priorities...
	//----------------------------------------
	// Game Mode
	//----------------------------------------
	// Game mode priority is decided first to get looser flag

	if (gameInfo.GameType < HexenDefs::NUMGAMESNOTEAM)
	{
		int plInPlay = gameInfo.GetPlayerCount();

		scorezero = (player.Team.Players[0].Score == 0) &&
			(player.Team.Players[player.PlayerPosition].Score == 0);

		if (!scorezero && player.PlayerPosition > 0)
		{
			Priority[priort_Objective] += priorv_Objective_NotFirst;
			Priority[priort_Wander] += priorv_Wander_NotFirst;
			if (!player.Score)
			{
				Priority[priort_Objective] += priorv_Objective_NoScoreBonus;
				Priority[priort_Wander] += priorv_Wander_NoScoreBonus;
			}
		}

		if (!scorezero && (plInPlay > 1) && (player.PlayerPosition == plInPlay - 1))
		{
			Priority[priort_Objective] += priorv_Objective_Last;
			Priority[priort_Wander] += priorv_Wander_Last;
			if (!player.Score)
			{
				Priority[priort_Objective] += priorv_Objective_NoScoreBonus << 2;
				Priority[priort_Wander] += priorv_Wander_NoScoreBonus * 3;
			}
			looser = 4;
		}
		else if (!scorezero && player.PlayerPosition > 1)
		{
			Priority[priort_Objective] += priorv_Objective_Loosing;
			Priority[priort_Wander] += priorv_Wander_Loosing;
			if (!player.Score)
			{
				Priority[priort_Objective] += priorv_Objective_NoScoreBonus << 1;
				Priority[priort_Wander] += priorv_Wander_NoScoreBonus << 1;
			}
			looser = 2;
		}
	}
	else if (gameInfo.GameType >= HexenDefs::NUMGAMESNOTEAM && player.Team)
	{
		int tmInPlay = gameInfo.GetTeamCount();

		scorezero = (MainGameInfo(player.Level.Game).Teams[0].Score == 0) &&
			(MainGameInfo(player.Level.Game).Teams[player.Team.Position].Score == 0);

		if (!scorezero && player.Team.Position > 0)
		{
			Priority[priort_Objective] += priorv_Objective_NotFirst;
			Priority[priort_Wander] += priorv_Wander_NotFirst;
			if (!player.Team.Score)
			{
				Priority[priort_Objective] += priorv_Objective_NoScoreBonus;
				Priority[priort_Wander] += priorv_Wander_NoScoreBonus;
			}
		}

		if (!scorezero && (tmInPlay > 1) && (player.Team.Position == tmInPlay - 1))
		{
			Priority[priort_Objective] += priorv_Objective_Last;
			Priority[priort_Wander] += priorv_Wander_Last;
			if (!player.Team.Score)
			{
				Priority[priort_Objective] += priorv_Objective_NoScoreBonus << 2;
				Priority[priort_Wander] += priorv_Wander_NoScoreBonus * 3;
			}
			looser = 4;
		}
		else if (!scorezero && player.Team.Position > 1)
		{
			Priority[priort_Objective] += priorv_Objective_Loosing;
			Priority[priort_Wander] += priorv_Wander_Loosing;
			if (!player.Team.Score)
			{
				Priority[priort_Objective] += priorv_Objective_NoScoreBonus << 1;
				Priority[priort_Wander] += priorv_Wander_NoScoreBonus << 1;
			}
			looser = 2;
		}
	}

	Priority[priort_Objective] += priorv_Objective_Normal;
	Priority[priort_Wander] += priorv_Wander_Normal;

	if (botstate.flag_lost)
	{
		Priority[priort_Objective] += priorv_Game_FlagLostBonus * looser;
		Priority[priort_Wander] += priorv_Game_FlagLostBonus * looser;
	}

	//----------------------------------------
	// Weaponry
	//----------------------------------------
	Weapon wpn = Player(self.player).BestWeapon();
	int my_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
	int heaviest_weapon = GetHeaviestEnemyWeapon();
	int opponent_weapon = 0;
	int opponent_weapon_current = 0;

	if (enemy && enemy.Player)
	{
		wpn = Player(enemy.Player).BestWeapon();
		opponent_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
		opponent_weapon_current = KArenaWeapon(Player(enemy.Player).ReadyWeapon).Slot;
	}

	// Has only 2nd level weapon
	if (my_weapon <= 1)
	{
		Priority[priort_Weapons] += priorv_Weapons_BadEquipment;
	}
	if (my_weapon < heaviest_weapon)
	{
		Priority[priort_Weapons] += priorv_Weapons_HeavyEnemies;
	}
	if (my_weapon < opponent_weapon)
	{
		Priority[priort_Weapons] += priorv_Weapons_HeavyOpponent;
	}
	if (my_weapon < opponent_weapon_current)
	{
		Priority[priort_Weapons] += priorv_Weapons_HeavyOffence;
	}
	if (my_weapon < 7)
	{
		Priority[priort_Weapons] += priorv_Weapons_NotTheBest;
	}

	if (Priority[priort_Weapons])
	{
		Priority[priort_Weapons] += priorv_Weapons_LooserBonus * looser;
	}

	//----------------------------------------
	// Ammo
	//----------------------------------------

	//
	// [CW] This works a bit different thus not to repeat Inventory searches
	//
	if (player.IsOutOfAmmo())
	{
		Priority[priort_Ammo] += priorv_Ammo_Null;
		Priority[priort_Ammo] += priorv_Ammo_Low;
		Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
		Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
		if (enemy)
		{
			Priority[priort_Ammo] += (priorv_Ammo_UnderFireBonus << 1);
		}
	}
	else
	{
		if (player.IsAmmoBelowLevel(50))
		{
			Priority[priort_Ammo] += priorv_Ammo_Low;
			Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
			Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
			if (enemy)
			{
				Priority[priort_Ammo] += priorv_Ammo_UnderFireBonus;
			}
		}
		else if (player.IsAmmoBelowLevel(50, class<KArenaWeapon>(player.ReadyWeapon.Class)) ||
				 player.ReadyWeapon.CheckAmmo(player.ReadyWeapon.FireMode, false, true))
		{
			Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
			Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
			if (enemy)
			{
				Priority[priort_Ammo] += priorv_Ammo_UnderFireBonus;
			}
		}
		else
		{
			if (player.IsAmmoBelowLevel(200, none, Mana1) ||
				player.IsAmmoBelowLevel(200, none, Mana2) ||
				player.IsAmmoBelowLevel(200, none, ItemManaRed))
			{
				Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
			}
		}
	}

	if (Priority[priort_Ammo])
	{
		Priority[priort_Ammo] += priorv_Ammo_LooserBonus * looser;
	}

	//----------------------------------------
	// AlternativeAmmo
	//----------------------------------------

	if (player.IsOutOfAmmo(,,true))
	{
		Priority[priort_AltAmmo] += priorv_AltAmmo_Null;
		Priority[priort_AltAmmo] += priorv_AltAmmo_Low;
		Priority[priort_AltAmmo] += priorv_AltAmmo_NotMaximum;
		if (enemy)
		{
			Priority[priort_AltAmmo] += priorv_AltAmmo_UnderFireBonus << 1;
		}
	}
	else
	{
		if (player.IsAmmoBelowLevel(60,,,true))
		{
			Priority[priort_AltAmmo] += priorv_AltAmmo_Low;
			Priority[priort_AltAmmo] += priorv_AltAmmo_NotMaximum;
			if (enemy)
			{
				Priority[priort_AltAmmo] += priorv_AltAmmo_UnderFireBonus;
			}
		}
		else if (player.IsAmmoBelowLevel(200, none, ArtifactFlechette) ||
				player.IsAmmoBelowLevel(200, none, ArtifactBlastRadius))
		{			
			Priority[priort_AltAmmo] += priorv_AltAmmo_NotMaximum;
			if (enemy)
			{
				Priority[priort_AltAmmo] += priorv_AltAmmo_UnderFireBonus;
			}
		}
	}

	if (Priority[priort_AltAmmo])
	{
		Priority[priort_AltAmmo] += priorv_AltAmmo_LooserBonus * looser;
	}
	
	//----------------------------------------
	// Health & Armor
	//----------------------------------------

	if (EntityEx(player.MO).CheckInventory('health') <= 15)
	{
		Priority[priort_Health] += priorv_Health_Dying;
		Priority[priort_Armor] += priorv_Armor_LowHealthBonus << 1;
		if (enemy)
		{
			Priority[priort_Health] += priorv_Health_UnderFireBonus << 1;
		}
	}
	if (EntityEx(player.MO).CheckInventory('health') <= (player.max_health >> 1))
	{
		Priority[priort_Health] += priorv_Health_Low;
		Priority[priort_Armor] += priorv_Armor_LowHealthBonus;
		if (enemy)
		{
			Priority[priort_Health] += priorv_Health_UnderFireBonus;
		}
	}
	if (EntityEx(player.MO).CheckInventory('health') < player.max_health)
	{
		Priority[priort_Health] += priorv_Health_NotMaximum;
	}

	if (Priority[priort_Health])
	{
		Priority[priort_Health] += priorv_Health_LooserBonus * looser;
	}
	
	if (EntityEx(player.MO).CheckInventory('armor') == 0)
	{
		Priority[priort_Armor] += priorv_Armor_None;
		if (enemy)
		{
			Priority[priort_Armor] += priorv_Armor_UnderFireBonus << 1;
		}
	}
	else if (EntityEx(player.MO).CheckInventory('armor') <= 50)
	{
		Priority[priort_Armor] += priorv_Armor_Low;
		if (enemy)
		{
			Priority[priort_Armor] += priorv_Armor_UnderFireBonus;
		}
	}
	else if (EntityEx(player.MO).CheckInventory('armor') <= 100)
	{
		Priority[priort_Armor] += priorv_Armor_Half;
	}
	else if (EntityEx(player.MO).CheckInventory('armor') <= 200)
	{
		Priority[priort_Armor] += priorv_Armor_NotMaximum;
	}

	if (Priority[priort_Armor])
	{
		Priority[priort_Armor] += priorv_Armor_LooserBonus * looser;
	}

	//----------------------------------------
	// Artifacts
	//----------------------------------------

	Priority[priort_Artifacts] += priorv_Artifacts_WantSome;

	//----------------------------------------
	// Special Equipment
	//----------------------------------------

	switch (gameInfo.GameType)
	{
		case HexenDefs::game_xmas:
			{
				if (!player.BestWeaponOfDamageType('Fire'))
				{
					Priority[priort_Special] += priort_Special_XmasHavocFireWpn;
				}
			}
	}

	//----------------------------------------
	// Enemy
	//----------------------------------------

	if (t_frust > 0.0)
	{
		Priority[priort_Enemy] += priorv_Enemy_Frustrated;
		if (t_hitme > 0.0)
		{
			Priority[priort_Enemy] += priorv_Enemy_HitMeBonus << 2;	// AWOOOOO!!!
		}
	}
	else if (t_pissed > 0.0)
	{
		Priority[priort_Enemy] += priorv_Enemy_Pissed;
		if (t_hitme > 0.0)
		{
			Priority[priort_Enemy] += priorv_Enemy_HitMeBonus << 1;
		}
	}
	else
	{
		Priority[priort_Enemy] += priorv_Enemy_Normal;
		if (t_hitme > 0.0)
		{
			Priority[priort_Enemy] += priorv_Enemy_HitMeBonus;
		}
	}

	//----------------------------------------
	// Nemesis
	//----------------------------------------

	if (nemesis)
	{
		if (t_frust > 0.0)
		{
			Priority[priort_Nemesis] += priorv_Nemesis_Frustrated;
			if (t_hitme > 0.0)
			{
				Priority[priort_Nemesis] += priorv_Enemy_HitMeBonus << 2;	// AWOOOOO!!! BARK!! BARK!!
			}
		}
		else	// 'just' pissed off
		{
			Priority[priort_Nemesis] += priorv_Nemesis_Pissed;
			if (t_hitme > 0.0)
			{
				Priority[priort_Nemesis] += priorv_Enemy_HitMeBonus << 1;
			}
		}
	}

	//
	//
	// [CW] Sort priorities
	//
	int prior_max;
	int excluded[NUM_PRIORITIES];
	bool is_excluded;

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		Prior_Targets[i] = -1;
		excluded[i] = -1;
	}

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		prior_max = -1;
		for (j = 0; j < NUM_PRIORITIES; j++)
		{
			is_excluded = false;
			// check if this priority type is in sorted list already
			for (k = 0; k < NUM_PRIORITIES; k++)
			{
				if (excluded[k] < 0)
				{
					break;
				}
				if (excluded[k] == j)
				{
					is_excluded = true;
					break;
				}
			}

			// check if this priority value is the maximal known
			if (!is_excluded)
			{
				if (Priority[j] > prior_max ||
					(Priority[j] == prior_max && P_Random() > 127))
				{
					Prior_Targets[i] = j;
					prior_max = Priority[j];
				}
			}
		}

		// exclude final choice of piority type, that is put into sorted list
		excluded[i] = Prior_Targets[i];
	}

#ifdef DEBUG_BOT_AI_TARGET
	string PriorityName;
	print("--------------------------");
	print("priorities updated for %s:", player.PlayerName);
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		switch (Prior_Targets[i])
		{
		case priort_Weapons: PriorityName = "Weapons"; break;
		case priort_Ammo: PriorityName = "Ammo"; break;
		case priort_AltAmmo: PriorityName = "Alt-Ammo"; break;
		case priort_Health: PriorityName = "Health"; break;
		case priort_Armor: PriorityName = "Armor"; break;
		case priort_Artifacts: PriorityName = "Artifact"; break;
		case priort_Special: PriorityName = "Special"; break;
		case priort_Enemy: PriorityName = "Enemy"; break;
		case priort_Nemesis: PriorityName = "Nemesis"; break;
		case priort_Evade: PriorityName = "Evade"; break;
		case priort_Support: PriorityName = "Support"; break;
		case priort_Objective: PriorityName = "Objective"; break;
		case priort_Wander: PriorityName = "Wander"; break;
		default: PriorityName = "Unknown";
		}
		print("%s = %i", PriorityName, Priority[Prior_Targets[i]]);
	}
	print("--------------------------");
#endif

	ITarget = none;
}

//==========================================================================
//
//	GetHeaviestEnemyWeapon
//
//==========================================================================

int GetHeaviestEnemyWeapon()
{
	int i;
	Weapon wpn;
	int pl_weapon;
	int weapon = 0;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (gameInfo.Players[i] && gameInfo.Players[i].MO &&
			gameInfo.Players[i] != player &&
			Actor(gameInfo.Players[i].MO) == enemy)
		{
			wpn = PlayerEx(gameInfo.Players[i]).BestWeapon();
			pl_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
			if (pl_weapon > weapon)
			{
				weapon = pl_weapon;
			}
		}
	}

	return weapon;
}

//==========================================================================
//
//	GetFirstPriorityTarget
//
//	[CW] Handles Bot hunt for Important Game Objects and Inventory items.
//		What should be remembered, this method checks only these objects
//		that are reachable in this very moment. It is not usable for
//		planning some future actions.
//
//==========================================================================

Actor GetFirstPriorityTarget()
{
	Actor ee;
	Actor candidates[NUM_PRIORITIES];
	float dist[NUM_PRIORITIES];
	int i, priort;

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		dist[i] = -1.0;
	}

	if (nemesis)
	{
		candidates[priort_Nemesis] = (CheckTo(nemesis.Origin, nemesis) ? nemesis : none);
	}
	if (!candidates[priort_Nemesis] && enemy && enemy != nemesis)
	{
		#ifdef DEBUG_BOT_AI_TARGET
			dprint("check priort_enemy");
		#endif
		candidates[priort_Enemy] = (CheckTo(enemy.Origin, enemy) ? enemy : none);
	}
	#ifdef DEBUG_BOT_AI_TARGET
		dprint("enemy = %i, nemesis = %i", enemy, nemesis);
		dprint("candidates[priort_Enemy] = %i", candidates[priort_Enemy]);
	#endif

	if (ally)
	{
		candidates[priort_Support] = (CheckTo(ally.Origin, ally) ? ally : none);
	}
	candidates[priort_Objective] = GetGameObjective(true);
	candidates[priort_Wander] = GetGamePathNode(true);

	if (!candidates[priort_Wander])
	{
		#ifdef DEBUG_BOT_AI_TARGET_EXCEPTIONS
			print("no wander priority");
		#endif

		if (candidates[priort_Nemesis])
		{
			candidates[priort_Wander] = candidates[priort_Nemesis];
			#ifdef DEBUG_BOT_AI_TARGET_EXCEPTIONS
				print("set to nemesis, %i", candidates[priort_Wander]);
			#endif
		}
		else if (candidates[priort_Enemy])
		{
			candidates[priort_Wander] = candidates[priort_Enemy];
			#ifdef DEBUG_BOT_AI_TARGET_EXCEPTIONS
				print("set to enemy, %i", candidates[priort_Wander]);
			#endif
		}
		else if (candidates[priort_Support] &&
			/* Prevent bot allies stuck in each other */
			!(candidates[priort_Support].bIsPlayer && candidates[priort_Support].Player.bIsBot &&
			Player(candidates[priort_Support].Player).Bot.ITarget == botmo))
		{
			candidates[priort_Wander] = candidates[priort_Support];
			#ifdef DEBUG_BOT_AI_TARGET_EXCEPTIONS
				print("set to ally, %i", candidates[priort_Wander]);
			#endif
		}
		else
		{
			candidates[priort_Wander] = GetNearestPathNode(class<Thinker>(PathNode), true);
			#ifdef DEBUG_BOT_AI_TARGET_EXCEPTIONS
				print("set to path node, %i", candidates[priort_Wander]);
			#endif
		}
	}

	// [CW] Look over all acceptable objects, common to every map and game mode
	// and remember closest candidates for each of the priority type
	foreach botmo.AllThinkers(Actor, ee)
	{
		if (ee.bInvisible)
		{
			continue;
		}
		if (ee.bNoSector)
		{
			continue;
		}

		if (ee.IsA('Inventory'))
		{
			if (!player.IsOKToPickupItem(Inventory(ee)))
			{
				// [FB] We can't actually pick up this
				continue;
			}
		}

		if (ee.IsA('Weapon'))
		{
			//
			// Special cases
			//
			if (gameInfo.GameType == HexenDefs::game_xmas &&
				botmo.WeaponClasses[KArenaWeapon(ee).Slot - 1].default.DamageTypeHint == 'Fire')
			{
				priort = priort_Special;
			}
			//
			// Common case
			//
			else
			{
				priort = priort_Weapons;
			}
		}
		else if (ee.IsA('Ammo'))
		{
			if (ee.Class == ArtifactFlechette || ee.Class == ArtifactBlastRadius)
			{
				priort = priort_AltAmmo;
			}
			else
			{
				priort = priort_Ammo;
			}
		}
		else if (ee.IsA('Health'))
		{
			priort = priort_Health;
		}
		else if (ee.IsA('Armor'))
		{
			priort = priort_Armor;
		}
		else if (ee.IsA('Artifact'))
		{
			priort = priort_Artifacts;
		}
		else
		{
			continue;
		}

		if (!Priority[priort])
		{
			continue;
		}

		if (dist[priort] < 0.0 || Length(ee.Origin - botmo.Origin) < dist[priort])
		{
			if (botmo.CanSee(ee) && CheckTo(ee.Origin, ee))
			{
				candidates[priort] = ee;
				dist[priort] = Length(ee.Origin - botmo.Origin);
			}
		}
	}

	// Finally, select the top priority candidate found
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		if (!Priority[Prior_Targets[i]])
		{
			#ifdef DEBUG_BOT_AI_TARGET_EXCEPTIONS
				print("top priority is 0, nothing to do :(");
			#endif
			break;
		}
		if (candidates[Prior_Targets[i]])
		{
			IPriorityType = Prior_Targets[i];
			return candidates[Prior_Targets[i]];
		}
	}

	return none;
}

//==========================================================================
//
//	ProcessImmediate
//
//	[CW] The method allows Bot to make immediate decisions of what to do,
//		depending of the current situation and his preset priorities.
//
//==========================================================================

void ProcessImmediate()
{
	// [CW] Bot should always seek for an incoming missile
	if (!missile)
	{
		missile = FindMissile();
	}

	// still TODO: if bot has high Evade priority he should not draw attention to himself...
	// [CW] Bot should always seek for an enemy to attack one
	if (!enemy)
	{
		enemy = GetNearestEnemy(false);
	}
	else if (nemesis && botmo.CanSee(nemesis))
	{
		enemy = nemesis;	// [CW] switch to hated enemy
	}

	#ifdef DEBUG_BOT_AI_ENEMY
		if (enemy)
		{
			print("BOT %s : my enemy is %n", player.PlayerName, GetClassName(enemy.Class));
		}
	#endif

	// [CW] Bot should always know where to go; this can be a pickup,
	//	    a specific map object or simply a path node.
	if (!ITarget)
	{
		//
		// While enemy is something that bot shoot at, ITarget is used mainly
		// to determine where he will move (except for immediate evade actions);
		// There are situations in which bot would rather shoot away at enemy,
		// at same time collecting some pickups or capturing objectives, and there
		// are cases where he would rather concentrate on enemy whacking, ignoring
		// other things.
		// ITarget must be set correspondingly, keeping all that said above in mind.
		//

		// [CW] Get any reachable object according to preset priorities
		ITarget = GetFirstPriorityTarget();

		if (ITarget)
		{
			// If Bot has got non-casional target, he should reset his nodes history
			if (!ITarget.IsA('PathNode') && !ITarget.IsA('Inventory'))
				nodes.Num = 0;
		}
	}

	#ifdef DEBUG_BOT_AI_TARGET
		if (ITarget)
		{
			print("BOT %s : my target is %n / %i", player.PlayerName, GetClassName(ITarget.Class), nodes.Num);
		}
	#endif
	bSoftContact = false;
	bCanReachNoCare = false;
	bMeleeUrge = false;
	bKeepDistant = false;

	if (ITarget)
	{
		// [CW] Soft Contact means Bot should not lower speed when approach target;
		// That is, either target cannot block way or it HAS to be bumped into (like soccer ball)
		bSoftContact =	bAttackOffsetValid ||
						(!ITarget.bMonster && !ITarget.bSolid) ||
						ITarget.IsA('SoccerBall');
	}

	if (enemy)
	{
		// [CW] Depending on current weapons, enemy's and Bot's, Bot should decide
		// whether to approach or keep distance
		if (enemy.IsA('ZXmasHavocTree') && (KArenaWeapon(player.ReadyWeapon).bBotProjectileMedium ||
						player.ReadyWeapon.bBotProjectile))
		{
			bKeepDistant = true;
		}
		else
		{
			bMeleeUrge =
						// bot has a melee weapon, and...
						(!KArenaWeapon(player.ReadyWeapon).bBotProjectile &&
						  !KArenaWeapon(player.ReadyWeapon).bBotProjectileMedium) &&
						// there's no ITarget, or...
						  (!ITarget ||
					    // ITarget is enemy and enemy is a monster, or...
							(ITarget == enemy && enemy.bMonster) ||
						// enemy is a player who is armed by missile weapon
							enemy.Player &&
						 (((KArenaWeapon(Player(enemy.Player).ReadyWeapon).bBotProjectileMedium ||
							KArenaWeapon(Player(enemy.Player).ReadyWeapon).bBotProjectile) &&
							(ITarget == enemy || botmo.DistTo(enemy) < 512.0))) &&
							!ITarget.IsA('KArenaWeapon')
						   && !player.Banner);
			bKeepDistant = !bMeleeUrge && (!KArenaWeapon(player.ReadyWeapon).bBotProjectileMedium &&
							!KArenaWeapon(player.ReadyWeapon).bBotProjectile);
		}
	}
}

//==========================================================================
//
//	GetNearestEnemy
//
//==========================================================================

Actor GetNearestEnemy(optional bool bReachable)
{
	/*if (enemy)
	{
		return enemy;
	}*/

	if (nemesis && botmo.CanSee(nemesis) && (!bReachable || CheckTo(nemesis.Origin, nemesis)))
	{
		return nemesis;
	}

	Actor e = GetSpecialEnemy(bReachable);
	if (!e)
	{
		e = FindEnemy(bReachable);
	}
	return e;
}

//==========================================================================
//
//	GetSpecialEnemy
//
//==========================================================================

Actor GetSpecialEnemy(optional bool bReachable)
{
	Actor actor;
	int i;
	float dist, closest_dist;
	float vangle;
	int light;

	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
	{
		vangle = 360.0;
	}
	else
	{
		vangle = ENEMY_SCAN_FOV;
	}
	bAllRound = false;

	switch (gameInfo.GameType)
	{
		case HexenDefs::game_kth:

			// [CW] In KTH if there's a Heresiarch and he is not this Bot,
			// Bot must target only Heresiarch
			if (GameKTH(gameInfo.GameModel).State == GameKTH::state_heresiarch &&
				GameKTH(gameInfo.GameModel).plHeresiarch &&
				GameKTH(gameInfo.GameModel).plHeresiarch != player &&
				GameKTH(gameInfo.GameModel).plHeresiarch.MO)
			{
				actor = Actor(GameKTH(gameInfo.GameModel).plHeresiarch.MO);
				dist = botmo.DistTo(actor);
			}
			break;

		case HexenDefs::game_ctf:

			closest_dist = -1.0;
			for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
			{
				CTFBanner Banner = GameCTF(gameInfo.GameModel).Banners[i];
				if (Banner.Team == player.Team)
				{
					// [CW] In any case Bot should try to gun the opposing flag-carrier down
					if (Banner.Status == CTFBanner::BANNER_STATUS__CARRIED &&
						Banner.Capturer && Banner.Capturer.MO)
					{
						dist = botmo.DistTo(Banner.Capturer.MO);
						if (closest_dist == -1.0 || closest_dist > dist)
						{
							actor = Actor(Banner.Capturer.MO);
							closest_dist = dist;
						}
					}
				}
			}
			break;

		case HexenDefs::game_football:

			if (GameFootball(gameInfo.GameModel).Ball && 
				GameFootball(gameInfo.GameModel).Ball.Owner &&
				GameFootball(gameInfo.GameModel).Ball.Owner.Team != player.Team)
			{
				actor = Actor(GameFootball(gameInfo.GameModel).Ball.Owner.MO);
			}
			break;

		case HexenDefs::game_xmas:

			if (player.BestWeaponOfDamageType('Fire'))
			{
				actor = Actor(botmo.A_GetNearestEntity(ZXmasHavocTree));
				if (actor)
					dist = botmo.DistTo(actor);
			}
			break;
	}

	if (actor)
	{
		if (dist <= EntityEx::MELEERANGE || Check_LOS(actor, vangle) && EntityEx(botmo).CanSee(actor))
		{
			light = actor.Sector->params.lightlevel; // [FB] Detect the light level
			if (actor.Sector->floor.LightSourceSector)
			{
				//[FB] Add static or dynamic lights?
				light += actor.Sector->floor.LightSourceSector;
			}
			// [FB] Too dark?
			// [CW] enhance this a bit, still human players usually CAN see in dark
			if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
			{
				if (light <= WHATS_VERYDARK)
				{
					if (P_Random() < 196)
					{
						return none;
					}
				}
				else if (P_Random() < 128)
				{
					return none;
				}
			}

			if (!bReachable || CheckTo(actor.Origin, actor))
			{
				return actor;
			}
		}
	}

	return none;
}

//==========================================================================
//
//	GetGameObjective
//
//	[CW] Seeks for special objects, that have importance in current game mode.
//  No enemies nor path nodes should be sought here (this is done separately)
//
//==========================================================================

Actor GetGameObjective(optional bool bReachable)
{
	Actor EE;
	Actor ee;
	float dist = -1.0;
	int i;

	switch (gameInfo.GameType)
	{
		case HexenDefs::game_ctf:

			for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
			{
				ee = GameCTF(gameInfo.GameModel).Banners[i];

				// [CW] Our flag (lost or captured) is highest priority
				// regardless of the bot status (offense/defence)
				// [FB] Check status of our flag
				if (CTFBanner(ee).Team == player.Team)
				{
					if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__CARRIED ||
						CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST ||
						// [CW] Now, that's special, if bot carries enemy flag
						// he must seek for his own flag even if it is on the base
						botstate.BState == bst_scoring &&
								CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE)
					{
						if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
						{
							if (!bReachable || CheckTo(ee.Origin, ee))
							{
								EE = ee;
								dist = Length(botmo.Origin - ee.Origin);
							}
						}
					}
				}
				
				// [CW] I suggest this be high priority in any case,
				// since if bot really can reach enemy flag at the moment
				// he better try to get one (unless he already carries a flag)
				// [FB] Check status of enemy flag
				if (botstate.BState != bst_scoring && CTFBanner(ee).Team != player.Team)
				{
					if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE ||
						CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST)
					{
						if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
						{
							if (!bReachable || CheckTo(ee.Origin, ee))
							{
								EE = ee;
								dist = Length(botmo.Origin - ee.Origin);
							}
						}
					}
				}
			}

			if (!EE)
			{
				dist = -1.0;
				for (i = 0; i < GameCTF(gameInfo.GameModel).spot_banners.Num; i++)
				{
					ee = GameCTF(gameInfo.GameModel).spot_banners[i];

					if (CTFBase(ee).Team == player.Team &&
						(botstate.BState == bst_defense && P_Random() < 64 ||
						botstate.BState == bst_scoring && P_Random() < 128))
					{
						if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
						{
							if (!bReachable || CheckTo(ee.Origin, ee))
							{
								EE = ee;
								dist = Length(botmo.Origin - ee.Origin);
							}
						}
					}
				}
			}
			break;

		case HexenDefs::game_domination:

			for (i = 0; i < GameDomination(gameInfo.GameModel).DomSigils.Num; i++)
			{
				ee = GameDomination(gameInfo.GameModel).DomSigils[i];
				if (DominationSigil(ee).Team != player.Team ||
					(botstate.BState == bst_defense && DominationSigil(ee).Team == player.Team &&
					 P_Random() < 64) &&
					(dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
				{
					if (!bReachable || CheckTo(ee.Origin, ee))
					{
						EE = ee;
						dist = Length(botmo.Origin - ee.Origin);
					}
				}
			}
			break;

		case HexenDefs::game_football:

			EE = GameFootball(gameInfo.GameModel).Ball;
			bAttackOffsetValid = false;

			// [CW] set a target offset
			if (EE)
			{
				int target_team;
				Actor sts;
				GameFootball fb = GameFootball(gameInfo.GameModel);
				if (/* gameInfo.Teams[0] == */ player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
				{
					target_team = PlayerTeam::TEAM2_INDEX_RED;
				}
				else
				{
					target_team = PlayerTeam::TEAM2_INDEX_BLUE;
				}

				// Get nearest goal target
				for (i = 0; i < fb.spot_targets.Num; i++)
				{
					if (fb.spot_targets[i].Args[0] != target_team)
					{
						continue;
					}
					ee = fb.spot_targets[i];
					if ((dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
					{
						if (!bReachable || CheckTo(ee.Origin, ee))
						{
							sts = ee;
							dist = Length(botmo.Origin - ee.Origin);
						}
					}
				}

				if (sts)
				{
					AttackOffset = (Normalise(EE.Origin - sts.Origin) * (botmo.Radius * 2.0)) + EE.Origin;
					bAttackOffsetValid = true;
				}
			}
			break;
	}

	return EE;
}

//==========================================================================
//
//	GetGamePathNode
//
//	[CW] Seeks for path nodes, that have importance in current game mode.
//
//==========================================================================

Actor GetGamePathNode(optional bool bReachable)
{
	Actor EE;

	switch (gameInfo.GameType)
	{
	case HexenDefs::game_ctf:

		// [CW] If no Flag or Flag Carrier in sight, check for path
		// leading to our or their Flag
		switch(botstate.BState)
		{
		case bst_offense:
			break; // [CW] skip this part to seek offensive Team Node below
		case bst_defense:
			if (player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
			{
				EE = GetNearestPathNode(class<Thinker>(BlueGuardSpot), false);
			}
			else
			{
				EE = GetNearestPathNode(class<Thinker>(RedGuardSpot), false);
			}
			break;
		case bst_scoring:
			if (player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
			{
				EE = GetNearestPathNode(class<Thinker>(BlueGoalSpot), false);
			}
			else
			{
				EE = GetNearestPathNode(class<Thinker>(RedGoalSpot), false);
			}
			break;
		}

		if (!EE)
		{
			if (player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
			{
				EE = GetNearestPathNode(class<Thinker>(BlueNode), false);
			}
			else
			{
				EE = GetNearestPathNode(class<Thinker>(RedNode), false);
			}
			break;
		}

		break;
	}

	if (!EE &&
		// In DM, TDM and KTH path nodes should be checked after enemy,
		// so skip this one
		gameInfo.GameType != HexenDefs::game_dm &&
		gameInfo.GameType != HexenDefs::game_dmteam &&
		gameInfo.GameType != HexenDefs::game_kth)
	{
		EE = GetNearestPathNode(class<Thinker>(PriorityNode), false);
	}

	return EE;
}

//==========================================================================
//
//	GetNearestPathNode
//
//==========================================================================

Actor GetNearestPathNode(class<Thinker> NodeType, optional bool bFinal)
{
	PathNode PN;
	PathNode pn;
	float dist = -1.0;
	bool visited;
	int i;

	array<PathNode> skipped;

	PathNode previous;

	if (nodes.Num)
	{
		previous = nodes[nodes.Num - 1];
	}

	foreach botmo.AllThinkers(NodeType, pn)
	{
		if (pn == node_current)
		{
			continue;
		}

		visited = false;
		for (i = 0; i < nodes.Num; i++)
		{
			if (nodes[i] == pn)
			{
				visited = true;
				break;
			}
		}

		if (visited)
		{
			continue;
		}

		if (dist < 0.0 || Length(pn.Origin - botmo.Origin) < dist)
		{
			if (CheckTo(pn.Origin))
			{
				if (pn.Class == PathNode && P_Random() < 33)
				{
					// skip common nodes sometimes to give bot movement more variety
					skipped.Num = skipped.Num + 1;
					skipped[skipped.Num - 1] = pn;
					continue;
				}

				PN = pn;
				dist = Length(pn.Origin - botmo.Origin);
			}
		}
	}

	if (PN)
	{
		if (skipped.Num)
		{
			int oldNum = nodes.Num;
			nodes.Num = nodes.Num + skipped.Num;
			for (i = oldNum; i < nodes.Num; i++)
			{
				nodes[i] = skipped[i - oldNum];
			}
		}

		if (node_current)
		{
			// emulate Queue
			if (nodes.Num >= 256)
			{
				for (i = 1; i < nodes.Num; i++)
					nodes[i - 1] = nodes[i];
			}
			else
				nodes.Num = nodes.Num + 1;
			nodes[nodes.Num - 1] = node_current;
		}
		node_current = PN;
	}
	else
	{
		if (bFinal)
		{
			if (node_current)
			{
				nodes.Num = 1;
				nodes[0] = node_current;
			}
			else
			{
				nodes.Num = 0;
			}
			node_current = previous;
		}
		else return none;
	}
	return node_current;
}

bool LinesCross(float x11, float y11, float x12, float y12, float x21, float y21, float x22, float y22,
				  TVec * crosspt)
{
	float maxx1 = FMax(x11, x12), maxy1 = FMax(y11, y12);
	float minx1 = FMin(x11, x12), miny1 = FMin(y11, y12);
	float maxx2 = FMax(x21, x22), maxy2 = FMax(y21, y22);
	float minx2 = FMin(x21, x22), miny2 = FMin(y21, y22);

	if (minx1 > maxx2 || maxx1 < minx2 || miny1 > maxy2 || maxy1 < miny2)
	{
		return false;
	}
 
	float dx1 = x12 - x11, dy1 = y12 - y11; // First line projection to x & y axes
	float dx2 = x22 - x21, dy2 = y22 - y21; // Second line projection to x & y axes
	float dxx = x11 - x21, dyy = y11 - y21;
	float div, mul;

	div = (dy2 * dx1 - dx2 * dy1);
	if (div == 0.0)
	{
	  return false; // Parallel lines
	}
	if (div > 0.0)
	{
		mul = (dx1 * dyy - dy1 * dxx);
		if (mul < 0.0 || mul > div)
		{
			return false; // first line crossing out of limits
		}
		mul = (dx2*dyy-dy2*dxx);
		if (mul < 0.0 || mul > div)
		{
			return false; // second line crossing out of limits
		}
	}

	mul = -(dx1 * dyy - dy1 * dxx);
	if (mul < 0.0 || mul > -div)
	{
		return false; // first line crossing out of limits
	}
	mul = -(dx2 * dyy - dy2 * dxx);
	if (mul < 0.0 || mul > -div)
	{
		return false; // second line crossing out of limits
	}

	float factor = (dx2 * dyy - dy2 * dxx) / div;

	crosspt->x = x11 + factor * (x21 - x11);
	crosspt->y = y11 + factor * (y21 - y11);

	return true;
}

defaultproperties
{
}
