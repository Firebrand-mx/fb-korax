//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		    ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: BotPlayer.vc 1133 2007-11-26 23:13:04Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The
//  main bot AI loop, BotTick, is called every tic.
//  Also included are various bot decision-making
//  procedures, such as CheckStuff and SetEnemy.
//
//	[CW] ... also includes so many other things, ough-uh...
//
//**************************************************************************

// Main bot class
class BotPlayer : Object;

const float
	FORWARDWALK				= 200.0,
	FORWARDRUN				= 400.0,
	SIDEWALK				= 192.0,
	SIDERUN					= 320.0,

	// [CW] CHECKME -- not used!
	MAX_TRAVERSE_DIST		= 1024.0,		// 10 meters, used within b_func.c
	AVOID_DIST				= 512.0,		// Try avoid incoming missiles once they reached this close
	// [CW] CHECKME -- not used!
	SAFE_SELF_MISDIST		= 128.0,		// Distance from self to target where it's safe to pull a rocket.
	// [CW] CHECKME -- not used!
	FRIEND_DIST				= 1024.0,		// To friend.
	DARK_DIST				= 256.0,		// Distance that bot can see enemies in the dark from.
	// [CW] CHECKME -- not used!
	MAX_MONSTER_TARGET_DIST	= 1024.0,		// Too high can slow down the performance, see P_mobj.c
	ENEMY_SCAN_FOV			= 120.0,
	MAXSTEPHEIGHT			= 24.0,
	MAXJUMPHEIGHT			= 56.0,
	MAXMOVEHEIGHT			= MAXJUMPHEIGHT,
	MAXDROPHEIGHT			= 384.0,
	//MAXMOVEHEIGHT			= 32.0,			// MAXSTEPMOVE but with jumping counted in.
	// [CW] CHECKME -- not used!
	GETINCOMBAT				= 512.0,		// Max distance to item if it's due to be picked up in a combat situation.
	SHOOTFOV				= 60.0,
	// [CW] CHECKME -- not used!
	MAXROAM					= (5.0 * 35.0);	// When this time is elapsed the bot will roam after something else.
const int
	WHATS_DARK		= 64,					// light value thats classed as dark.
	WHATS_VERYDARK	= 24;

/*

  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.

*/

// [FB] Bot Difficulty/skill settings/filters.
enum
{
	bsk_verypoor,
	bsk_poor,
	bsk_low,
	bsk_medium,
	bsk_high,
	bsk_excellent,
	bsk_supreme
};

struct botinfo_t
{
	string Name;		// Bot's name
	int accuracy;		// Accuracy with "instant" weapons (this includes "leading")
	int intelect;		// Accuracy with "missile" weapons (rocket launcher, etc.)
	int evade;			// Ability to dodge incoming missiles
	int anticip;		// Ability to anticipate "instant" shots
	int reaction;		// Overall reaction time (lower is "better")
	int pisschance;		// Chance the bot will get pissed when his threshold is reached
	int threshold;		// How much it takes to frustrate/piss off the bot
	int dangerlevel;	// When health is below this, we need some health
/*	int wpfav;			// Favorite weapon
	int chatinfo;		// Bot's chat strings
	int chattime;		// How long it takes us to type a line
	int chatty;			// How talkative the bot is
	char *colour;		// Colour (in form of a string)
	char *gender;		// Male/female/it :)
	char *skin;			// Skin
	int railcolour;		// Railgun trail colour
	bool revealed;		// Hidden bots must be revealed*/
	string userinfo;
};
/*
struct chatline_t
{
//	string		*string;
//	chattype_t  bot;
	chatline_t	*line;
};

struct chatinfo_t
{
	chatline_t		intro[5];
	chatline_t		inter[5];
	chatline_t		rare[5];
	chatline_t		frag[15];
	chatline_t		died[10];
	chatline_t		roam[10];
	chatline_t		pissed[5];
	chatline_t		frustrated[5];
	chatline_t		special[20];
};
*/
enum { NUMTOTALBOTS = 24 };
enum { NUMBOTTYPES = 24 };

//
// [CW] Okay, here I'll begin to add something =)
//

//
// [CW] Priority counters: basically speaking, the one with larger value
//		determine what this Bot should aim to
//
enum
{
	priort_Weapons,		// tells how much Bot needs a new weapon
	priort_Ammo,		// tells how much Bot needs an ammo
	priort_AltAmmo,		// tells how much Bot needs an alternative ammo
	priort_Health,		// tells how much Bot needs health
	priort_Armor,		// tells how much Bot needs armor
	priort_Artifacts,	// tells how much Bot needs an artifact... not sure this would be useful, but let's have it
	priort_Special,		// tells how much Bot needs something special (e.g. special equipment)
	priort_Enemy,		// tells how much Bot needs to fight the enemy, ignoring all other things for awhile
	priort_Nemesis,		// tells how much Bot needs to fight the hated enemy, in particular
	priort_Evade,		// tells how much Bot needs to get away from enemies
	priort_Support,		// tells how much Bot needs to support his buddy in combat
	priort_GameMode,	// tells how much Bot needs to peform some task specific to advanced gamemode
	NUM_PRIORITIES
						// those evening bells, those evening bells, so many things this priority tells...
};

int Priority[NUM_PRIORITIES];		// current priority values
int Prior_Targets[NUM_PRIORITIES];	// prioritised list of actions

// [CW] Priority additive values (by categories)
enum
{
	priorv_Weapons_BadEquipment		= 24,	// has only low level weapons (1,2)
	priorv_Weapons_HeavyOffence		= 16,	// opponent wields more poweful weapon (currently)
	priorv_Weapons_HeavyOpponent	= 12,	// opponent has more powerful weapons
	priorv_Weapons_HeavyEnemies		= 10,	// enemies have more powerful weapons
	priorv_Weapons_NotTheBest		= 8,

	priorv_Ammo_Null				= 32,	// need ammo ...NOW!!
	priorv_Ammo_Low					= 12,	// overall ammo is low
	priorv_Ammo_ThisWeaponLow		= 8,	// ammo for selected weapon is low
	priorv_Ammo_NotMaximum			= 4,	// you can never be sure you have enouph
	priorv_Ammo_UnderFireBonus		= 16,	// can see enemy while ammo low (x2 if ammo null)

	priorv_AltAmmo_Null				= 24,	// need alt-ammo
	priorv_AltAmmo_Low				= 12,	// overall alt-ammo is low
	priorv_AltAmmo_NotMaximum		= 4,	// you can never be sure you have enouph
	priorv_AltAmmo_UnderFireBonus	= 16,	// can see enemy while ammo low (x2 if ammo null)

	priorv_Health_Dying				= 48,	// need health ...now!!... NO, FASTER THAN NOW!!
	priorv_Health_Low				= 24,	// health is low
	priorv_Health_NotMaximum		= 8,	// this won't last for long
	priorv_Health_UnderFireBonus	= 32,	// can see enemy while health low (x2 if dying)

	priorv_Armor_None				= 32,
	priorv_Armor_Low				= 12,
	priorv_Armor_Half				= 8,
	priorv_Armor_NotMaximum			= 4,
	priorv_Armor_LowHealthBonus		= 16,	// health is low, so some armor will be useful too
	priorv_Armor_UnderFireBonus		= 24,

	priorv_Artifacts_WantSome		= 4,	// ..huh.. (TODO)

	priort_Special_XmasHavocFireWpn	= 24,	// Xmas Havoc is unplayable without fire weapons

	priorv_Enemy_Frustrated			= 24,	// arghh! arghh!! argh!!!
	priorv_Enemy_Pissed				= 18,	// arghh! I want to kill everyone!
	priorv_Enemy_Normal				= 8,	// just a normal urge to whack someone
	priorv_Enemy_HitMeBonus			= 12,	// enemy just hit me, I want revenge!

	priorv_Nemesis_Frustrated		= 48,
	priorv_Nemesis_Pissed			= 24,

	priorv_Evade					= 0,	// TODO

	priorv_Support					= 0,	// TODO

	priorv_GameMode_Last			= 24,
	priorv_GameMode_Loosing			= 16,
	priorv_GameMode_NotFirst		= 12,
	priorv_GameMode_Normal			= 8,
	priorv_GameMode_NoScoreBonus	= 4		// x2 if Not First, x4 if Loosing and x8 if last
};
//
// [CW] So, idea is, that bot summarize its current situation periodically and decides what he should do next
//

const float AI_TIME_DELAY	= 5.0;	// in seconds
float AITime;

//
// Bot states
//
enum
{
	bst_deciding,	// 	Bot is deciding what to do
	bst_offense,	// 	Bot is "fetching" something (offense)
	bst_defense,	// 	Bot is defending something
	bst_scoring		// 	Bot is heading to scoring place
};

struct botstate_t
{
	int BState;
};

Player player;			// Points to reference player
KArenaPlayerPawn botmo;
MainGameInfo gameInfo;

// [CW] try this...
Actor FTarget;			// final target (goal) ----- currently UNUSED
Actor ITarget;			// immediate target (where to go)
//TVec ITargetPos;		// immediate target position (valid in specific situations)
int IPriorityType;		// current ITarget priority type
TVec AttackOffset;		// basically, a point to get to just before heading to target
PathNode node_current;
array<PathNode> nodes;  // list of visited nodes (to make bot move freely along the map)

Actor enemy;			// The dead meat.
Actor nemesis;			// Prefered enemy to chase when pissed off

Actor ally;				// Ally to tag along with
Actor last_mate;		// If bots mate dissapeared (not if died) that mate is
						// pointed to by this. Allows bot to roam to it if
						// necessary.
Actor missile;			// A threathing missile that got to be avoided.

botstate_t botstate;	// What we're doing in teamgame mode

// Tickers
float t_respawn;
float t_strafe;
float t_react;
/* float t_fight;
float t_rocket;*/
float t_turn;
float t_hitme;			// someone hit me!!
float t_pissed;
float t_frust;
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;
//float t_chat;				// Tics left until bots completes "typing" in what he's saying.
						// Bot also doesn't do anything during this time.

float forwardmove;		// For building ucmd
float sidemove;

// Flags, controlling movement
// regarding ITarget:
bool bSoftContact;			// ITarget is something that could be passed through without slowing down
// regarding ITarget = enemy (or nemesis)
bool bMeleeUrge;			// Must come closer to enemy as quickly as possible
bool bKeepDistant;			// Enemy should be attacked from distance
//bool bUseTargetPosition;	// ITargetPos is valid
bool bAttackOffsetValid;	// Use AttackOffset


// Misc booleans
bool bAllRound;

/* chatline_t	*chatline;			// For when t_chat expires

bottype_t	bottype;			// Bot type*/
botinfo_t info;			// Aiming, name, perfection, yadda yadda

int angerlevel;

float angle;			// The wanted angle that the bot tries to get every tic.

// -----------------------------------------------------------
//
// Darkness Stats Update
//
// -----------------------------------------------------------

// [FB] Copy of certain affected stats for Darkness
int old_intelect;
int old_anticip;
int old_evade;
int old_accuracy;

// [FB] Used to determine if stats have been reduced
bool accuracy_r;
bool intelect_r;
bool evade_r;
bool anticip_r;

// -----------------------------------------------------------
//
// Pissed off Stats Update
//
// -----------------------------------------------------------

// [FB] Copy of certain affected stats for Darkness
int n_anticip;
int n_evade;
int n_accuracy;

// [FB] Used to determine if stats have been updated when pissed off
bool p_init;

//==========================================================================
//
//	AngleTo
//
//	Returns yaw angle to a certain location
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	AngleTo2
//
//	Returns pitch angle to a certain location
//
//==========================================================================

float AngleTo2(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.pitch;
}

//==========================================================================
//
//	SetAction
//
//	Decide what to do in teamgame (defend, whatever)
//
//==========================================================================

void SetAction()
{
	int i;
	int defenders = 0;
	int attackers = 0;

	// [FB] Run this routine only in some gameplay modes
	if (gameInfo.GameType != HexenDefs::game_ctf &&
		gameInfo.GameType != HexenDefs::game_football)
	{
		return;
	}

	// [CW] Moved from GetGameModeGoal --
	if (gameInfo.GameType == HexenDefs::game_ctf)
	{
		CTFBanner Banner;
		for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
		{
			Banner = GameCTF(gameInfo.GameModel).Banners[i];
			if (CTFBanner(Banner).Status == CTFBanner::BANNER_STATUS__CARRIED &&
				CTFBanner(Banner).Capturer == player)
			{
				// [FB] We are carrying, set our state to scoring to change our goal
				botstate.BState = bst_scoring;
			}
		}
	}

	// [FB] We are deciding what to do
	if (botstate.BState == bst_deciding)
	{
		// Let's see what the other bots on our
		// team are doing, and decide our action based
		// off on that
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO && 
			    Player(player.Level.Game.Players[i]).bIsBot && 
			    Player(player.Level.Game.Players[i]).Team == player.Team)
			{
				// [FB] Is this bot in Offense?
				if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == bst_offense)
				{
					attackers++;
				}
				// [FB] Is this bot in Defense?
				else if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == bst_defense)
				{
					defenders++;
				}
			}
		}

#ifdef DEBUG_BOT_AI_TARGET
		print("BOT %s : Defenders: %d", player.PlayerName, defenders);
		print("BOT %s : Attackers: %d", player.PlayerName, attackers);
#endif
		// Defense wins championships...
		if (defenders <= attackers)
		{
			// [FB] Then get on defense
			botstate.BState = bst_defense;
#ifdef DEBUG_BOT_AI_TARGET
			print("BOT %s : Got defense", player.PlayerName);
#endif
		}
		else
		{
			// [FB] Then get on offense
			botstate.BState = bst_offense;
#ifdef DEBUG_BOT_AI_TARGET
			print("BOT %s : Got offense", player.PlayerName);
#endif
		}
	}
}

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	switch (sec->special & ~SECSPEC_SECRET_MASK)
	{
		case 4:		// Scroll_EastLavaDamage
		case 5:		// Damage_LavaWimpy
		case 7:		// Damage_Sludge
		case 16:	// Damage_LavaHefty
			return true;
	}

	return false;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//	[CW] keep in mind that this method is now used only during short move
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;
	intercept_t* in;
	float bottracerange;
	TVec bottracedir;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	bottracedir.z = 0.0;	
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + botmo.Radius + dist * bottracedir.x;
 	y2 = y1 + botmo.Radius + dist * bottracedir.y;

	// [FB] Use lines
	EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');

	//	[BC] For the bots
	//	[FB] Additions for 3d floor checks
	foreach botmo.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS)
	{
		EntityEx th;
		line_t *ld;
		TVec hit_point;
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight, dheight;

		if (in->bIsALine)
		{
			ld = in->line;	// This linedef
			hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

			// Line is impassible
			if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING) ||
				(ld->flags & ML_BLOCKEVERYTHING))
			{
				return false;
			}

			// Line isn't two sided
			if (!ld->backsector)
			{
				return false;
			}

			if (!PointOnPlaneSide(botmo.Origin, ld))
			{
				back = ld->backsector;
				front = ld->frontsector;
			}
			else
			{
				back = ld->frontsector;
				front = ld->backsector;
			}

			// Sector is dangerous
			if (IsDangerous(back))
			{
				return false;
			}

			// crosses a two sided line
			open = LineOpenings(ld, hit_point);
			open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);

			// No valid openings
			if (!open || open->range <= botmo.Height)
			{
				return false;
			}
			else
			{
				// [FB] No cliff jumping unless we're going after something
				if ((open->lowfloor - open->bottom) > /*32.0*/MAXMOVEHEIGHT &&
					(open->lowfloor - open->bottom) < /*384.0*/MAXDROPHEIGHT && !(enemy && enemy == ITarget))
				{
					return false;
				}

				// [FB] Determine if it's wise to jump up to a floor
				diffheight = open->bottom - open->lowfloor;

				if (diffheight > 0.0)
				{
					if (diffheight >= MAXSTEPHEIGHT && diffheight <= MAXJUMPHEIGHT)
					{
						botmo.Player.Buttons |= BT_JUMP;
						continue;
					}
					else if (diffheight > MAXJUMPHEIGHT)
					{
						// CHECKME!!
					/*	if (front->SSpecial == ThrustThingZ || front->springpadzone)
						{
							return true;
						}
						else*/
							return false;
					}
				}
			}
		}
		else
		{
			th = EntityEx(in->Thing);

			if (Actor(th) == botmo)
			{
				continue;
			}

			if (th.bSolid && th != enemy)
			{
				// [FB] Jump to avoid something
				dheight = th.Origin.z + th.Height - botmo.Origin.z;

				if (dheight >= MAXSTEPHEIGHT && dheight <= MAXJUMPHEIGHT)
				{
					botmo.Player.Buttons |= BT_JUMP;
					continue;
				}

				return false;
			}

			// [FB] Jump to reach something
			dheight = th.Origin.z + th.Height - botmo.Origin.z;

			if (dheight >= MAXSTEPHEIGHT && dheight <= MAXJUMPHEIGHT)
			{
				botmo.Player.Buttons |= BT_JUMP;
				continue;
			}
		}
	}

	return true;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if a location is reachable
//
//==========================================================================

bool CheckTo(TVec pos, optional EntityEx TargetEntity)
{
	if (!specified_TargetEntity)
	{
		TargetEntity = none;
	}

	return botmo.CanReach(pos, TargetEntity, MAXJUMPHEIGHT, MAXDROPHEIGHT, botmo.Height);
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff()
{
	if (enemy)
	{
		if (!enemy.bShootable || enemy.bDormant || enemy.Health <= 0 ||
			!EntityEx(botmo).CanSee(enemy) ||
			// Special cases
			enemy.IsA('ZXmasHavocTree') &&
				(KArenaWeapon(player.ReadyWeapon).DamageTypeHint != 'Fire' ||
					!player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Either, false)))
		{
			enemy = none;
		}
	}

	if (missile)
	{
		// [CW] CHECKME - Not sure the first condition had any sense here
		if (/*!missile.bMissile ||*/missile.IsDestroyed())
		{
			missile = none;
		}
	}

	// [CW]
	if (ITarget)
	{
		if (ITarget.IsA('Inventory'))
		{
			if (ITarget.Owner || ITarget.bInvisible)
			{
				ITarget = none;
				return;
			}
			else if (Length(botmo.Origin - ITarget.Origin) <= EntityEx::MELEERANGE)
			{
				if (!player.IsOKToPickupItem(Inventory(ITarget)))
				{
					// [FB] We can't actually pick up this
					ITarget = none;
					return;
				}
			}
		}

		//
		// Special cases
		if (ITarget.IsA('DominationSigil') && DominationSigil(ITarget).Team == player.Team)
		{
			// [CW] Domination Sigil already captured
			ITarget = none;
			return;
		}
		// TODO -- think out same specials for CTF banner
		
		if (((ITarget == node_current) && (Length(botmo.Origin - ITarget.Origin) <= EntityEx::MELEERANGE)) ||
			!CheckTo(ITarget.Origin, ITarget))
		{
			ITarget = none;
			return;
		}
	}
}

//==========================================================================
//
//	Check_LOS
//
//	Doesn't check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(EntityEx to, float vangle)
{
	if (!botmo.CanSee(to))
	{
		return false; // out of sight
	}
	if (vangle == 360.0)
	{
		return true;
	}
	if (vangle == 0.0)
	{
		return false; // Looker seems to be blind.
	}

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
	{
		return skill;
	}

	skill -= num;
	if (skill < 0)
	{
		skill = 0;
	}

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
	if (t_turn)
		return;

	angle = AngleMod360(an);
//	angle = an;

	if (!enemy)
	{
		return;
	}

	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
			t_turn = 4.0 / 3.0;
			break;
		case bsk_low:
			t_turn = 2.0 / 3.0;
			break;
		case bsk_medium:
			t_turn = 1.0 / 2.0;
			break;
		case bsk_high:
			t_turn = 1.0 / 4.0;
			break;
		case bsk_excellent:
			t_turn = 1.0 / 8.0;
			break;
		case bsk_supreme:
			break;
	}
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle()
{
	return angle;
}

//==========================================================================
//
//	AimProjectile
//
// 	[FB] Projectile weapons
//
//==========================================================================

void AimProjectile(float dist, bool right, float an)
{
	// [BC] Cajun prediction
	// Here goes the prediction.
	float m = (dist / 875.0); // FIXME Determine current weapon's missile speed
	float px = enemy.Origin.x + (enemy.Origin.x + (enemy.Velocity.x * m * 2.0));
	float py = enemy.Origin.y + (enemy.Origin.y + (enemy.Velocity.y * m * 2.0));

	switch (info.intelect)
	{
		case bsk_verypoor:
		case bsk_poor:
			if (MainGameInfo(player.Level.Game).botskill > 3 && Random() < 0.01)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
/*				SetAngle(R_PointToAngle2(MO->x,
							      MO->y,
							      enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
							      enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));*/	
			}
			else
			{
				// Aim right at the enemy
				SetAngle(an);
			}
			break;
		case bsk_low:
			if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.03)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				// Aim right at the enemy
				SetAngle(an);
			}
			break;
		case bsk_medium:
			if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.09)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		case bsk_high:
			if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.9)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		case bsk_excellent:
			if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.3)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		case bsk_supreme:
			if (MainGameInfo(player.Level.Game).botskill > 0 && Random() < 0.1)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
				{
					SetAngle(an + Random() * 20.0);
				}
				else
				{
					SetAngle(an - Random() * 20.0);
				}
			}
			break;
		default:
			Error("BotPlayer::AimProjectile::Unknown bot accuracy skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	AimInstant
//
// 	[FB] Instant weapons
//
//==========================================================================

void AimInstant(float dist, bool right, float an)
{
	// [CW] : temporary fix
/*	if (info.accuracy < bsk_high && dist < EntityEx::MELEERANGE * 2.0)
	{
		SetAngle(an);
		return;
	}*/

	// FIXME: Implement botskill, accuracy, and intelligence
	switch (info.accuracy)
	{
		case bsk_verypoor:
			if (right)
			{
				SetAngle(an + Random() * 60.0);
			}
			else
			{
				SetAngle(an - Random() * 60.0);
			}
			break;
		case bsk_poor:
			if (right)
			{
				SetAngle(an + Random() * 45.0);
			}
			else
			{
				SetAngle(an - Random() * 45.0);
			}
			break;
		case bsk_low:
			if (right)
			{
				SetAngle(an + Random() * 30.0);
			}
			else
			{
				SetAngle(an - Random() * 30.0);
			}
			break;
		case bsk_medium:
			if (right)
			{
				SetAngle(an + Random() * 15.0);
			}
			else
			{
				SetAngle(an - Random() * 15.0);
			}
			break;
		case bsk_high:
			SetAngle(an);
			break;
		case bsk_excellent:
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		case bsk_supreme://FIXME
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		default:
			Error("BotPlayer::AimInstant::Unknown bot accuracy skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	Aim
//
//==========================================================================

void Aim()
{
	float dist;
	bool right;
	float an;
	int i;

	if (!enemy)
	{
		// [CW] Target can be other object, simply face its direction
		if (ITarget)
		{
			SetAngle(AngleTo(ITarget.Origin));
		}
		return;
	}

	if (t_react > 4.0)
	{
		return;
	}

	// Distance to enemy.
	dist = botmo.DistTo(enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [FB] Set fire time
	t_fire = KArenaWeapon(player.ReadyWeapon).fire_tics;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		// [FB] Set t_anticip for our enemies
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
			player.Level.Game.Players[i].bIsBot &&
			Player(player.Level.Game.Players[i]).Bot.enemy && 
			Player(player.Level.Game.Players[i]).Bot.enemy == botmo)
		{
			Player(player.Level.Game.Players[i]).Bot.t_anticip = 
					KArenaWeapon(player.ReadyWeapon).refire_tics;
		}
	}

	// [FB] set pitch accordingly...
	Pitch();
	
	// [FB] ...and Decide which kind of aiming the bot will use
	if (KArenaWeapon(player.ReadyWeapon).bInstantRanged || player.ReadyWeapon.bBlaster)
	{
		AimInstant(dist, right, an);
	}
	else
	{
		AimProjectile(dist, right, an);
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy(optional bool bReachable)
{
	float closest_dist, dist;
	Actor target;
	float vangle;
	int i, light;
	Actor actor;

	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
	{
		vangle = 360.0;
	}
	else
	{
		vangle = ENEMY_SCAN_FOV;
	}
	bAllRound = false;

	closest_dist = 99999.0;

	// [CW] no need to pass through this if there are no monsters on map 
	if (!GetCvar('NoMonsters'))
	{
		// [FB] Search for monster enemies
		foreach botmo.AllThinkers(Actor, actor)
		{
			dist = botmo.DistTo(actor);

			if (!(actor.bMonster))
			{
				continue;
			}

			// [CW] Check_LOS and CanSee are checked below, no need to call them here
			/* if (!Check_LOS(actor, vangle))
			{
				continue;
			}
			if (!botmo.CanSee(actor))
			{
				continue;
			}*/

			if (actor.Health <= 0)
			{
				continue;
			}
			// [FB] We spawned the minotaur? we shouldn't attack him then!
			if (actor.Class == MinotaurFriend)
			{
				if (actor.Tracer == botmo)
				{
					continue;
				}
				// [FB] Don't attack a friendly minotaur in all these cases
				if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep)
				{
					continue;
				}
				else if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
				{
					bool SameTeam = false;
					// [FB] Check if an advanced game mode is active
					if (MainGameInfo(player.Level.Game).GameModel)
					{
						int teamfactor;

						teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(actor.Tracer,
									Actor(botmo));
						// [FB] We've got a team factor, just check if it's an ally or not
						if (teamfactor != GameModel::teamfactor_any &&
							teamfactor != GameModel::teamfactor_enemy)
						{
							continue;
						}
					}
					// [FB] Check if the minotaur's instigator is in the same team we are on
					for(i = 0; i < MAXPLAYERS; i++)
					{						
						if (actor.Tracer == player.Level.Game.Players[i] && 
							Player(player.Level.Game.Players[i]).Team == player.Team)
						{
							SameTeam = true;
							break;
						}
					}
					if (SameTeam)
					{
						continue;
					}					
				}
			}
			if (dist > MAX_MONSTER_TARGET_DIST)
			{
				continue;
			}

			 // Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always
			 // returns false. tought it should be the same checksight as below but.. (below works) something
			 // must be fuckin wierd screded up.
			if (dist <= EntityEx::MELEERANGE || Check_LOS(actor, vangle))
			{
				if (EntityEx(botmo).CanSee(actor))
				{
					// [CW] already calculated above
					//dist = botmo.DistTo(actor);

					light = actor.Sector->params.lightlevel; // [FB] Detect the light level
					if (actor.Sector->floor.LightSourceSector)
					{
						//[FB] Add static or dynamic lights?
						light += actor.Sector->floor.LightSourceSector;
					}
					// [FB] Too dark?
					// [CW] enhance this a bit, still human players usually CAN see in dark
					if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
					{
						if (light <= WHATS_VERYDARK)
						{
							if (P_Random() < 196)
							{
								continue;
							}
						}
						else if (P_Random() < 128)
						{
							continue;
						}
					}

					if (bReachable && !CheckTo(actor.Origin, actor))
					{
						continue;
					}

					if (dist < closest_dist)
					{
						closest_dist = dist;
						target = actor;
					}
				}
			}
			return target;
		}
	}

	// [CW] Don't waste time searching enemy players if this is coop game mode
	if (MainGameInfo(player.Level.Game).bIsCoopGame[MainGameInfo(player.Level.Game).GameType])
	{
		return none;
	}

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
		    player.Level.Game.Players[i].MO.Health > 0 && !Player(player.Level.Game.Players[i]).bUnControllable && 
			botmo != player.Level.Game.Players[i].MO)
		{
			// [CW] Check if an advanced game mode is active
			if (MainGameInfo(player.Level.Game).GameModel)
			{
				int teamfactor;

				teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(Actor(botmo),
					     Actor(player.Level.Game.Players[i].MO));
				// [CW] We've got a team factor, check if it can be an enemy
				if (teamfactor != GameModel::teamfactor_any &&
				    teamfactor != GameModel::teamfactor_enemy)
				{
					continue;
				}
			}
			// [FB] Are we on a Team gameplay mode?
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				// [FB] Don't attack same team players
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
				{
					continue;
				}
			}
			// Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost
			// always returns false. tought it should be the same checksight as below but.. (below
			// works) something must be fuckin wierd screded up.
			// [CW] ok... let's see what is here...
			dist = botmo.DistTo(player.Level.Game.Players[i].MO);

			if (dist <= EntityEx::MELEERANGE ||
				(botmo.Sector->SoundTarget == player.Level.Game.Players[i].MO
				/*[CW] No need to check this here, CanSee is called below*/
				/* && botmo.CanSee(botmo.Sector->SoundTarget)*/
				) || Check_LOS(EntityEx(player.Level.Game.Players[i].MO), vangle))
			{
				if (EntityEx(botmo).CanSee(player.Level.Game.Players[i].MO))
				{
					// [FB] Detect the light level
					light = player.Level.Game.Players[i].MO.Sector->params.lightlevel;
					if (player.Level.Game.Players[i].MO.Sector->floor.LightSourceSector)
					{
						//[FB] Add static or dynamic lights?
						light += player.Level.Game.Players[i].MO.Sector->floor.LightSourceSector;
					}
					// [FB] Too dark? // [CW] enhance this a bit, still human players usually CAN see in dark
					if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
					{
						if (light <= WHATS_VERYDARK)
						{
							if (P_Random() < 196)
							{
								continue;
							}
						}
						else if (P_Random() < 128)
						{
							continue;
						}
					}

					if (bReachable && !CheckTo(player.Level.Game.Players[i].MO.Origin,
													EntityEx(player.Level.Game.Players[i].MO)))
					{
						continue;
					}

					if (dist < closest_dist)
					{
						closest_dist = dist;
						target = Actor(player.Level.Game.Players[i].MO);
					}
				}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	FindMissile
//
//	[FB] Check for Missiles to avoid
//
//==========================================================================

Actor FindMissile()
{
	Actor actor;

	foreach botmo.AllThinkers(Actor, actor)
	{
		// [CW] Fixed to greatly optimize processing time
		if (actor.bMissile && (botmo.DistTo(actor) <= AVOID_DIST))
		{
			if (Check_LOS(actor, 90.0))
			{
				return actor;
			}
		}
	}

	return none;
}

//==========================================================================
//
//	PrepareWeapon
//
//==========================================================================

void PrepareWeapon()
{
	float dist;
	
	if (enemy)
		dist = botmo.DistTo(enemy);
	else
		dist = 99999.0; // [CW] be ready for anything

	// [FB] Decide our weapon if we have an enemy
	if (player.ReadyWeapon.bWimpyWeapon ||
		// Special cases
		(enemy && enemy.IsA('ZXmasHavocTree') &&
			KArenaWeapon(player.ReadyWeapon).DamageTypeHint != 'Fire')
		)
	{
		Weapon Best = ChooseWeapon(dist);
		if (Best && Best != player.ReadyWeapon)
		{
			player.PendingWeapon = Best;
		}
	}
}

//==========================================================================
//
//	ChooseWeapon
//
//	[FB] Decide which weapon would be best to use in our situation
//
//==========================================================================

Weapon ChooseWeapon(float dist)
{
	Inventory		Item;
	KArenaWeapon	Wpn;
	Weapon			Best = none;

	//if (enemy)
	//{
		for (Item = botmo.Inventory; Item; Item = Item.Inventory)
		{
			Wpn = KArenaWeapon(Item);
			if (!Wpn)
			{
				//	Not a weapon.
				continue;
			}
			if (enemy && enemy.IsA('ZXmasHavocTree'))
			{
				// [FB] We only want to use weapons that do fire damage in XMAS Havoc!
				if (Wpn.DamageTypeHint != 'Fire')
				{
					continue;
				}
			}
			if (dist <= Actor::MELEERANGE)
			{
				if (!Wpn.bBotMelee)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else if (dist <= 512.0)
			{
				if (!Wpn.bBotProjectileMedium)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else
			{
				if (!Wpn.bBotProjectile)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			if (!Wpn.CheckAmmo(Wpn.FireMode, false))
			{
				//	Not enough ammo.
				continue;
			}
			Best = Wpn;
		}
		if (Best)
		{
			return Best;
		}
	//}
	// Didn't find anything good
	return player.ReadyWeapon;
}

//==========================================================================
//
//	ChooseBlastRadiusMode
//
//	[FB] Decide which blast radius mode would be best to use in our situation
//
//==========================================================================

bool ChooseBlastRadiusMode(float dist, int amount)
{
	if (dist <= Actor::MELEERANGE)
	{
		// [FB] We've got several choices here so we'll cycle them
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_BLASTRADIUS])
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS_INSTANT:
			case HexenDefs::ALTFIRE_BLASTRADIUS_BOMB:
				if (amount >= 10)
				{
					// [FB] We can keep this alternate weapon
					return true;
				}
				break;
		}
	}
	else if (dist <= 512.0)
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_BLASTRADIUS])
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS_MISSILE:
			case HexenDefs::ALTFIRE_BLASTRADIUS_BOMB:
			case HexenDefs::ALTFIRE_BLASTRADIUS_INSTANT:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	else
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_BLASTRADIUS])
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS_MISSILE:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	return false;
}

//==========================================================================
//
//	ChoosePoisonBagMode
//
//	[FB] Decide which flechette mode would be best to use in our situation
//
//==========================================================================

bool ChoosePoisonBagMode(float dist, int amount)
{
	if (dist <= Actor::MELEERANGE)
	{
		// [FB] We've got several choices here so we'll cycle them
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_POISONBAG])
		{
			case HexenDefs::ALTFIRE_POISONBAG_BOMB:
			case HexenDefs::ALTFIRE_POISONBAG_CLOUD:
				if (amount >= 10)
				{
					// [FB] We can keep this alternate weapon
					return true;
				}
				break;
		}
	}
	else if (dist <= 512.0)
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_POISONBAG])
		{
			case HexenDefs::ALTFIRE_POISONBAG_GRENADE:
			case HexenDefs::ALTFIRE_POISONBAG_CLOUD:
			case HexenDefs::ALTFIRE_POISONBAG_BOMB:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	else
	{
		switch(player.altWeaponMode[HexenDefs::ALTFIRE_POISONBAG])
		{
			case HexenDefs::ALTFIRE_POISONBAG_GRENADE:
				if (amount >= 10)
				{
					return true;
				}
				break;
		}
	}
	return false;
}

//==========================================================================
//
//	ChooseAltWeapon
//
//	[FB] Decide which alternate weapon would be best to use in our situation
//
//==========================================================================

bool ChooseAltWeapon()
{
	Ammo AltWpn;

	if (!!P_Random() & 1)
	{
		AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));

		if (ChooseBlastRadiusMode(botmo.DistTo(enemy), AltWpn ? AltWpn.Amount : 0))
		{
			player.Impulse = HexenDefs::IMPULSE__TOGGLE_BLASTRAD;
			return true;
		}
	}
	else
	{
		AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));

		if (ChoosePoisonBagMode(botmo.DistTo(enemy), AltWpn ? AltWpn.Amount : 0))
		{
			player.Impulse = HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
			return true;
		}
	}

	return false;
}

//==========================================================================
//
//	SetAlly
//
//	[FB] This function is called every tick (for each bot) to set the
//	     mate (teammate coop mate).
//
//==========================================================================

Actor SetAlly()
{
	float closest_dist, test;
	Actor target;
	int i, j;

	//is mate alive?
	if (ally)
	{
		if (ally.Health <= 0)
		{
			ally = none;
		}
		else
		{
			last_mate = ally;
		}
	}

	//Check old_mates status.
	if (!ally && last_mate)
	{
		if (last_mate.Health <= 0)
		{
			last_mate = none;
			ally = last_mate;
		}
		else
		{
			ally = last_mate;
		}
	}

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if ((player.Level.Game.Players[i]) && (player.Level.Game.Players[i].MO) &&
			(botmo != player.Level.Game.Players[i].MO))
		{
			if (MainGameInfo(player.Level.Game).GameModel) // [FB] Check if an advanced game mode is active
			{
				int teamfactor;

				teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(Actor(botmo),
						Actor(player.Level.Game.Players[i].MO));
				// [FB] We've got a team factor, just check if it's an ally or not
				if (teamfactor != GameModel::teamfactor_any &&
					teamfactor != GameModel::teamfactor_enemy)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
				}
			}

			// [FB] Set an ally for team game modes
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
				}
			}
			else if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) // [FB] Set an ally if we're in a mode that has one
			{
				ally = Actor(player.Level.Game.Players[i].MO);
			}
		}
	}

	closest_dist = 99999.0;

	//Check for player friends
	for (j = 0; j < MAXPLAYERS; j++)
	{
		if ((player.Level.Game.Players[j]) && (player.Level.Game.Players[j].MO) &&
			(botmo != player.Level.Game.Players[j].MO))
		{
			// [FB] Team game modes
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				if ((Player(player.Level.Game.Players[j]).Team == player.Team))
				{
					int HealthDanger = Player(player.Level.Game.Players[j]).bIsBot ?
									   Player(player.Level.Game.Players[j]).Bot.info.dangerlevel : 
									   Player(player.Level.Game.Players[j]).max_health / 2;
					if (player.Level.Game.Players[j].MO.Health <= HealthDanger)
					{
						if (botmo.CanSee(player.Level.Game.Players[j].MO))
						{
							test = botmo.DistTo(player.Level.Game.Players[j].MO);

							if (test < closest_dist)
							{
								closest_dist = test;
								target = Actor(player.Level.Game.Players[j].MO);
								ally = target;
							}
						}
					}
				}
			}
			else if(MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) // [FB] Other ally gameplay modes (no player colour checking)
			{
				if (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2)
				{
					if (botmo.CanSee(player.Level.Game.Players[j].MO))
					{
						test = botmo.DistTo(player.Level.Game.Players[j].MO);

						if (test < closest_dist)
						{
							closest_dist = test;
							target = Actor(player.Level.Game.Players[j].MO);
							ally = target;
						}
					}
				}
			}
		}
	}

	return ally;
}

//==========================================================================
//
//	Roam
//
//	Handle non-attack/dodging movement (?)
//
//==========================================================================

void Roam(TVec dest)
{
	// [CW] let it be only for 2d first
	float yaw_delta = botmo.Angles.yaw - AngleTo(dest);
	float distance = fabs(Length(dest - botmo.Origin));
	float distance_bak = distance;

	if (bSoftContact || bMeleeUrge)
	{
		distance *= 100.0;	// to ensure bot will reach as quickly as possible
	}

	float fw_delta = distance * cos(yaw_delta);
	float side_delta = distance * sin(yaw_delta);

	if (bKeepDistant)
	{
		if (distance_bak > 256.0)
		{
			fw_delta *= -1.0;
			side_delta *= -1.0;
		}
		else if (distance_bak < 384.0)
		{
			fw_delta = 0.0;
		}
	}
		
	if (fw_delta > 0.0)
	{
		forwardmove = FORWARDRUN > fw_delta ? fw_delta : FORWARDRUN;
	}
	else
	{
		forwardmove = -FORWARDRUN < fw_delta ? fw_delta : -FORWARDRUN;
	}
	if (side_delta > 0.0)
	{
		sidemove = SIDERUN > side_delta ? side_delta : SIDERUN;
	}
	else
	{
		sidemove = -SIDERUN < side_delta ? side_delta : -SIDERUN;
	}

	TVec short_dest = botmo.Origin;
	short_dest.x += forwardmove * cos(botmo.Angles.yaw) + sidemove * cos(botmo.Angles.yaw - 90.0);
	short_dest.y += forwardmove * sin(botmo.Angles.yaw) + sidemove * sin(botmo.Angles.yaw - 90.0);
	CheckPath(Length(short_dest - botmo.Origin), AngleTo(short_dest));
}

//==========================================================================
//
//	Move
//
//	Main bot movement function.
//	Dodging/attacking movement is also handled here
//
//==========================================================================

void Move(float deltaTime)
{
	TVec dest;

	// Worry about missiles above all else
	if (missile)
	{
		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				// Don't change direction while dodging missiles (that could be bad)
				//bot->sidemove = -bot->sidemove;
				t_strafe = 2.0;
			}
		}

		// Look at the missile and sidestep it
		SetAngle(AngleTo(missile.Origin));
		forwardmove = -FORWARDRUN;
		return;
	}

	// Anticipate a shot: time to dodge!
	if (enemy && t_anticip <= 0.25)
	{
		if (!sidemove)
		{
			sidemove = SIDERUN;
		}

		switch (info.anticip)
		{
		case bsk_verypoor:
			// Deer caught in the headlights
			sidemove = 0.0;
			return;

		case bsk_poor:
			// Always walk right
			sidemove = SIDEWALK;
			break;

		case bsk_low:
			// Always run right
			sidemove = SIDERUN;
			break;

		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe)
			{
				t_strafe -= deltaTime;
				if (t_strafe <= 0.0)
				{
					sidemove = -sidemove;
					t_strafe = 2.0;
				}
			}
			break;

		case bsk_high:
			// Switch directions when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = -sidemove;
			}
			break;

		case bsk_excellent:
			// Move in a somewhat random direction when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;

				if (Random() < 0.5)
				{
					forwardmove = -FORWARDWALK;
				}
			}
			break;

		case bsk_supreme:
			// What a squirmy little fucker!
			if (!t_anticip)
			{
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}
			break;

		default:
			Error("BotPlayer::Move::Unknown bot anticipation skill level: %d", info.anticip);
			return;
		}
	}

	// Now handle attack movement
	if (enemy)
	{
		float an;

		if (!sidemove)
		{
			sidemove = SIDERUN;
		}

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		an = GetAngle(); //botmo.Angles.yaw;
		if (sidemove < 0.0)
		{
			an -= 90.0;
		}
		else
		{
			an += 90.0;
		}

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
		{
			an += (an > 180.0 ? -180.0 : 180.0);
			if (CheckPath(an, 48.0))
			{
				sidemove = -sidemove;
			}
			else
			{
				sidemove = 0.0;
			}
		}
//		return;
	}

	// [CW] Set a real destination for movement
	if (ITarget)
	{
		if (bAttackOffsetValid)
		{
			TAVec anglesFromOffset, anglesFromMO;
			TVec vOff = ITarget.Origin - AttackOffset;
			TVec vMO = ITarget.Origin - botmo.Origin;

			VectorAngles(&vOff, &anglesFromOffset);
			VectorAngles(&vMO, &anglesFromMO);
			
			// TODO: count accuracy level here maybe
			if (anglesFromMO.yaw >= anglesFromOffset.yaw - 15.0 &&
				anglesFromMO.yaw <= anglesFromOffset.yaw + 15.0)
			{
				dest = ITarget.Origin;
			}
			else
			{
				dest = AttackOffset;
			}
		}
		else
		{
			dest = ITarget.Origin;
		}
	}
	else
	{
//		dest = botmo.Origin;	// just hang on place where standing
		// do nothing?
		SetAngle(GetAngle() + 15.0);
		forwardmove = -FORWARDWALK;
		return;
	}

	if(CheckTo(dest))
		Roam(dest);
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack()
{
	// Still reacting to something or we don't have an enemy to fight
	if (t_react > 2.0 || !enemy)
	{
		return;
	}

	// [FB] Check if our allies are out of the way of the attack
	if (ally && Check_LOS(ally, SHOOTFOV))
	{
		return;
	}

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
	{
		return;
	}

/*	// [FB] We are still shooting
	if (t_fire)
	{
		return;
	}*/
	
	// [FB] Don't attack if the distance is not the right one for this weapon
	float combatdist = player.ReadyWeapon.BotCombatDist;
	if ((MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
		MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweepteam) &&
		combatdist > Actor::MELEERANGE)
	{
		combatdist /= 2.0;
	}
	if (botmo.DistTo(enemy) > combatdist)
	{
		return;
	}

	// [CW] Don't attack if incompatible damage type
	if (enemy.IsA('ZXmasHavocTree') && KArenaWeapon(player.ReadyWeapon).DamageTypeHint != 'Fire')
	{
		return;
	}

	player.Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	React
//
//	[FB] Called when bot receives damage
//
//==========================================================================

void React(EntityEx inflictor)
{
	bAllRound = true;

	// [CW]
	t_hitme += AI_TIME_DELAY + 1.0; // to make sure this will affect priority recalculations

	// [BC] 
	if (inflictor && inflictor != botmo && ally != inflictor)
	{
		if (!enemy)
		{
			enemy = Actor(inflictor);
//			t_react = player.DamageFlash + itof(info.reaction) * 2.0;
		}
		// [FB] Set reaction time
		switch (info.reaction)
		{
			case bsk_verypoor:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.6;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.6;
				}
				else
				{
					t_react = player.DamageFlash * 1.6;
				}
				break;
			case bsk_poor:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.5;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.5;
				}
				else
				{
					t_react = player.DamageFlash * 1.5;
				}
				break;
			case bsk_low:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.2;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.2;
				}
				else
				{
					t_react = player.DamageFlash * 1.2;
				}
				break;
			case bsk_medium:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.1;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.1;
				}
				else
				{
					t_react = player.DamageFlash * 1.1;
				}
				break;
			case bsk_high:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.0;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.0;
				}
				else
				{
					t_react = player.DamageFlash * 1.0;
				}
				break;
			case bsk_excellent:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 0.8;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 0.8;
				}
				else
				{
					t_react = player.DamageFlash * 0.8;
				}
				break;
			case bsk_supreme:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 0.6;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 0.6;
				}
				else
				{
					t_react = player.DamageFlash * 0.6;
				}
				break;
			default:
				Error("BotPlayer::React::Unknown bot reaction skill level: %d", info.reaction);
				return;
		}
	}
}

//==========================================================================
//
//	Alternate_Attack
//
//	[FB] Similar to Attack, but using alternate weapons
//
//==========================================================================

void Alternate_Attack()
{
	Ammo type;

	// Still reacting to something or we don't have an enemy to fight
	if (t_react > 2.0 || !enemy)
	{
		return;
	}

	// [FB] Have we chosen an alternate weapon?
	if (ChooseAltWeapon())
	{
		player.PlayerImpulse();

		// [FB] We just simply check which weapon is active and do what it's needed for it to work
		switch (player.altWeapon)
		{
			case HexenDefs::ALTFIRE_BLASTRADIUS:
				type = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));
				if (type && type.Amount >= 10)
				{
					// No point in firing if we won't hit them
					if (!Check_LOS(enemy, 255.0))
					{
						return;
					}
					// [FB] Check if our allies are out of the way of the attack
					if (ally && Check_LOS(ally, 255.0))
					{
						return;
					}
					if (botmo.DistTo(enemy) > 255.0)
					{
						return;
					}

					// [FB] We've got enough ammo
					player.AlternateAttack();
				}
				break;
			case HexenDefs::ALTFIRE_POISONBAG:
				type = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));
				if (type && type.Amount >= 10)
				{
					// No point in firing if we won't hit them
					if (!Check_LOS(enemy, SHOOTFOV))
					{
						return;
					}
					// [FB] Check if our allies are out of the way of the attack
					if (ally && Check_LOS(ally, SHOOTFOV))
					{
						return;
					}

					// [FB] We've got enough ammo
					player.AlternateAttack();
				}
				break;
		}
	}
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//
//==========================================================================

void Turn()
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

	if (!enemy)
	{
		player.ViewAngles.yaw = GetAngle();
		return;
	}

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			if (distance > 7.5)
			{
				distance = 7.5;
			}
			if (distance < -7.5)
			{
				distance = -7.5;
			}
			break;
		case bsk_medium:
			if (distance > 15.0)
			{
				distance = 15.0;
			}
			if (distance < -15.0)
			{
				distance = -15.0;
			}
			break;
		case bsk_high:
			if (distance > 22.5)
			{
				distance = 22.5;
			}
			if (distance < -22.5)
			{
				distance = -22.5;
			}
			break;
		case bsk_excellent:
			if (distance > 30.0)
			{
				distance = 30.0;
			}
			if (distance < -30.0)
			{
				distance = -30.0;
			}
			break;
		case bsk_supreme:
			if (distance > 37.5)
			{
				distance = 37.5;
			}
			if (distance < -37.5)
			{
				distance = -37.5;
			}
			break;
	}

	player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch()
{
	TVec dir;
	TAVec ang;

	// [FB] Set pitch for underwater areas
	if (player.MO.WaterLevel > 2)
	{
		if (enemy)
		{
			botmo.Angles.pitch = -AngleTo2(enemy.Origin);
			return;
		}

		// [FB] Follow our buddy if we're tagging along
		if (ally || (ally && !enemy))
		{
			botmo.Angles.pitch = -AngleTo2(ally.Origin);
			return;
		}
	}
	else
	{
		if (enemy)
		{
			botmo.Angles.pitch = AngleTo2(enemy.Origin);
			return;
		}
	}

	botmo.Angles.pitch = 0.0;
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(EntityEx victim)
{
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx killer)
{
	// [FB] Accumulate anger
	angerlevel += 10;

	if(angerlevel > info.threshold)
	{
		//[FB] There's a chance that we can get pissed off
		if(P_Random() < info.pisschance && !t_pissed)
		{
			//[FB] Now we are pissed off!
			//	this actor will temporarily become our main target now....
			nemesis = Actor(killer);
			//FIXME Determine which value would be the best here
			t_pissed = 120.0;
		}
		else if(t_pissed)
		{
			//[FB] Nope, we are now pissed and frustrated
			//FIXME Determine which value would be the best here
			t_frust = 120.0;
		}
		angerlevel = 0;
	}
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay()
{
	int bottype;
	botinfo_t *binfo;
	int i;

	if (strcmp(player.PlayerName, ""))
	{
		for (i = 0; i < MainGameInfo::NUMTOTALBOTS; i++)
		{
			if (!stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % MainGameInfo::NUMBOTTYPES;
	}

	binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];
	MainGameInfo(player.Level.Game).botskill = player.Level.World.GameSkill;

	if (MainGameInfo(player.Level.Game).botskill > 4)
	{
		MainGameInfo(player.Level.Game).botskill = 4;
	}
	if (MainGameInfo(player.Level.Game).botskill < 0)
	{
		MainGameInfo(player.Level.Game).botskill = 0;
	}

	t_strafe = 1.0;
	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - MainGameInfo(player.Level.Game).botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - MainGameInfo(player.Level.Game).botskill);
	info.evade = SkillLower(binfo->evade, 4 - MainGameInfo(player.Level.Game).botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - MainGameInfo(player.Level.Game).botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - MainGameInfo(player.Level.Game).botskill);
	player.UserInfo = binfo->userinfo;
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn()
{
	botstate.BState = bst_deciding;
	enemy = none;
	accuracy_r = false;
	intelect_r = false;
	evade_r = false;
	anticip_r = false;
	p_init = false;
}

//==========================================================================
//
//	AffectStat
//
//  [FB] Check if we are blind by darkness!!
//
//==========================================================================

void AffectStat()
{
	if (!accuracy_r)
	{
		old_accuracy = info.accuracy;
		accuracy_r = true;
	}
	if (!intelect_r)
	{
		old_intelect = info.intelect;
		intelect_r = true;
	}
	if (!evade_r)
	{
		old_evade = info.evade;
		evade_r = true;
	}
	if (!anticip_r)
	{
		old_anticip = info.anticip;
		anticip_r = true;
	}
	if (accuracy_r && player.BlindCount <= 50)
	{
		if (info.accuracy)
		{
			info.accuracy--;
		}
		// [FB] Make sure this stat isn't less than zero
		else if (info.accuracy < bsk_verypoor)
		{
			info.accuracy = bsk_verypoor;
		}
	}
	else if (intelect_r && (player.BlindCount > 50 && player.BlindCount <= 100))
	{
		if (info.intelect)
		{
			info.intelect--;
		}
		else if (info.intelect < bsk_verypoor)
		{
			info.intelect = bsk_verypoor;
		}
	}
	else if (evade_r && (player.BlindCount > 100 && player.BlindCount <= 150))
	{
		if (info.evade)
		{
			info.evade--;
		}
		else if (info.evade < bsk_verypoor)
		{
			info.evade = bsk_verypoor;
		}
	}
	else if (anticip_r && (player.BlindCount > 150 && player.BlindCount <= 200))
	{
		if (info.anticip)
		{
			info.anticip--;
		}
		else if (info.anticip < bsk_verypoor)
		{
			info.anticip = bsk_verypoor;
		}
	}
}

//==========================================================================
//
//	SetPissedStats
//
//  [FB] We are pissed off, so certain stats are boosted
//
//==========================================================================

void SetPissedStats()
{
	if (!p_init)
	{
		n_accuracy = info.accuracy;
		n_evade = info.evade;
		n_anticip = info.anticip;
	}
	info.accuracy++;
	info.evade++;
	info.anticip++;

	// [FB] Make sure stats don't go beyond
	if (info.accuracy > bsk_supreme)
	{
		info.accuracy = bsk_supreme;
	}
	else if (info.evade > bsk_supreme)
	{
		info.evade = bsk_supreme;
	}
	else if (info.anticip > bsk_supreme)
	{
		info.anticip = bsk_supreme;
	}
}

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//	[CW] Enhanced version since 2007/12/12.
//
//==========================================================================

void BotTick(float deltaTime)
{
	// ---------------------------
	// Initialization
	// ---------------------------
	gameInfo = MainGameInfo(player.Level.Game);
	botmo = KArenaPlayerPawn(player.MO);

	player.ForwardMove = 0.0;
	player.SideMove = 0.0;
	player.FlyMove = 0.0;
	player.Buttons = 0;

	// [CW]
	if (!botmo)
	{
		return;
	}

	// Weed out any bad destinations/enemies
	CheckStuff();

	// ---------------------------
	// Chat
	// ---------------------------
	// Don't do anything if we're talking
	//	if (B_Chat())
	//		return;

	// ---------------------------
	// Death
	// ---------------------------
	if (player.PlayerState == PST_DEAD)
	{
		if (player.respawn_counter <= 0.0)
		{
			player.Buttons |= BT_USE;
		}
		return;
	}

	// ---------------------------
	// Timed effects
	// ---------------------------
	UpdateTimedEffects(deltaTime);

	// ---------------------------
	// General DECIDE
	// ---------------------------
	// [CW] I propose using AI_TIME_DELAY for this stuff thus giving some free time to engine
	AITime -= deltaTime;
	if (AITime <= 0.0)
	{
		AITime = AI_TIME_DELAY + (Random() - 0.5) * AI_TIME_DELAY / 4.0;

		// [FB] Decide what action we'll take
		SetAction();

		// [FB] Set an ally if we're in a mode that has one
		// [CW] this may change by time in some game modes
		if (!ally && (gameInfo.bIsCoopGame[gameInfo.GameType] ||
			gameInfo.GameModel && gameInfo.GameModel.AllowAllies()))
		{
			ally = SetAlly();
		}
		else
		{
			ally = none;
		}

		ProcessPriorities();
	}

	ProcessImmediate();

	//
	// [CW] assuming we have have what to do, or decided just to roam around
	// ---------------------------
	// Immediate action
	// ---------------------------
	
	PrepareWeapon();
	// Turning towards destination...
	Aim();
	Turn();
	if (enemy)
	{
		Attack();
		Alternate_Attack();
	}
	Move(deltaTime);

	// Only walk if we're on skill 0
	if (!gameInfo.botskill || !player.Level.World.GameSkill)
	{
		if (forwardmove > FORWARDWALK)
		{
			forwardmove = FORWARDWALK;
		}
		if (forwardmove < -FORWARDWALK)
		{
			forwardmove = -FORWARDWALK;
		}
		if (sidemove > SIDEWALK)
		{
			sidemove = SIDEWALK;
		}
		if (sidemove < -SIDEWALK)
		{
			sidemove = -SIDEWALK;
		}
	}

	player.SideMove = sidemove;
	player.ForwardMove = forwardmove;
}

//==========================================================================
//
//	UpdateTimedEffects
//
//==========================================================================

void UpdateTimedEffects(float deltaTime)
{
	// [FB] Apply blind status
	if(player.BlindCount)
	{
		AffectStat();
	}
	else if (player.BlindCount <= 0)
	{
		//[FB] Darkness effects faded out, now restore everything back!
		if (anticip_r)
		{
			info.anticip = old_anticip;
			anticip_r = false;
		}
		if (evade_r)
		{
			info.evade = old_evade;
			evade_r = false;
		}
		if (intelect_r)
		{
			info.intelect = old_intelect;
			intelect_r = false;
		}
		if (accuracy_r)
		{
			info.accuracy = old_accuracy;
			accuracy_r = false;
		}
	}

	// Periodically let out some anger
	if (!(player.Level.XLevel.Time == 255.0))	// [CW] seriously,.. what the # is this 255.0?
	{
		if (angerlevel)
		{
			angerlevel--;
		}
		else if (angerlevel <= 0)
		{
			angerlevel = 0;
		}
	}

	//--------------------------------------------------------
	//--------------------------------------------------------

	t_react -= deltaTime;
	if (t_react <= 0.0)
	{
		t_react = 0.0;
	}

	t_anticip -= deltaTime;
	if (t_anticip <= 0.0)
	{
		t_anticip = 0.0;
	}

/*	t_fight -= deltaTime;
	if (t_fight <= 0.0)
	{
		t_fight = 0.0;
	}

	t_rocket -= deltaTime;
	if (t_rocket <= 0.0)
	{
		t_rocket = 0.0;
	}*/

	t_turn -= deltaTime;
	if (t_turn <= 0.0)
	{
		t_turn = 0.0;
	}

	t_hitme -= deltaTime;
	if (t_hitme < 0.0)
		t_hitme = 0.0;

	t_pissed -= deltaTime;
	if (t_pissed <= 0.0)
	{
		t_pissed = 0.0;

		//[FB] Stop chasing our main target
		if(nemesis)
		{
			nemesis = none;
		}

		//[FB] Return stats to their original
		if(p_init)
		{
			info.accuracy = n_accuracy;
			info.evade = n_evade;
			info.anticip = n_anticip;
			p_init = false;
		}
	}

	t_frust -= deltaTime;
	if (t_frust <= 0.0)
	{
		t_frust = 0.0;
	}

	t_fire -= deltaTime;
	if (t_fire <= 0.0)
	{
		t_fire = 0.0;
	}

	// [FB] Apply pissed off stats
	if (t_pissed && !p_init)
	{
		SetPissedStats();
	}
}

//==========================================================================
//
//	ProcessPriorities
//
//==========================================================================

void ProcessPriorities()
{
	int i, j;

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		Priority[i] = 0;
	}

	// [CW] Long way deciding priorities...
	//----------------------------------------
	// Weaponry
	//----------------------------------------
	Weapon wpn = Player(self.player).BestWeapon();
	int my_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
	int heaviest_weapon = GetHeaviestEnemyWeapon();
	int opponent_weapon = 0;
	int opponent_weapon_current = 0;

	if (enemy && enemy.Player)
	{
		wpn = Player(enemy.Player).BestWeapon();
		opponent_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
		opponent_weapon_current = KArenaWeapon(Player(enemy.Player).ReadyWeapon).Slot;
	}

	// Has only 2nd level weapon
	if (my_weapon <= 1)
	{
		Priority[priort_Weapons] += priorv_Weapons_BadEquipment;
	}
	if (my_weapon < heaviest_weapon)
	{
		Priority[priort_Weapons] += priorv_Weapons_HeavyEnemies;
	}
	if (my_weapon < opponent_weapon)
	{
		Priority[priort_Weapons] += priorv_Weapons_HeavyOpponent;
	}
	if (my_weapon < opponent_weapon_current)
	{
		Priority[priort_Weapons] += priorv_Weapons_HeavyOffence;
	}
	if (my_weapon < 7)
	{
		Priority[priort_Weapons] += priorv_Weapons_NotTheBest;
	}

	//----------------------------------------
	// Ammo
	//----------------------------------------

	//
	// [CW] This works a bit different thus not to repeat Inventory searches
	//
	if (player.IsOutOfAmmo())
	{
		Priority[priort_Ammo] += priorv_Ammo_Null;
		Priority[priort_Ammo] += priorv_Ammo_Low;
		Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
		Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
		if (enemy)
			Priority[priort_Ammo] += (priorv_Ammo_UnderFireBonus << 1);
	}
	else
	{
		if (player.IsAmmoBelowLevel(50))
		{
			Priority[priort_Ammo] += priorv_Ammo_Low;
			Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
			Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
			if (enemy)
				Priority[priort_Ammo] += priorv_Ammo_UnderFireBonus;
		}
		else if (player.IsAmmoBelowLevel(50, class<KArenaWeapon>(player.ReadyWeapon.Class)) ||
				 player.ReadyWeapon.CheckAmmo(player.ReadyWeapon.FireMode, false, true))
		{
			Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
			Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
			if (enemy)
				Priority[priort_Ammo] += priorv_Ammo_UnderFireBonus;
		}
		else
		{
			if (player.IsAmmoBelowLevel(200, none, Mana1) ||
				player.IsAmmoBelowLevel(200, none, Mana2) ||
				player.IsAmmoBelowLevel(200, none, ItemManaRed))
			{
				Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
			}
		}
	}

	//----------------------------------------
	// AlternativeAmmo
	//----------------------------------------

	if (player.IsOutOfAmmo(,,true))
	{
		Priority[priort_AltAmmo] += priorv_AltAmmo_Null;
		Priority[priort_AltAmmo] += priorv_AltAmmo_Low;
		Priority[priort_AltAmmo] += priorv_AltAmmo_NotMaximum;
		if (enemy)
			Priority[priort_AltAmmo] += priorv_AltAmmo_UnderFireBonus << 1;
	}
	else
	{
		if (player.IsAmmoBelowLevel(60,,,true))
		{
			Priority[priort_AltAmmo] += priorv_AltAmmo_Low;
			Priority[priort_AltAmmo] += priorv_AltAmmo_NotMaximum;
			if (enemy)
				Priority[priort_AltAmmo] += priorv_AltAmmo_UnderFireBonus;
		}
		else if (player.IsAmmoBelowLevel(200, none, ArtifactFlechette) ||
				player.IsAmmoBelowLevel(200, none, ArtifactBlastRadius))
		{			
			Priority[priort_AltAmmo] += priorv_AltAmmo_NotMaximum;
			if (enemy)
				Priority[priort_AltAmmo] += priorv_AltAmmo_UnderFireBonus;
		}
	}
	
	//----------------------------------------
	// Health & Armor
	//----------------------------------------

	if (EntityEx(player.MO).CheckInventory('health') <= 15)
	{
		Priority[priort_Health] += priorv_Health_Dying;
		Priority[priort_Armor] += priorv_Armor_LowHealthBonus << 1;
		if (enemy)
			Priority[priort_Health] += priorv_Health_UnderFireBonus << 1;
	}
	if (EntityEx(player.MO).CheckInventory('health') <= (player.max_health >> 1))
	{
		Priority[priort_Health] += priorv_Health_Low;
		Priority[priort_Armor] += priorv_Armor_LowHealthBonus;
		if (enemy)
			Priority[priort_Health] += priorv_Health_UnderFireBonus;
	}
	if (EntityEx(player.MO).CheckInventory('health') < player.max_health)
	{
		Priority[priort_Health] += priorv_Health_NotMaximum;
	}
	
	if (EntityEx(player.MO).CheckInventory('armor') == 0)
	{
		Priority[priort_Armor] += priorv_Armor_None;
		if (enemy)
			Priority[priort_Armor] += priorv_Armor_UnderFireBonus << 1;
	}
	else if (EntityEx(player.MO).CheckInventory('armor') <= 50)
	{
		Priority[priort_Armor] += priorv_Armor_Low;
		if (enemy)
			Priority[priort_Armor] += priorv_Armor_UnderFireBonus;
	}
	else if (EntityEx(player.MO).CheckInventory('armor') <= 100)
	{
		Priority[priort_Armor] += priorv_Armor_Half;
	}
	else if (EntityEx(player.MO).CheckInventory('armor') <= 200)
	{
		Priority[priort_Armor] += priorv_Armor_NotMaximum;
	}

	//----------------------------------------
	// Artifacts
	//----------------------------------------

	Priority[priort_Artifacts] += priorv_Artifacts_WantSome;

	//----------------------------------------
	// Special Equipment
	//----------------------------------------

	switch (gameInfo.GameType)
	{
		case HexenDefs::game_xmas:
			{
				if (!player.BestWeaponOfDamageType('Fire'))
				{
					Priority[priort_Special] += priort_Special_XmasHavocFireWpn;
				}
			}
	}

	//----------------------------------------
	// Enemy
	//----------------------------------------

	if (t_frust > 0.0)
	{
		Priority[priort_Enemy] += priorv_Enemy_Frustrated;
		if (t_hitme > 0.0)
			Priority[priort_Enemy] += priorv_Enemy_HitMeBonus << 2;	// AWOOOOO!!!
	}
	else if (t_pissed > 0.0)
	{
		Priority[priort_Enemy] += priorv_Enemy_Pissed;
		if (t_hitme > 0.0)
			Priority[priort_Enemy] += priorv_Enemy_HitMeBonus << 1;
	}
	else
	{
		Priority[priort_Enemy] += priorv_Enemy_Normal;
		if (t_hitme > 0.0)
			Priority[priort_Enemy] += priorv_Enemy_HitMeBonus;
	}

	//----------------------------------------
	// Nemesis
	//----------------------------------------

	if (nemesis)
	{
		if (t_frust > 0.0)
		{
			Priority[priort_Nemesis] += priorv_Nemesis_Frustrated;
			if (t_hitme > 0.0)
				Priority[priort_Nemesis] += priorv_Enemy_HitMeBonus << 2;	// AWOOOOO!!! BARK!! BARK!!
		}
		else	// 'just' pissed off
		{
			Priority[priort_Nemesis] += priorv_Nemesis_Pissed;
			if (t_hitme > 0.0)
				Priority[priort_Nemesis] += priorv_Enemy_HitMeBonus << 1;
		}
	}

	//----------------------------------------
	// Game Mode
	//----------------------------------------

	if (gameInfo.GameType < HexenDefs::NUMGAMESNOTEAM)
	{
		int plInPlay = gameInfo.GetPlayerCount();

		if (player.PlayerPosition > 0)
		{
			Priority[priort_GameMode] += priorv_GameMode_NotFirst;
			if (!player.Score)
				Priority[priort_GameMode] += priorv_GameMode_NoScoreBonus;
		}

		if (player.PlayerPosition == plInPlay - 1)
		{
			Priority[priort_GameMode] += priorv_GameMode_Last;
			if (!player.Score)
				Priority[priort_GameMode] += priorv_GameMode_NoScoreBonus << 2;
		}
		else if (player.PlayerPosition > 1)
		{
			Priority[priort_GameMode] += priorv_GameMode_Loosing;
			if (!player.Score)
				Priority[priort_GameMode] += priorv_GameMode_NoScoreBonus << 1;
		}
	}
	else if (gameInfo.GameType >= HexenDefs::NUMGAMESNOTEAM && player.Team)
	{
		int tmInPlay = gameInfo.GetTeamCount();

		if (player.Team.Position > 0)
		{
			Priority[priort_GameMode] += priorv_GameMode_NotFirst;
			if (!player.Team.Score)
				Priority[priort_GameMode] += priorv_GameMode_NoScoreBonus;
		}

		if (player.Team.Position == tmInPlay - 1)
		{
			Priority[priort_GameMode] += priorv_GameMode_Last;
			if (!player.Team.Score)
				Priority[priort_GameMode] += priorv_GameMode_NoScoreBonus << 2;
		}
		else if (player.Team.Position > 1)
		{
			Priority[priort_GameMode] += priorv_GameMode_Loosing;
			if (!player.Team.Score)
				Priority[priort_GameMode] += priorv_GameMode_NoScoreBonus << 1;
		}
	}

	if (GetGameModeGoal(false))
	{
		Priority[priort_GameMode] += priorv_GameMode_Normal;
	}

	int prior_max;
	int prior_limit = -1;

#ifdef DEBUG_BOT_AI_TARGET
	string PriorityName;
	print("--------------------------");
	print("priorities updated for %s:", player.PlayerName);
#endif
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
#ifdef DEBUG_BOT_AI_TARGET
		switch (i)
		{
		case priort_Weapons: PriorityName = "Weapons"; break;
		case priort_Ammo: PriorityName = "Ammo"; break;
		case priort_AltAmmo: PriorityName = "Alt-Ammo"; break;
		case priort_Health: PriorityName = "Health"; break;
		case priort_Armor: PriorityName = "Armor"; break;
		case priort_Artifacts: PriorityName = "Artifact"; break;
		case priort_Special: PriorityName = "Special"; break;
		case priort_Evade: PriorityName = "Evade"; break;
		case priort_Support: PriorityName = "Support"; break;
		case priort_GameMode: PriorityName = "GameMode"; break;
		default: PriorityName = "Unknown";
		}
		print("%s = %i", PriorityName, Priority[i]);
#endif
		Prior_Targets[i] = 0;
	}
#ifdef DEBUG_BOT_AI_TARGET
	print("--------------------------");
#endif

	// [CW] sort prioritised targets
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		prior_max = -1;
		for (j = 0; j < NUM_PRIORITIES; j++)
		{
			if (prior_limit >= 0 && Priority[j] >= prior_limit)
			{
				continue;
			}
			if (Priority[j] > prior_max ||
				Priority[j] == prior_max && P_Random() > 127)
			{
				Prior_Targets[i] = j;
				prior_max = Priority[j];
			}
		}

		prior_limit = Priority[Prior_Targets[i]];
	}

	ITarget = none;
}

//==========================================================================
//
//	GetHeaviestEnemyWeapon
//
//==========================================================================

int GetHeaviestEnemyWeapon()
{
	int i;
	Weapon wpn;
	int pl_weapon;
	int weapon = 0;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (gameInfo.Players[i] && gameInfo.Players[i].MO &&
			gameInfo.Players[i] != player &&
			Actor(gameInfo.Players[i].MO) == enemy)
		{
			wpn = PlayerEx(gameInfo.Players[i]).BestWeapon();
			pl_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
			if (pl_weapon > weapon)
			{
				weapon = pl_weapon;
			}
		}
	}

	return weapon;
}

//==========================================================================
//
//	GetFirstPriorityTarget
//
//	[CW] Handles Bot hunt for Important Game Objects and Inventory items.
//		What should be remembered, this method checks only these objects
//		that are reachable in this very moment. It is not usable for
//		planning some future actions.
//
//==========================================================================

Actor GetFirstPriorityTarget()
{
	Actor ee;
	Actor candidates[NUM_PRIORITIES];
	float dist[NUM_PRIORITIES];
	int i, priort;

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		dist[i] = -1.0;
	}

	if (nemesis)
		candidates[priort_Nemesis] = (botmo.CanReach(nemesis.Origin, nemesis) ? nemesis : none);
	if (!candidates[priort_Nemesis] && enemy && enemy != nemesis)
		candidates[priort_Enemy] = (botmo.CanReach(enemy.Origin, enemy) ? enemy : none);

	candidates[priort_GameMode] = GetGameModeGoal(true);
	if (!candidates[priort_GameMode])
	{
		if (candidates[priort_Nemesis])
			candidates[priort_GameMode] = candidates[priort_Nemesis];
		else if (candidates[priort_Enemy])
			candidates[priort_GameMode] = candidates[priort_Enemy];
		else
			candidates[priort_GameMode] = GetNearestPathNode(class<Thinker>(PathNode), true);
	}

	// [CW] Look over all acceptable objects, common to every map and game mode
	// and remember closest candidates for each of the priority type
	foreach botmo.AllThinkers(Actor, ee)
	{
		if (ee.bInvisible)
		{
			continue;
		}
		if (ee.bNoSector)
		{
			continue;
		}

		if (ee.IsA('Inventory'))
		{
			if (!player.IsOKToPickupItem(Inventory(ee)))
			{
				// [FB] We can't actually pick up this
				continue;
			}
		}

		if (ee.IsA('Weapon'))
		{
			//
			// Special cases
			//
			if (gameInfo.GameType == HexenDefs::game_xmas &&
				botmo.WeaponClasses[KArenaWeapon(ee).Slot - 1].default.DamageTypeHint == 'Fire')
			{
				priort = priort_Special;
			}
			//
			// Common case
			//
			else
				priort = priort_Weapons;
		}
		else if (ee.IsA('Ammo'))
		{
			if (ee.Class == ArtifactFlechette || ee.Class == ArtifactBlastRadius)
				priort = priort_AltAmmo;
			else
				priort = priort_Ammo;
		}
		else if (ee.IsA('Health'))
		{
			priort = priort_Health;
		}
		else if (ee.IsA('Armor'))
		{
			priort = priort_Armor;
		}
		else if (ee.IsA('Artifact'))
		{
			priort = priort_Artifacts;
		}
		else
		{
			continue;
		}

		if (!Priority[priort])
		{
			continue;
		}

		if (dist[priort] < 0.0 || Length(ee.Origin - botmo.Origin) < dist[priort])
		{
			if (botmo.CanSee(ee) && CheckTo(ee.Origin, ee))
			{
				candidates[priort] = ee;
				dist[priort] = Length(ee.Origin - botmo.Origin);
			}
		}
	}

	// Finally, select the top priority candidate found
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		if (!Priority[Prior_Targets[i]])
		{
			break;
		}
		if (candidates[Prior_Targets[i]])
		{
			IPriorityType = Prior_Targets[i];
			return candidates[Prior_Targets[i]];
		}
	}

	return none;
}

//==========================================================================
//
//	ProcessImmediate
//
//	[CW] The method allows Bot to make immediate decisions of what to do,
//		depending of the current situation and his preset priorities.
//
//==========================================================================

void ProcessImmediate()
{
	// [CW] Bot should always seek for an incoming missile
	if (!missile)
	{
		missile = FindMissile();
	}

	// still TODO: if bot has high Evade priority he should not draw attention to himself...
	// [CW] Bot should always seek for an enemy to attack one
	if (!enemy)
	{
		enemy = GetNearestEnemy(false);
	}
	else if (nemesis && botmo.CanSee(nemesis))
		enemy = nemesis;	// [CW] switch to hated enemy

	// [CW] Bot should always know where to go; this can be a pickup,
	//	    a specific map object or simply a path node.
	if (!ITarget)
	{
		//
		// While enemy is something that bot shoot at, ITarget is used mainly
		// to determine where he will move (except for immediate evade actions);
		// There are situations in which bot would rather shoot away at enemy,
		// at same time collecting some pickups or capturing objectives, and there
		// are cases where he would rather concentrate on enemy whacking, ignoring
		// other things.
		// ITarget must be set correspondingly, keeping all that said above in mind.
		//

		// [CW] Get any reachable object according to preset priorities
		ITarget = GetFirstPriorityTarget();

		if (ITarget)
		{
			// If Bot has got non-casional target, he should reset his nodes history
			if (!ITarget.IsA('PathNode') && !ITarget.IsA('Inventory'))
				nodes.Num = 0;
		}

		// [CW] Nearest node was being searched in GetFirstPriorityTarget
		/*// If Bot cannot find any reachable priority target at the moment,
		// he/she should try to get a reachable Path Node.
		else
		{
			ITarget = GetNearestPathNode(class<Thinker>(PathNode), true);
		}*/

		// [CW] No need to do this here anymore
		/*// [CW] In the very least case try to use 'enemy' as a "go for" target
		// (in fact, this is most unlikely to happen HERE, anyway)
		if (!ITarget && enemy && CheckTo(enemy.Origin, enemy))
		{
			ITarget = enemy;
		}*/
	}

#ifdef DEBUG_BOT_AI_TARGET
	if (ITarget)
	{
		print("BOT %s : my target is %n / %i", player.PlayerName, GetClassName(ITarget.Class), nodes.Num);
	}
#endif
	bSoftContact = false;
	bMeleeUrge = false;
	bKeepDistant = false;

	if (ITarget)
	{
		// [CW] Soft Contact means Bot should not lower speed when approach target;
		// That is, either target cannot block way or it HAS to be bumped into (like soccer ball)
		bSoftContact =	bAttackOffsetValid ||
						(!ITarget.bMonster && !ITarget.bSolid) ||
						ITarget.IsA('SoccerBall');

		if (ITarget == enemy)
		{
			// [CW] Depending on current weapons, enemy's and Bot's, Bot should decide
			// whether to approach or keep distance
			if (enemy.IsA('ZXmasHavocTree') && (KArenaWeapon(player.ReadyWeapon).bBotProjectileMedium ||
							player.ReadyWeapon.bBotProjectile))
				bKeepDistant = true;
			else
			{
				bMeleeUrge = KArenaWeapon(player.ReadyWeapon).bBotMelee && enemy.Player &&
							 (KArenaWeapon(Player(enemy.Player).ReadyWeapon).bBotProjectileMedium ||
								KArenaWeapon(Player(enemy.Player).ReadyWeapon).bBotProjectile);
				bKeepDistant = !bMeleeUrge && (!KArenaWeapon(player.ReadyWeapon).bBotProjectileMedium &&
								!KArenaWeapon(player.ReadyWeapon).bBotProjectile);
			}
		}
	}
}

//==========================================================================
//
//	GetNearestEnemy
//
//==========================================================================

Actor GetNearestEnemy(optional bool bReachable)
{
	if (enemy)
		return enemy;

	if (nemesis && botmo.CanSee(nemesis) && (!bReachable || botmo.CanReach(nemesis.Origin, nemesis)))
		return nemesis;

	Actor e = GetSpecialEnemy(bReachable);
	if (!e)
	{
		e = FindEnemy(bReachable);
	}
	return e;
}

//==========================================================================
//
//	GetSpecialEnemy
//
//==========================================================================

Actor GetSpecialEnemy(optional bool bReachable)
{
	Actor actor;
	int i;
	float dist, closest_dist;
	float vangle;
	int light;

	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
	{
		vangle = 360.0;
	}
	else
	{
		vangle = ENEMY_SCAN_FOV;
	}
	bAllRound = false;


	switch (gameInfo.GameType)
	{
		case HexenDefs::game_kth:

			// [CW] In KTH if there's a Heresiarch and he is not this Bot,
			// Bot must target only Heresiarch
			if (GameKTH(gameInfo.GameModel).State == GameKTH::state_heresiarch &&
				GameKTH(gameInfo.GameModel).plHeresiarch != player)
			{
				actor = Actor(GameKTH(gameInfo.GameModel).plHeresiarch.MO);
				dist = botmo.DistTo(actor);
			}
			break;

		case HexenDefs::game_ctf:

			closest_dist = -1.0;
			for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
			{
				CTFBanner Banner = GameCTF(gameInfo.GameModel).Banners[i];
				if (Banner.Team == player.Team)
				{
					// [CW] In any case Bot should try to gun the opposing flag-carrier down
					if (Banner.Status == CTFBanner::BANNER_STATUS__CARRIED)
					{
						dist = botmo.DistTo(Banner.Capturer.MO);
						if (closest_dist == -1.0 || closest_dist > dist)
						{
							actor = Actor(Banner.Capturer.MO);
							closest_dist = dist;
						}
					}
				}
			}
			break;

		case HexenDefs::game_xmas:

			if (player.BestWeaponOfDamageType('Fire'))
			{
				actor = Actor(botmo.A_GetNearestEntity(ZXmasHavocTree));
				if (actor)
					dist = botmo.DistTo(actor);
			}
			break;
	}

	if (actor)
	{
		if (dist <= EntityEx::MELEERANGE || Check_LOS(actor, vangle))
		{
			if (EntityEx(botmo).CanSee(actor))
			{
				light = actor.Sector->params.lightlevel; // [FB] Detect the light level
				if (actor.Sector->floor.LightSourceSector)
				{
					//[FB] Add static or dynamic lights?
					light += actor.Sector->floor.LightSourceSector;
				}
				// [FB] Too dark?
				// [CW] enhance this a bit, still human players usually CAN see in dark
				if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
				{
					if (light <= WHATS_VERYDARK)
					{
						if (P_Random() < 196)
						{
							return none;
						}
					}
					else if (P_Random() < 128)
					{
						return none;
					}
				}

				if (!bReachable || CheckTo(actor.Origin, actor))
					return actor;
			}
		}
	}

	return none;
}

//==========================================================================
//
//	GetGameModeGoal
//
//	[CW] Seeks for special objects, that have importance in current game mode.
//  No enemies shall be sought here (this is done separately)
//
//==========================================================================

Actor GetGameModeGoal(optional bool bReachable)
{
	Actor EE;
	Actor ee;
	float dist = -1.0;
	int i;

	switch (gameInfo.GameType)
	{
		case HexenDefs::game_ctf:

			for (i = 0; i < GameCTF(gameInfo.GameModel).Banners.Num; i++)
			{
				ee = GameCTF(gameInfo.GameModel).Banners[i];

				// [CW] Our flag (lost or captured) is highest priority
				// regardless of the bot status (offense/defence)
				// [FB] Check status of our flag
				if (CTFBanner(ee).Team == player.Team)
				{
					if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__CARRIED ||
						CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST ||
						// [CW] Now, that's special, if bot carries enemy flag
						// he must seek for his own flag even if it is on the base
						botstate.BState == bst_scoring &&
								CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE)
					{
						if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
						{
							if (!bReachable || CheckTo(ee.Origin, ee))
							{
								EE = ee;
								dist = Length(botmo.Origin - ee.Origin);
							}
						}
					}
				}
				
				// [CW] I suggest this be high priority in any case,
				// since if bot really can reach enemy flag at the moment
				// he better try to get one (unless he already carries a flag)
				// [FB] Check status of enemy flag
				if (botstate.BState != bst_scoring && CTFBanner(ee).Team != player.Team)
				{
					if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE ||
						CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST)
					{
						if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
						{
							if (!bReachable || CheckTo(ee.Origin, ee))
							{
								EE = ee;
								dist = Length(botmo.Origin - ee.Origin);
							}
						}
					}
				}
			}

			// [CW] If no Flag or Flag Carrier in sight, check for path
			// leading to our or their Flag
			if (!EE)
			{
				switch(botstate.BState)
				{
				case bst_offense:
					if (player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
					{
						EE = GetNearestPathNode(class<Thinker>(BlueNode), false);
					}
					else
					{
						EE = GetNearestPathNode(class<Thinker>(RedNode), false);
					}
					break;
				case bst_defense:
					if (player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
					{
						EE = GetNearestPathNode(class<Thinker>(BlueGuardSpot), false);
						if (!EE)
						{
							EE = GetNearestPathNode(class<Thinker>(BlueNode), false);
						}
					}
					else
					{
						EE = GetNearestPathNode(class<Thinker>(RedGuardSpot), false);
						if (!EE)
						{
							EE = GetNearestPathNode(class<Thinker>(RedNode), false);
						}
					}
					break;
				case bst_scoring:
					if (player.Team.T2 == PlayerTeam::TEAM2_INDEX_BLUE)
					{
						EE = GetNearestPathNode(class<Thinker>(BlueGoalSpot), false);
						if (!EE)
						{
							EE = GetNearestPathNode(class<Thinker>(BlueNode), false);
						}
					}
					else
					{
						EE = GetNearestPathNode(class<Thinker>(RedGoalSpot), false);
						if (!EE)
						{
							EE = GetNearestPathNode(class<Thinker>(RedNode), false);
						}
					}
					break;
				}
			}
			break;

		case HexenDefs::game_domination:

			for (i = 0; i < GameDomination(gameInfo.GameModel).DomSigils.Num; i++)
			{
				ee = GameDomination(gameInfo.GameModel).DomSigils[i];
				if (DominationSigil(ee).Team != player.Team &&
					(dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
				{
					if (!bReachable || CheckTo(ee.Origin, ee))
					{
						EE = ee;
						dist = Length(botmo.Origin - ee.Origin);
					}
				}
			}

			break;

		case HexenDefs::game_football:

			EE = GameFootball(gameInfo.GameModel).Ball;
			bAttackOffsetValid = false;

			// [CW] set a target offset
			if (EE)
			{
				int team;
				Actor sts;
				GameFootball fb = GameFootball(gameInfo.GameModel);
				if (gameInfo.Teams[0] == player.Team)
				{
					team = 1;
				}
				else
				{
					team = 0;
				}

				// Get nearest goal target
				for (i = 0; i < fb.spot_targets.Num; i++)
				{
					if (fb.spot_targets[i].Args[0] != team)
					{
						continue;
					}
					ee = fb.spot_targets[i];
					if ((dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
					{
						if (!bReachable || CheckTo(ee.Origin, ee))
						{
							sts = ee;
							dist = Length(botmo.Origin - ee.Origin);
						}
					}
				}

				if (sts)
				{
					AttackOffset = (Normalise(EE.Origin - sts.Origin) * (botmo.Radius * 2.0)) + EE.Origin;
					bAttackOffsetValid = true;
				}
			}
			break;
	}

	//if (!EE)
	//	EE = GetNearestPathNode(class<Thinker>(PriorityNode), false);

	// [CW] No need in this since now we have separate Enemy priority type
	//if (!EE)
	//	EE = GetNearestEnemy(true);

	return EE;
}

//==========================================================================
//
//	GetNearestPathNode
//
//==========================================================================

Actor GetNearestPathNode(class<Thinker> NodeType, optional bool bFinal)
{
	PathNode PN;
	PathNode pn;
	float dist = -1.0;
	bool visited;
	int i;

	array<PathNode> skipped;

	PathNode previous;

	if (nodes.Num)
	{
		previous = nodes[nodes.Num - 1];
	}

	foreach botmo.AllThinkers(NodeType, pn)
	{
		if (pn == node_current)
		{
			continue;
		}

		visited = false;
		for (i = 0; i < nodes.Num; i++)
		{
			if (nodes[i] == pn)
			{
				visited = true;
				break;
			}
		}

		if (visited)
		{
			continue;
		}

		if (dist < 0.0 || Length(pn.Origin - botmo.Origin) < dist)
		{
			if (CheckTo(pn.Origin))
			{
				if (pn.Class == PathNode && P_Random() < 33)
				{
					// skip common nodes sometimes to give bot movement more variety
					skipped.Num = skipped.Num + 1;
					skipped[skipped.Num - 1] = pn;
					continue;
				}

				PN = pn;
				dist = Length(pn.Origin - botmo.Origin);
			}
		}
	}

	if (PN)
	{
		if (skipped.Num)
		{
			int oldNum = nodes.Num;
			nodes.Num = nodes.Num + skipped.Num;
			for (i = oldNum; i < nodes.Num; i++)
			{
				nodes[i] = skipped[i - oldNum];
			}
		}

		if (node_current)
		{
			// emulate Queue
			if (nodes.Num >= 256)
			{
				for (i = 1; i < nodes.Num; i++)
					nodes[i - 1] = nodes[i];
			}
			else
				nodes.Num = nodes.Num + 1;
			nodes[nodes.Num - 1] = node_current;
		}
		node_current = PN;
	}
	else
	{
		if (bFinal)
		{
			if (node_current)
			{
				nodes.Num = 1;
				nodes[0] = node_current;
			}
			else
			{
				nodes.Num = 0;
			}
			node_current = previous;
		}
		else return none;
	}
	return node_current;
}

defaultproperties
{
}
