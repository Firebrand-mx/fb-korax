//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		    ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: BotPlayer.vc 1133 2007-11-26 23:13:04Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The
//  main bot AI loop, BotTick, is called every tic.
//  Also included are various bot decision-making
//  procedures, such as CheckStuff and SetEnemy.
//
//	[CW] ... also includes so many other things, ough-uh...
//
//**************************************************************************

// Main bot class
class BotPlayer : Object;

const float
	FORWARDWALK				= 200.0,
	FORWARDRUN				= 400.0,
	SIDEWALK				= 192.0,
	SIDERUN					= 320.0,

	MAX_TRAVERSE_DIST		= 1024.0,		// 10 meters, used within b_func.c
	AVOID_DIST				= 512.0,		// Try avoid incoming missiles once they reached this close
	SAFE_SELF_MISDIST		= 128.0,		// Distance from self to target where it's safe to pull a rocket.
	FRIEND_DIST				= 1024.0,		// To friend.
	DARK_DIST				= 256.0,		// Distance that bot can see enemies in the dark from.
	MAX_MONSTER_TARGET_DIST	= 1024.0,		// Too high can slow down the performance, see P_mobj.c
	ENEMY_SCAN_FOV			= 120.0,
	MAXMOVEHEIGHT			= 32.0,			// MAXSTEPMOVE but with jumping counted in.
	GETINCOMBAT				= 512.0,		// Max distance to item if it's due to be picked up in a combat situation.
	SHOOTFOV				= 60.0,
	MAXROAM					= (5.0 * 35.0);	// When this time is elapsed the bot will roam after something else.
const int
	WHATS_DARK		= 64,					// light value thats classed as dark.
	WHATS_VERYDARK	= 24;

/*

  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.

*/

// [FB] Bot Difficulty/skill settings/filters.
enum
{
	bsk_verypoor,
	bsk_poor,
	bsk_low,
	bsk_medium,
	bsk_high,
	bsk_excellent,
	bsk_supreme
};

struct botinfo_t
{
	string Name;		// Bot's name
	int accuracy;		// Accuracy with "instant" weapons (this includes "leading")
	int intelect;		// Accuracy with "missile" weapons (rocket launcher, etc.)
	int evade;			// Ability to dodge incoming missiles
	int anticip;		// Ability to anticipate "instant" shots
	int reaction;		// Overall reaction time (lower is "better")
	int pisschance;		// Chance the bot will get pissed when his threshold is reached
	int threshold;		// How much it takes to frustrate/piss off the bot
	int dangerlevel;	// When health is below this, we need some health
/*	int wpfav;			// Favorite weapon
	int chatinfo;		// Bot's chat strings
	int chattime;		// How long it takes us to type a line
	int chatty;			// How talkative the bot is
	char *colour;		// Colour (in form of a string)
	char *gender;		// Male/female/it :)
	char *skin;			// Skin
	int railcolour;		// Railgun trail colour
	bool revealed;		// Hidden bots must be revealed*/
	string userinfo;
};
/*
struct chatline_t
{
//	string		*string;
//	chattype_t  bot;
	chatline_t	*line;
};

struct chatinfo_t
{
	chatline_t		intro[5];
	chatline_t		inter[5];
	chatline_t		rare[5];
	chatline_t		frag[15];
	chatline_t		died[10];
	chatline_t		roam[10];
	chatline_t		pissed[5];
	chatline_t		frustrated[5];
	chatline_t		special[20];
};
*/
enum { NUMTOTALBOTS = 24 };
enum { NUMBOTTYPES = 24 };

//
// [CW] Okay, here I'll begin to add something =)
//

//
// [CW] Priority counters: basically speaking, the one with larger value
//		determine what this Bot should aim to
//
enum
{
	priort_Weapons,		// tells how much Bot needs a new weapon
	priort_Ammo,		// tells how much Bot needs an ammo
	priort_Health,		// tells how much Bot needs health and/or armor
	priort_Artifacts,	// tells how much Bot needs an artifact... not sure this would be useful, but let's have it
	priort_Evade,		// tells how much Bot needs to get away from enemies
	priort_Support,		// tells how much Bot needs to support his buddy in combat
	priort_GameMode,	// tells how much Bot needs to peform some task specific to advanced gamemode
	NUM_PRIORITIES
						// those evening bells, those evening bells, something bla-bla-bla their music tells...
};

int Priority[NUM_PRIORITIES];		// current priority values
int Prior_Targets[NUM_PRIORITIES];	// prioritised list of actions

// [CW] Priority additive values (by categories)
enum
{
	priorv_Weapons_BadEquipment		= 16,	// has only low level weapons (1,2)
	priorv_Weapons_HeavyEnemies		= 8,	// enemies has more powerful weapons
	priorv_Weapons_HeavyOpponent	= 12,	// opponent has more powerful weapons
	priorv_Weapons_HeavyOffence		= 16,	// opponent wields more poweful weapon (currently)
	priorv_Weapons_NotTheBest		= 8,

	priorv_Ammo_Null				= 20,	// need ammo ...NOW!!
	priorv_Ammo_Low					= 12,	// overall ammo is low
	priorv_Ammo_ThisWeaponLow		= 8,	// ammo for selected weapon is low
	priorv_Ammo_NotMaximum			= 4,	// you can never be sure you have enouph

	priorv_Health_Dying				= 40,	// need health ...now!!... NO, FASTER THAN NOW!!
	priorv_Health_Low				= 12,	// health is low
	priorv_Health_NotMaximum		= 8,	// this won't last for long
	priorv_Health_ArmorNotMaximum	= 4,	// health is at max limit, but armor still not

	priorv_Artifacts_WantSome		= 4,	// ..huh..

	priorv_Evade_Nightmare			= 20,	// SOS!
	priorv_Evade_Tactical			= 12,	// i'll be back
	priorv_Evade_TakeABreak			= 8,	// just need to rest for a while

	priorv_Support					= 0,

	priorv_GameMode_NoScore			= 12,
	priorv_GameMode_NotFirst		= 8,
	priorv_GameMode_Loosing			= 12,
	priorv_GameMode_Last			= 16,
	priorv_GameMode_Normal			= 8
};

//
// [CW] So, idea is, that bot summarize its current situation periodically and decides what he should do next
//
const float AI_TIME_DELAY	= 5.0;	// in seconds
float AITime;

//
// Bot states
//
// [CW] This is currently not used...
// [FB] We'll be using it now ;)
enum
{
	bst_deciding,	// 	Bot is deciding what to do
	bst_offense,	// 	Bot is "fetching" something (offense)
	bst_defense,	// 	Bot is defending something
	bst_scoring		// 	Bot is heading to scoring place
};

struct botstate_t
{
	int BState;
};

Player player;			// Points to reference player
KArenaPlayerPawn botmo;
MainGameInfo gameInfo;

// [CW] try this...
Actor FTarget;			// final target (goal) ----- currently UNUSED
Actor ITarget;			// immediate target (where to go)
//TVec ITargetPos;		// immediate target position (valid in specific situations)
TVec AttackOffset;		// basically, a point to get to just before heading to target
PathNode node_current;
array<PathNode> nodes;  // list of visited nodes (to make bot move freely along the map)

Actor enemy;			// The dead meat.
Actor nemesis;			// Prefered enemy to chase when pissed off

Actor ally;				// Ally to tag along with
Actor last_mate;		// If bots mate dissapeared (not if died) that mate is
						// pointed to by this. Allows bot to roam to it if
						// necessary.
Actor missile;			// A threathing missile that got to be avoided.

botstate_t botstate;	// What we're doing in teamgame mode

// Tickers
float t_respawn;
float t_strafe;
float t_react;
/*float t_fight;
float t_rocket;*/
float t_turn;
float t_pissed;
float t_frust;
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;
//float t_chat;				// Tics left until bots completes "typing" in what he's saying.
						// Bot also doesn't do anything during this time.

float forwardmove;		// For building ucmd
float sidemove;

// Flags, controlling movement
bool bSoftContact;		// Target is something that could be passed through without slowing down
bool bMeleeUrge;		// Must come closer to enemy as quickly as possible
bool bKeepDistant;		// Enemy should be attacked from distance
//bool bUseTargetPosition;	// ITargetPos is valid
bool bAttackOffsetValid;// Use AttackOffset


// Misc booleans
bool bAllRound;

/*chatline_t	*chatline;			// For when t_chat expires

bottype_t	bottype;			// Bot type*/
botinfo_t info;			// Aiming, name, perfection, yadda yadda

int angerlevel;

float angle;			// The wanted angle that the bot tries to get every tic.

// -----------------------------------------------------------
//
// Darkness Stats Update
//
// -----------------------------------------------------------

// [FB] Copy of certain affected stats for Darkness
int old_intelect;
int old_anticip;
int old_evade;
int old_accuracy;

// [FB] Used to determine if stats have been reduced
bool accuracy_r;
bool intelect_r;
bool evade_r;
bool anticip_r;

// -----------------------------------------------------------
//
// Pissed off Stats Update
//
// -----------------------------------------------------------

// [FB] Copy of certain affected stats for Darkness
int n_anticip;
int n_evade;
int n_accuracy;

// [FB] Used to determine if stats have been updated when pissed off
bool p_init;

//==========================================================================
//
//	AngleTo
//
//	Returns yaw angle to a certain location
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	AngleTo2
//
//	Returns pitch angle to a certain location
//
//==========================================================================

float AngleTo2(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.pitch;
}

//==========================================================================
//
//	SetAction
//
//	Decide what to do in teamgame (defend, whatever)
//
//==========================================================================

void SetAction()
{
	int i;
	int defenders = 0;
	int attackers = 0;

	if (!player.Team)
		return;

	// [FB] We are deciding what to do
	if (botstate.BState == bst_deciding)
	{
		// Let's see what the other bots on our
		// team are doing, and decide our action based
		// off on that
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO && 
			    Player(player.Level.Game.Players[i]).bIsBot && 
			    Player(player.Level.Game.Players[i]).Team == player.Team)
			{
				// [FB] Is this bot in Offense?
				if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == bst_offense)
					attackers++;
				// [FB] Is this bot in Defense?
				if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == bst_defense)
					defenders++;
			}
		}

		// Defense wins championships...
		if (defenders <= attackers)
			// [FB] Then get on defense
			botstate.BState = bst_defense;
		else
			// [FB] Then get on offense
			botstate.BState = bst_offense;
	}
}

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	switch (sec->special & ~SECSPEC_SECRET_MASK)
	{
		case 4:		// Scroll_EastLavaDamage
		case 5:		// Damage_LavaWimpy
		case 7:		// Damage_Sludge
		case 16:	// Damage_LavaHefty
			return true;
	}

	return false;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//	[CW] keep in mind that this method is now used only during short move
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;
	intercept_t* in;
	float bottracerange;
	TVec bottracedir;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	bottracedir.z = 0.0;	
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + botmo.Radius + dist * bottracedir.x;
 	y2 = y1 + botmo.Radius + dist * bottracedir.y;

	// [FB] Use lines
	EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');

	//	[BC] For the bots
	//	[FB] Additions for 3d floor checks
	foreach botmo.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS)
	{
		EntityEx th;
		line_t *ld;
		TVec hit_point;
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight, dheight;

		if (in->bIsALine)
		{
			ld = in->line;	// This linedef
			hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

			// Line is impassible
			if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING) || (ld->flags & ML_BLOCKEVERYTHING))
			{
				return false;
			}

			// Line isn't two sided
			if (!ld->backsector)
			{
				return false;
			}

			if (!PointOnPlaneSide(botmo.Origin, ld))
			{
				back = ld->backsector;
				front = ld->frontsector;
			}
			else
			{
				back = ld->frontsector;
				front = ld->backsector;
			}

			// Sector is dangerous
			if (IsDangerous(back))
			{
				return false;
			}

			// crosses a two sided line
			open = LineOpenings(ld, hit_point);
			open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);

			// No valid openings
			if (!open || open->range <= botmo.Height)
			{
				return false;
			}
			else
			{
				// [FB] No cliff jumping unless we're going after something
				if ((open->lowfloor - open->bottom) > 32.0 && (open->lowfloor - open->bottom) < 384.0 && !enemy)
				{
					return false;
				}

				// [FB] Determine if it's wise to jump up to a floor
				diffheight = open->bottom - open->lowfloor;

				if (diffheight > 0.0)
				{
					if (diffheight >= 24.0 && diffheight <= 56.0)
					{
						botmo.Player.Buttons |= BT_JUMP;
						continue;
					}
					else if (diffheight > 56.0)
					{
						// CHECKME!!
					/*	if (front->SSpecial == ThrustThingZ || front->springpadzone)
						{
							return true;
						}
						else*/
							return false;
					}
				}
			}
		}
		else
		{
			th = EntityEx(in->Thing);

			if (Actor(th) == botmo)
			{
				continue;
			}

			if (th.bSolid && th != enemy)
			{
				// [FB] Jump to avoid something
				dheight = th.Origin.z + th.Height - botmo.Origin.z;

				if (dheight >= 24.0 && dheight <= 56.0)
				{
					botmo.Player.Buttons |= BT_JUMP;
					continue;
				}

				return false;
			}

			// [FB] Jump to reach something
			dheight = th.Origin.z + th.Height - botmo.Origin.z;

			if (dheight >= 24.0 && dheight <= 56.0)
			{
				botmo.Player.Buttons |= BT_JUMP;
				continue;
			}
		}
	}

	return true;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if a location is reachable
//
//==========================================================================

bool CheckTo(TVec pos, optional EntityEx TargetEntity)
{
	if (!specified_TargetEntity)
		TargetEntity = none;

	return botmo.CanReach(pos, TargetEntity, 56.0/*[CW] FIXME! - jump height*/, 384.0/*[CW] FIXME!*/, botmo.Height);
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff()
{
	if (enemy)
	{
		if (enemy.Health <= 0 || !enemy.bShootable || enemy.bDormant || !botmo.CanSee(enemy))
			enemy = none;
	}

	if (missile)
	{
		if (!missile.bMissile || missile.IsDestroyed())
			missile = none;
	}

	// [CW]
	if (ITarget)
	{
		if ((ITarget.IsA('Inventory') && (ITarget.Owner || ITarget.bInvisible)) ||
				(ITarget == node_current && Length(botmo.Origin - ITarget.Origin) <= EntityEx::MELEERANGE) ||
				!CheckTo(ITarget.Origin, ITarget))
			ITarget = none;
	}
}

//==========================================================================
//
//	Check_LOS
//
//	Doesn't check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(EntityEx to, float vangle)
{
	if (!botmo.CanSee(to))
		return false; // out of sight
	if (vangle == 360.0)
		return true;
	if (vangle == 0.0)
		return false; // Looker seems to be blind.

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
		return skill;

	skill -= num;
	if (skill < 0)
		skill = 0;

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
	if (t_turn)
		return;

	angle = AngleMod360(an);
//	angle = an;

	if (!enemy)
		return;

	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
			t_turn = 4.0 / 3.0;
			break;
		case bsk_low:
			t_turn = 2.0 / 3.0;
			break;
		case bsk_medium:
			t_turn = 1.0 / 2.0;
			break;
		case bsk_high:
			t_turn = 1.0 / 4.0;
			break;
		case bsk_excellent:
			t_turn = 1.0 / 8.0;
			break;
		case bsk_supreme:
			break;
	}
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle()
{
	return angle;
}

//==========================================================================
//
//	AimProjectile
//
// 	[FB] Projectile weapons
//
//==========================================================================

void AimProjectile(float dist, bool right, float an)
{
	// [BC] Cajun prediction
	// Here goes the prediction.
	float m = (dist / 875.0); // FIXME Determine current weapon's missile speed
	float px = enemy.Origin.x + (enemy.Origin.x + (enemy.Velocity.x * m * 2.0));
	float py = enemy.Origin.y + (enemy.Origin.y + (enemy.Velocity.y * m * 2.0));

	switch (info.intelect)
	{
		case bsk_verypoor:
		case bsk_poor:
			if (MainGameInfo(player.Level.Game).botskill > 3 && Random() < 0.01)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
/*				SetAngle(R_PointToAngle2(MO->x,
							      MO->y,
							      enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
							      enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));*/	
			}
			else
			{
				// Aim right at the enemy
				SetAngle(an);
			}
			break;
		case bsk_low:
			if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.03)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				// Aim right at the enemy
				SetAngle(an);
			}
			break;
		case bsk_medium:
			if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.09)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
					SetAngle(an + Random() * 20.0);
				else
					SetAngle(an - Random() * 20.0);
			}
			break;
		case bsk_high:
			if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.9)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
					SetAngle(an + Random() * 20.0);
				else
					SetAngle(an - Random() * 20.0);
			}
			break;
		case bsk_excellent:
			if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.3)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
					SetAngle(an + Random() * 20.0);
				else
					SetAngle(an - Random() * 20.0);
			}
			break;
		case bsk_supreme:
			if (MainGameInfo(player.Level.Game).botskill > 0 && Random() < 0.1)
			{
				SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
			}
			else
			{
				if (right)
					SetAngle(an + Random() * 20.0);
				else
					SetAngle(an - Random() * 20.0);
			}
			break;
		default:
			Error("BotPlayer::AimProjectile::Unknown bot accuracy skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	AimInstant
//
// 	[FB] Instant weapons
//
//==========================================================================

void AimInstant(float dist, bool right, float an)
{
	// [CW] : temporary fix
	if (info.accuracy < bsk_high && dist < EntityEx::MELEERANGE * 2.0)
	{
		SetAngle(an);
		return;
	}

	// FIXME: Implement botskill, accuracy, and intelligence
	switch (info.accuracy)
	{
		case bsk_verypoor:
			if (right)
				SetAngle(an + Random() * 60.0);
			else
				SetAngle(an - Random() * 60.0);
			break;
		case bsk_poor:
			if (right)
				SetAngle(an + Random() * 45.0);
			else
				SetAngle(an - Random() * 45.0);
			break;
		case bsk_low:
			if (right)
				SetAngle(an + Random() * 30.0);
			else
				SetAngle(an - Random() * 30.0);
			break;
		case bsk_medium:
			if (right)
				SetAngle(an + Random() * 15.0);
			else
				SetAngle(an - Random() * 15.0);
			break;
		case bsk_high:
			SetAngle(an);
			break;
		case bsk_excellent:
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		case bsk_supreme://FIXME
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		default:
			Error("BotPlayer::AimInstant::Unknown bot accuracy skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	Aim
//
//==========================================================================

void Aim()
{
	float dist;
	bool right;
	float an;
	int i;

	if (!enemy)
	{
		// [CW] Target can be other object, simply face its direction
		if (ITarget)
			SetAngle(AngleTo(ITarget.Origin));
		return;
	}

	if (t_react > 4.0)
		return;

	// Distance to enemy.
	dist = botmo.DistTo2(enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [FB] Decide our weapon if we have an enemy
	// [JL] NOTE the old code didn't change weapon correctly meaning this would
	// never work. I'll enable fixed version but with very low chance.
	// [CW] removed JL's limit
	if (/*Random() < 0.001 || */player.ReadyWeapon.bWimpyWeapon)
	{
		Weapon Best = ChooseWeapon(dist);
		if (Best && Best != player.ReadyWeapon)
		{
			player.PendingWeapon = Best;
		}
	}

	// [FB] Set fire time
	t_fire = KArenaWeapon(player.ReadyWeapon).fire_tics;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		// [FB] Set t_anticip for our enemies
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
			player.Level.Game.Players[i].bIsBot &&
			Player(player.Level.Game.Players[i]).Bot.enemy && 
			Player(player.Level.Game.Players[i]).Bot.enemy == botmo)
			Player(player.Level.Game.Players[i]).Bot.t_anticip = 
					KArenaWeapon(player.ReadyWeapon).refire_tics;
	}

	// [FB] set pitch accordingly...
	Pitch();
	
	// [FB] ...and Decide which kind of aiming the bot will use
	if (player.ReadyWeapon.bBotProjectile)
	{
		AimProjectile(dist, right, an);
	}
	else
	{
		AimInstant(dist, right, an);
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy()
{
	float closest_dist, dist;
	Actor target;
	float vangle;
	int i, light;
	Actor actor;

	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
		vangle = 360.0;
	else
		vangle = ENEMY_SCAN_FOV;
	bAllRound = false;

	// [CW] no need to pass through this if there are no monsters on map 
	if (!GetCvar('NoMonsters'))
	{
		// [FB] Search for monster enemies
		foreach botmo.AllThinkers(Actor, actor)
		{
			dist = botmo.DistTo(actor);

			if (!(actor.bMonster))
				continue;
			if (!Check_LOS(actor, vangle))
				continue;
			if (!botmo.CanSee(actor))
				continue;
			if (actor.Health <= 0)
				continue;
			// [FB] We spawned the minotaur? we shouldn't attack him then!
			if (actor.Class == Minotaur)
			{
				if (actor.Tracer == botmo)
					continue;
				// [FB] Don't attack a friendly minotaur in all these cases
				if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep)
					continue;
				else if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
				{
					bool SameTeam = false;
					// [FB] Check if an advanced game mode is active
					if (MainGameInfo(player.Level.Game).GameModel)
					{
						int teamfactor;

						teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(actor.Tracer,
									Actor(botmo));
						// [FB] We've got a team factor, just check if it's an ally or not
						if (teamfactor != GameModel::teamfactor_any &&
							teamfactor != GameModel::teamfactor_enemy)
							continue;
					}
					// [FB] Check if the minotaur's instigator is in the same team we are on
					for(i = 0; i < MAXPLAYERS; i++)
					{						
						if (actor.Tracer == player.Level.Game.Players[i] && 
							Player(player.Level.Game.Players[i]).Team == player.Team)
						{
							SameTeam = true;
							break;
						}
					}
					if (SameTeam)
						continue;
				}
			}
			if (dist > MAX_MONSTER_TARGET_DIST)
				continue;

			target = none;
			closest_dist = 99999.0;

			 // Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always
			 // returns false. tought it should be the same checksight as below but.. (below works) something
			 // must be fuckin wierd screded up.
			if (Check_LOS(actor, vangle))
			{
				//if (botmo.CanSee(actor))
				//{
					dist = botmo.DistTo(actor);
					light = actor.Sector->params.lightlevel; // [FB] Detect the light level
					if (actor.Sector->floor.LightSourceSector)
					{
						//[FB] Add static or dynamic lights?
						light += actor.Sector->floor.LightSourceSector;
					}
					// [FB] Too dark? // [CW] enhance this a bit, still human players usually CAN see in dark
					if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
					{
						if (light <= WHATS_VERYDARK)
						{
							if (P_Random() < 196)
								continue;
						}
						else if (P_Random() < 128)
							continue;
					}
					if (dist < closest_dist)
					{
						closest_dist = dist;
						target = actor;
					}
				//}
			}
			return target;
		}
	}

	target = none;
	closest_dist = 99999.0;

	// [CW] Don't waste time searching enemy players if this is coop game mode
	if (MainGameInfo(player.Level.Game).bIsCoopGame[MainGameInfo(player.Level.Game).GameType])
		return none;

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
		    player.Level.Game.Players[i].MO.Health > 0 && !Player(player.Level.Game.Players[i]).bUnControllable && 
			botmo != player.Level.Game.Players[i].MO)
		{
			if (MainGameInfo(player.Level.Game).GameModel) // [CW] Check if an advanced game mode is active
			{
				int teamfactor;

				teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(Actor(botmo),
					     Actor(player.Level.Game.Players[i].MO));
				// [CW] We've got a team factor, check if it can be an enemy
				if (teamfactor != GameModel::teamfactor_any &&
				    teamfactor != GameModel::teamfactor_enemy)
					continue;
			}
			// [FB] Are we on a Team gameplay mode?
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				// [FB] Don't attack same team players
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
					continue;
			}
			// Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost
			// always returns false. tought it should be the same checksight as below but.. (below
			// works) something must be fuckin wierd screded up.
			// [CW] ok... let's see what is here...
			dist = botmo.DistTo(player.Level.Game.Players[i].MO);

			if (dist <= EntityEx::MELEERANGE ||
				(botmo.Sector->SoundTarget == player.Level.Game.Players[i].MO &&
				botmo.CanSee(botmo.Sector->SoundTarget)) ||
				Check_LOS(EntityEx(player.Level.Game.Players[i].MO), vangle))
			{
				// [CW] I disable this one...
				//if (botmo.CanSee(player.Level.Game.Players[i].MO))
				//{
					// [FB] Detect the light level
					light = player.Level.Game.Players[i].MO.Sector->params.lightlevel;
					if (player.Level.Game.Players[i].MO.Sector->floor.LightSourceSector)
					{
						//[FB] Add static or dynamic lights?
						light += player.Level.Game.Players[i].MO.Sector->floor.LightSourceSector;
					}
					// [FB] Too dark? // [CW] enhance this a bit, still human players usually CAN see in dark
					if (light <= WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
					{
						if (light <= WHATS_VERYDARK)
						{
							if (P_Random() < 196)
								continue;
						}
						else if (P_Random() < 128)
							continue;
					}
					if (dist < closest_dist)
					{
						closest_dist = dist;
						target = Actor(player.Level.Game.Players[i].MO);
					}
				//}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	FindMissile
//
//	[FB] Check for Missiles to avoid
//
//==========================================================================

Actor FindMissile()
{
	Actor actor;

	foreach botmo.AllThinkers(Actor, actor)
	{
		if (Check_LOS(actor, 90.0))
		{
			if (!missile && actor.bMissile &&
				(botmo.DistTo(actor) <= AVOID_DIST))
			{
				return actor;
			}
		}
	}

	return none;
}

//==========================================================================
//
//	ChooseWeapon
//
//	[FB] Decide which weapon would be best to use in our situation
//
//==========================================================================

Weapon ChooseWeapon(float dist)
{
	Inventory		Item;
	KArenaWeapon	Wpn;
	Weapon			Best = none;

	if (enemy)
	{
		for (Item = botmo.Inventory; Item; Item = Item.Inventory)
		{
			Wpn = KArenaWeapon(Item);
			if (!Wpn)
			{
				//	Not a weapon.
				continue;
			}
			if (dist <= Actor::MELEERANGE)
			{
				if (!Wpn.bBotChooseMelee)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else if (dist <= 512.0)
			{
				if (!Wpn.bBotChooseMedium)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else
			{
				if (!Wpn.bBotChooseRanged)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			if (!Wpn.CheckAmmo(Wpn.FireMode, false))
			{
				//	Not enough ammo.
				continue;
			}
			Best = Wpn;
		}
		if (Best)
		{
			return Best;
		}
	}
	// Didn't find anything good
	return player.ReadyWeapon;
}

//==========================================================================
//
//	ChooseAltWeapon
//
//	[FB] Decide which alternate weapon would be best to use in our situation
//
//==========================================================================

void ChooseAltWeapon(float dist)
{
	Ammo AltWpn;

	if (enemy)
	{
		if (dist <= Actor::MELEERANGE)
		{
			player.Impulse = !!P_Random() & 1 ? HexenDefs::IMPULSE__TOGGLE_BLASTRAD : HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
			player.PlayerImpulse();
			// [FB] We've got several choices here so we'll cycle them
			switch(player.altWeaponMode[player.altWeapon])
			{
				case HexenDefs::ALTFIRE_BLASTRADIUS_INSTANT:
				{
					AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));
					if (AltWpn && AltWpn.Amount > 10)
					{
						// [FB] We can keep this alternate weapon
						return;
					}
					break;
				}
				case HexenDefs::ALTFIRE_POISONBAG_BOMB:
				case HexenDefs::ALTFIRE_POISONBAG_CLOUD:
				{
					AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));
					if (AltWpn && AltWpn.Amount > 10)
					{
						// [FB] We can keep this alternate weapon
						return;
					}
					break;
				}
				default:
				{
					player.Impulse = !!P_Random() & 1 ? HexenDefs::IMPULSE__TOGGLE_BLASTRAD : HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
					player.PlayerImpulse();
					return;
				}
			}
		}
		else if (dist <= 512.0)
		{
			player.Impulse = !!P_Random() & 1 ? HexenDefs::IMPULSE__TOGGLE_BLASTRAD : HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
			player.PlayerImpulse();
			// [FB] We've got several choices here so we'll cycle them
			switch(player.altWeaponMode[player.altWeapon])
			{
				case HexenDefs::ALTFIRE_BLASTRADIUS_INSTANT:
				{
					AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));
					if (AltWpn && AltWpn.Amount > 10)
					{
						// [FB] We can keep this alternate weapon
						return;
					}
					break;
				}
				default:
				{
					AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));
					if (AltWpn && AltWpn.Amount > 10)
					{
						// [FB] We can keep this alternate weapon
						return;
					}
					break;
				}
			}
		}
		else
		{
			player.Impulse = HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
			player.PlayerImpulse();
			// [FB] We've got several choices here so we'll cycle them
			switch(player.altWeaponMode[player.altWeapon])
			{
				case HexenDefs::ALTFIRE_POISONBAG_BOMB:
				{
					AltWpn = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));
					if (AltWpn && AltWpn.Amount > 10)
					{
						// [FB] We can keep this alternate weapon
						return;
					}
					break;
				}
				default:
				{
					player.Impulse = !!P_Random() & 1 ? HexenDefs::IMPULSE__TOGGLE_BLASTRAD : HexenDefs::IMPULSE__TOGGLE_POSIONBAG;
					player.PlayerImpulse();
					return;
				}
			}
		}
	}
	return;
}

//==========================================================================
//
//	SetAlly
//
//	[FB] This function is called every tick (for each bot) to set the
//	     mate (teammate coop mate).
//
//==========================================================================

Actor SetAlly()
{
	float closest_dist, test;
	Actor target;
	int i, j;

	//is mate alive?
	if (ally)
	{
		if (ally.Health <= 0)
		{
			ally = none;
		}
		else
		{
			last_mate = ally;
		}
	}

	//Check old_mates status.
	if (!ally && last_mate)
	{
		if (last_mate.Health <= 0)
		{
			last_mate = none;
			ally = last_mate;
		}
		else
		{
			ally = last_mate;
		}
	}

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if ((player.Level.Game.Players[i]) && (botmo != player.Level.Game.Players[i].MO))
		{
			if (MainGameInfo(player.Level.Game).GameModel) // [FB] Check if an advanced game mode is active
			{
				int teamfactor;

				teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(Actor(botmo),
						Actor(player.Level.Game.Players[i].MO));
				// [FB] We've got a team factor, just check if it's an ally or not
				if (teamfactor != GameModel::teamfactor_any &&
					teamfactor != GameModel::teamfactor_enemy)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
				}
			}

			// [FB] Set an ally for team game modes
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
				}
			}
			else if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) // [FB] Set an ally if we're in a mode that has one
			{
				ally = Actor(player.Level.Game.Players[i].MO);
			}
		}
	}

	closest_dist = 99999.0;

	//Check for player friends
	for (j = 0; j < MAXPLAYERS; j++)
	{
		if ((player.Level.Game.Players[j]) && (botmo != player.Level.Game.Players[j].MO))
		{
			// [FB] Team game modes
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				if ((Player(player.Level.Game.Players[j]).Team == player.Team) &&
				    (player.Level.Game.Players[j].MO.Health <=
					Player(player.Level.Game.Players[j]).Bot.info.dangerlevel))
				{
					if (botmo.CanSee(player.Level.Game.Players[j].MO))
					{
						test = botmo.DistTo(player.Level.Game.Players[j].MO);

						if (test < closest_dist)
						{
							closest_dist = test;
							target = Actor(player.Level.Game.Players[j].MO);
							ally = target;
						}
					}
				}
			}
			else if(MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) // [FB] Other ally gameplay modes (no player colour checking)
			{
				if (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2)
				{
					if (botmo.CanSee(player.Level.Game.Players[j].MO))
					{
						test = botmo.DistTo(player.Level.Game.Players[j].MO);

						if (test < closest_dist)
						{
							closest_dist = test;
							target = Actor(player.Level.Game.Players[j].MO);
							ally = target;
						}
					}
				}
			}
		}
	}

	return ally;
}

//==========================================================================
//
//	Roam
//
//	Handle non-attack/dodging movement
//
//	[CW] TODO: must implement bKeepDistant!
//
//==========================================================================

void Roam(TVec dest)
{
	// [CW] let it be only for 2d first
	float yaw_delta = botmo.Angles.yaw - AngleTo(dest);
	float distance = fabs(Length(dest - botmo.Origin));

	if (bSoftContact || bMeleeUrge)
	{
		distance *= 100.0;	// to ensure bot will reach as quickly as possible
	}

	float fw_delta = distance * cos(yaw_delta);
	float side_delta = distance * sin(yaw_delta);
		
	if (fw_delta > 0.0)
		forwardmove = FORWARDRUN > fw_delta ? fw_delta : FORWARDRUN;
	else
		forwardmove = -FORWARDRUN < fw_delta ? fw_delta : -FORWARDRUN;
	if (side_delta > 0.0)
		sidemove = SIDERUN > side_delta ? side_delta : SIDERUN;
	else
		sidemove = -SIDERUN < side_delta ? side_delta : -SIDERUN;

	TVec short_dest = botmo.Origin;
	short_dest.x += forwardmove * cos(botmo.Angles.yaw) + sidemove * cos(botmo.Angles.yaw - 90.0);
	short_dest.y += forwardmove * sin(botmo.Angles.yaw) + sidemove * sin(botmo.Angles.yaw - 90.0);
	CheckPath(Length(short_dest - botmo.Origin), AngleTo(short_dest));
}

//==========================================================================
//
//	Move
//
//	Main bot movement function.
//	Dodging/attacking movement is also handled here
//
//==========================================================================

void Move(float deltaTime)
{
	TVec dest;

	// Worry about missiles above all else
	if (missile)
	{
		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				// Don't change direction while dodging missiles (that could be bad)
				//bot->sidemove = -bot->sidemove;
				t_strafe = 2.0;
			}
		}

		// Look at the missile and sidestep it
		SetAngle(AngleTo(missile.Origin));
		forwardmove = -FORWARDRUN;
		return;
	}

	// Anticipate a shot: time to dodge!
	if (enemy && t_anticip <= 0.25)
	{
		if (!sidemove)
			sidemove = SIDERUN;

		switch (info.anticip)
		{
		case bsk_verypoor:
			// Deer caught in the headlights
			sidemove = 0.0;
			return;

		case bsk_poor:
			// Always walk right
			sidemove = SIDEWALK;
			break;

		case bsk_low:
			// Always run right
			sidemove = SIDERUN;
			break;

		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe)
			{
				t_strafe -= deltaTime;
				if (t_strafe <= 0.0)
				{
					sidemove = -sidemove;
					t_strafe = 2.0;
				}
			}
			break;

		case bsk_high:
			// Switch directions when we think our opponent will fire
			if (!t_anticip)
				sidemove = -sidemove;
			break;

		case bsk_excellent:
			// Move in a somewhat random direction when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;

				if (Random() < 0.5)
				{
					forwardmove = -FORWARDWALK;
				}
			}
			break;

		case bsk_supreme:
			// What a squirmy little fucker!
			if (!t_anticip)
			{
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}
			break;

		default:
			Error("BotPlayer::Move::Unknown bot anticipation skill level: %d", info.anticip);
			return;
		}
	}

	// Now handle attack movement
	if (enemy)
	{
		float an;

		if (!sidemove)
			sidemove = SIDERUN;

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		an = GetAngle();//botmo.Angles.yaw;
		if (sidemove < 0.0)
			an -= 90.0;
		else
			an += 90.0;

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
		{
			an += (an > 180.0 ? -180.0 : 180.0);
			if (CheckPath(an, 48.0))
				sidemove = -sidemove;
			else
				sidemove = 0.0;
		}
//		return;
	}

	// [CW] Set a real destination for movement
	if (ITarget)
	{
		if (bAttackOffsetValid)
		{
			TAVec anglesFromOffset, anglesFromMO;
			TVec vOff = ITarget.Origin - AttackOffset;
			TVec vMO = ITarget.Origin - botmo.Origin;

			VectorAngles(&vOff, &anglesFromOffset);
			VectorAngles(&vMO, &anglesFromMO);
			
			// TODO: count accuracy level here maybe
			if (anglesFromMO.yaw >= anglesFromOffset.yaw - 15.0 &&
				anglesFromMO.yaw <= anglesFromOffset.yaw + 15.0)
			{
				dest = ITarget.Origin;
			}
			else
				dest = AttackOffset;
		}
		else
			dest = ITarget.Origin;
	}
	else
	{
//		dest = botmo.Origin;	// just hang on place where standing
		// do nothing?
		SetAngle(GetAngle() + 15.0);
		forwardmove = -FORWARDWALK;
		return;
	}

	if(CheckTo(dest))
		Roam(dest);
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack()
{
	// Still reacting to something or we don't have an enemy to fight
	if (t_react > 2.0 || !enemy)
		return;

	// [FB] Check if our allies are out of the way of the attack
	if (ally && Check_LOS(ally, SHOOTFOV))
		return;

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
		return;

/*	// [FB] We are still shooting
	if (t_fire)
		return;*/
	
	// [FB] Don't attack if the distance is not the right one for this weapon
	float combatdist = player.ReadyWeapon.BotCombatDist;
	if ((MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
		MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweepteam) &&
		combatdist > Actor::MELEERANGE)
	{
		combatdist /= 2.0;
	}
	if (botmo.DistTo(enemy) > combatdist)
		return;

	player.Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	React
//
//	[FB] Called when bot receives damage
//
//==========================================================================

void React(EntityEx inflictor)
{
	bAllRound = true;

	// [BC] 
	if (inflictor && inflictor != botmo && ally != inflictor)
	{
		if (!enemy)
		{
			enemy = Actor(inflictor);
//			t_react = player.DamageFlash + itof(info.reaction) * 2.0;
		}
		// [FB] Set reaction time
		switch (info.reaction)
		{
			case bsk_verypoor:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.6;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.6;
				}
				else
				{
					t_react = player.DamageFlash * 1.6;
				}
				break;
			case bsk_poor:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.5;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.5;
				}
				else
				{
					t_react = player.DamageFlash * 1.5;
				}
				break;
			case bsk_low:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.2;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.2;
				}
				else
				{
					t_react = player.DamageFlash * 1.2;
				}
				break;
			case bsk_medium:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.1;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.1;
				}
				else
				{
					t_react = player.DamageFlash * 1.1;
				}
				break;
			case bsk_high:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 1.0;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 1.0;
				}
				else
				{
					t_react = player.DamageFlash * 1.0;
				}
				break;
			case bsk_excellent:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 0.8;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 0.8;
				}
				else
				{
					t_react = player.DamageFlash * 0.8;
				}
				break;
			case bsk_supreme:
				if(player.PoisonCount)
				{
					t_react = itof(player.PoisonCount) * 0.6;
				}
				else if(player.BlindCount)
				{
					t_react = itof(player.BlindCount) * 0.6;
				}
				else
				{
					t_react = player.DamageFlash * 0.6;
				}
				break;
			default:
				Error("BotPlayer::React::Unknown bot reaction skill level: %d", info.reaction);
				return;
		}
	}
}

//==========================================================================
//
//	Alternate_Attack
//
//	[FB] Similar to Attack, but using alternate weapons
//
//==========================================================================

void Alternate_Attack()
{
	Ammo type;

	// Still reacting to something or we don't have an enemy to fight
	if (t_react > 2.0 || !enemy)
		return;

	ChooseAltWeapon(botmo.DistTo2(enemy));
	// [FB] We just simply check which weapon is active and do what it's needed for it to work
	switch (player.altWeapon)
	{
	case HexenDefs::ALTFIRE_BLASTRADIUS:
		type = Ammo(EntityEx(botmo).FindInventory(ArtifactBlastRadius));
		if (type && type.Amount > 10)
		{
			// [FB] Check if our allies are out of the way of the attack
			if (ally && Check_LOS(ally, 255.0))
				return;

			// No point in firing if we won't hit them
			if (!Check_LOS(enemy, 255.0))
				return;

			if (botmo.DistTo(enemy) > 255.0)
				return;

			// [FB] We've got enough ammo
			player.AlternateAttack();
		}
		break;
	case HexenDefs::ALTFIRE_POISONBAG:
		type = Ammo(EntityEx(botmo).FindInventory(ArtifactFlechette));
		if (type && type.Amount > 10)
		{
			// No point in firing if we won't hit them
			if (!Check_LOS(enemy, SHOOTFOV))
				return;

			// [FB] We've got enough ammo
			player.AlternateAttack();
		}
		break;
	}
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//
//==========================================================================

void Turn()
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

	if (!enemy)
	{
		player.ViewAngles.yaw = GetAngle();
		return;
	}

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			if (distance > 7.5)
				distance = 7.5;
			if (distance < -7.5)
				distance = -7.5;
			break;
		case bsk_medium:
			if (distance > 15.0)
				distance = 15.0;
			if (distance < -15.0)
				distance = -15.0;
			break;
		case bsk_high:
			if (distance > 22.5)
				distance = 22.5;
			if (distance < -22.5)
				distance = -22.5;
			break;
		case bsk_excellent:
			if (distance > 30.0)
				distance = 30.0;
			if (distance < -30.0)
				distance = -30.0;
			break;
		case bsk_supreme:
			if (distance > 37.5)
				distance = 37.5;
			if (distance < -37.5)
				distance = -37.5;
			break;
	}

	player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch()
{
	TVec dir;
	TAVec ang;

	// [FB] Set pitch for underwater areas
	if (player.MO.WaterLevel > 2)
	{
		if (enemy)
		{
			botmo.Angles.pitch = -AngleTo2(enemy.Origin);
			return;
		}

		// [FB] Follow our buddy if we're tagging along
		if (ally || (ally && !enemy))
		{
			botmo.Angles.pitch = -AngleTo2(ally.Origin);
			return;
		}
	}
	else
	{
		if (enemy)
		{
			botmo.Angles.pitch = AngleTo2(enemy.Origin);
			return;
		}
	}

	botmo.Angles.pitch = 0.0;
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(EntityEx victim)
{
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx killer)
{
	// [FB] Accumulate anger
	angerlevel += 10;

	if(angerlevel > info.threshold)
	{
		//[FB] There's a chance that we can get pissed off
		if(P_Random() < info.pisschance && !t_pissed)
		{
			//[FB] Now we are pissed off!
			//	this actor will temporarily become our main target now....
			nemesis = Actor(killer);
			//FIXME Determine which value would be the best here
			t_pissed = 120.0;
		}
		else if(t_pissed)
		{
			//[FB] Nope, we are now pissed and frustrated
			//FIXME Determine which value would be the best here
			t_frust = 120.0;
		}
		angerlevel = 0;
	}
}

//==========================================================================
//
//	BotSkill
//
//	[FB] Determine the bot skills depending the game skill
//
//==========================================================================

int BotSkill()
{
	if(player.Level.Game.gameskill == sk_nightmare)
	{
		return 4;
	}
	else if(player.Level.Game.gameskill == sk_hard)
	{
		return 3;
	}
	else if(player.Level.Game.gameskill == sk_medium)
	{
		return 2;
	}
	else if(player.Level.Game.gameskill == sk_easy)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay()
{
	int bottype;
	botinfo_t *binfo;
	int i;

	if (strcmp(player.PlayerName, ""))
	{
		for (i = 0; i < MainGameInfo::NUMTOTALBOTS; i++)
		{
			if (!stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % MainGameInfo::NUMBOTTYPES;
	}

	binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];
	t_strafe = 1.0;
	MainGameInfo(player.Level.Game).botskill = BotSkill();

	if (MainGameInfo(player.Level.Game).botskill > 4)
		MainGameInfo(player.Level.Game).botskill = 4;
	if (MainGameInfo(player.Level.Game).botskill < 0)
		MainGameInfo(player.Level.Game).botskill = 0;

	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - MainGameInfo(player.Level.Game).botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - MainGameInfo(player.Level.Game).botskill);
	info.evade = SkillLower(binfo->evade, 4 - MainGameInfo(player.Level.Game).botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - MainGameInfo(player.Level.Game).botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - MainGameInfo(player.Level.Game).botskill);
	player.UserInfo = binfo->userinfo;
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn()
{
	botstate.BState = bst_deciding;
	enemy = none;
	accuracy_r = false;
	intelect_r = false;
	evade_r = false;
	anticip_r = false;
	p_init = false;
}

//==========================================================================
//
//	AffectStat
//
//  [FB] Check if we are blind by darkness!!
//
//==========================================================================

void AffectStat()
{
	if (!accuracy_r)
	{
		old_accuracy = info.accuracy;
		accuracy_r = true;
	}
	if (!intelect_r)
	{
		old_intelect = info.intelect;
		intelect_r = true;
	}
	if (!evade_r)
	{
		old_evade = info.evade;
		evade_r = true;
	}
	if (!anticip_r)
	{
		old_anticip = info.anticip;
		anticip_r = true;
	}
	if (accuracy_r && player.BlindCount <= 50)
	{
		if (info.accuracy)
			info.accuracy--;
		// [FB] Make sure this stat isn't less than zero
		else if (info.accuracy <= bsk_verypoor)
			info.accuracy = bsk_verypoor;
	}
	else if (intelect_r && (player.BlindCount > 50 && player.BlindCount <= 100))
	{
		if (info.intelect)
			info.intelect--;
		else if (info.intelect <= bsk_verypoor)
			info.intelect = bsk_verypoor;
	}
	else if (evade_r && (player.BlindCount > 100 && player.BlindCount <= 150))
	{
		if (info.evade)
			info.evade--;
		else if (info.evade <= bsk_verypoor)
			info.evade = bsk_verypoor;
	}
	else if (anticip_r && (player.BlindCount > 150 && player.BlindCount <= 200))
	{
		if (info.anticip)
			info.anticip--;
		else if (info.anticip <= bsk_verypoor)
			info.anticip = bsk_verypoor;
	}
}

//==========================================================================
//
//	SetPissedStats
//
//  [FB] We are pissed off, so certain stats are boosted
//
//==========================================================================

void SetPissedStats()
{
	if (!p_init)
	{
		n_accuracy = info.accuracy;
		n_evade = info.evade;
		n_anticip = info.anticip;
	}
	info.accuracy++;
	info.evade++;
	info.anticip++;

	// [FB] Make sure stats don't go beyond
	if (info.accuracy > bsk_supreme)
		info.accuracy = bsk_supreme;
	else if (info.evade > bsk_supreme)
		info.evade = bsk_supreme;
	else if (info.anticip > bsk_supreme)
		info.anticip = bsk_supreme;
}

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//	[CW] Enhanced version since 2007/12/12.
//
//==========================================================================

void BotTick(float deltaTime)
{
	// ---------------------------
	// Initialization
	// ---------------------------
	gameInfo = MainGameInfo(player.Level.Game);
	botmo = KArenaPlayerPawn(player.MO);

	player.ForwardMove = 0.0;
	player.SideMove = 0.0;
	player.FlyMove = 0.0;
	player.Buttons = 0;

	// Weed out any bad destinations/enemies
	CheckStuff();

	// ---------------------------
	// Chat
	// ---------------------------
	// Don't do anything if we're talking
	//	if (B_Chat())
	//		return;

	// ---------------------------
	// Death
	// ---------------------------
	if (player.PlayerState == PST_DEAD)
	{
		if (player.respawn_counter <= 0.0)
		{
			player.Buttons |= BT_USE;
		}
		return;
	}

	// ---------------------------
	// Timed effects
	// ---------------------------
	UpdateTimedEffects(deltaTime);

	// ---------------------------
	// General DECIDE
	// ---------------------------
	// [CW] I propose using AI_TIME_DELAY for this stuff thus giving some free time to engine
	AITime -= deltaTime;
	if (AITime <= 0.0)
	{
		AITime = AI_TIME_DELAY + (Random() - 0.5) * 2.5;

		// [FB] Decide what action we'll take
		SetAction();

		// [FB] Set an ally if we're in a mode that has one
		if (!ally && (gameInfo.bIsCoopGame[gameInfo.GameType] ||
				// [CW] this may change by time in some game modes
				gameInfo.GameModel && gameInfo.GameModel.AllowAllies()))
			ally = SetAlly();
		else
			ally = none;

		ProcessPriorities();
	}

	ProcessImmediate();

	//
	// [CW] assuming we have have what to do, or decided just to roam around
	// ---------------------------
	// Immediate action
	// ---------------------------
	
	// Turning towards destination...
	Aim();
	Turn();
	Attack();
	Alternate_Attack();
	Move(deltaTime);

	// Only walk if we're on skill 0
	if (!gameInfo.botskill || player.Level.Game.gameskill == sk_baby)
	{
		if (forwardmove > FORWARDWALK)
			forwardmove = FORWARDWALK;
		if (forwardmove < -FORWARDWALK)
			forwardmove = -FORWARDWALK;
		if (sidemove > SIDEWALK)
			sidemove = SIDEWALK;
		if (sidemove < -SIDEWALK)
			sidemove = -SIDEWALK;
	}

	player.SideMove = sidemove;
	player.ForwardMove = forwardmove;
}

//==========================================================================
//
//	UpdateTimedEffects
//
//==========================================================================

void UpdateTimedEffects(float deltaTime)
{
	// [FB] Apply blind status
	if(player.BlindCount)
		AffectStat();
	else if (player.BlindCount <= 0)
	{
		//[FB] Darkness effects faded out, now restore everything back!
		if (anticip_r)
		{
			info.anticip = old_anticip;
			anticip_r = false;
		}
		if (evade_r)
		{
			info.evade = old_evade;
			evade_r = false;
		}
		if (intelect_r)
		{
			info.intelect = old_intelect;
			intelect_r = false;
		}
		if (accuracy_r)
		{
			info.accuracy = old_accuracy;
			accuracy_r = false;
		}
	}

	// Periodically let out some anger
	if (!(player.Level.XLevel.Time == 255.0))	// [CW] seriously,.. what the # is this 255.0?
	{
		if (angerlevel)
			angerlevel--;
		else if (angerlevel <= 0)
			angerlevel = 0;
	}

	//--------------------------------------------------------
	//--------------------------------------------------------

	t_react -= deltaTime;
	if (t_react <= 0.0)
		t_react = 0.0;

	t_anticip -= deltaTime;
	if (t_anticip <= 0.0)
		t_anticip = 0.0;

/*	t_fight -= deltaTime;
	if (t_fight <= 0.0)
		t_fight = 0.0;

	t_rocket -= deltaTime;
	if (t_rocket <= 0.0)
		t_rocket = 0.0;*/

	t_turn -= deltaTime;
	if (t_turn <= 0.0)
		t_turn = 0.0;

	t_pissed -= deltaTime;
	if (t_pissed <= 0.0)
	{
		t_pissed = 0.0;

		//[FB] Stop chasing our main target
		if(nemesis)
			nemesis = none;

		//[FB] Return stats to their original
		if(p_init)
		{
			info.accuracy = n_accuracy;
			info.evade = n_evade;
			info.anticip = n_anticip;
			p_init = false;
		}
	}

	t_frust -=deltaTime;
	if (t_frust <= 0.0)
		t_frust = 0.0;

	t_fire -= deltaTime;
	if (t_fire <= 0.0)
		t_fire = 0.0;

	// [FB] Apply pissed off stats
	if (t_pissed && !p_init)
	{
		SetPissedStats();
	}
}

//==========================================================================
//
//	ProcessPriorities
//
//==========================================================================

void ProcessPriorities()
{
	int i,j;
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		Priority[i] = 0;
	}

	// [CW] Long way deciding priorities...

	//----------------------------------------
	// Weaponry
	//----------------------------------------
	Weapon wpn = Player(self.player).BestWeapon();
	int my_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
	int heaviest_weapon = GetHeaviestEnemyWeapon();
	int opponent_weapon = 0;
	int opponent_weapon_current = 0;
	if (enemy && enemy.Player)
	{
		wpn = Player(enemy.Player).BestWeapon();
		opponent_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
		opponent_weapon_current = KArenaWeapon(Player(enemy.Player).ReadyWeapon).Slot;
	}

	// Has only 2nd level weapon
	if (my_weapon <= 1)
		Priority[priort_Weapons] += priorv_Weapons_BadEquipment;
	if (my_weapon < heaviest_weapon)
		Priority[priort_Weapons] += priorv_Weapons_HeavyEnemies;
	if (my_weapon < opponent_weapon)
		Priority[priort_Weapons] += priorv_Weapons_HeavyOpponent;
	if (my_weapon < opponent_weapon_current)
		Priority[priort_Weapons] += priorv_Weapons_HeavyOffence;
	if (my_weapon < 7)
		Priority[priort_Weapons] += priorv_Weapons_NotTheBest;

	//----------------------------------------
	// Ammo
	//----------------------------------------

	//
	// [CW] This works a bit different thus not to repeat Inventory searches
	//
	if (player.IsOutOfAmmo())
	{
		Priority[priort_Ammo] += priorv_Ammo_Null;
		Priority[priort_Ammo] += priorv_Ammo_Low;
		Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
		Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
	}
	else
	{
		if (player.IsAmmoBelowLevel( 50 ))
		{
			Priority[priort_Ammo] += priorv_Ammo_Low;
			Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
			Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
		}
		else if (player.IsAmmoBelowLevel( 50 , class<KArenaWeapon>(player.ReadyWeapon.Class) ) ||
				player.ReadyWeapon.CheckAmmo(player.ReadyWeapon.FireMode, false, true))
		{
			Priority[priort_Ammo] += priorv_Ammo_ThisWeaponLow;
			Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
		}
		else
		{
			if (player.IsAmmoBelowLevel( 200 , none, Mana1 ) ||
					player.IsAmmoBelowLevel( 200 , none, Mana2) ||
					player.IsAmmoBelowLevel( 200 , none, ItemManaRed ) )
				Priority[priort_Ammo] += priorv_Ammo_NotMaximum;
		}
	}
	
	//----------------------------------------
	// Health & Armor
	//----------------------------------------

	if (EntityEx(player.MO).CheckInventory('Health') <= 15)
		Priority[priort_Health] += priorv_Health_Dying;
	if (EntityEx(player.MO).CheckInventory('Health') <= (player.max_health >> 1))
		Priority[priort_Health] += priorv_Health_Low;
	if (EntityEx(player.MO).CheckInventory('Health') < player.max_health)
		Priority[priort_Health] += priorv_Health_NotMaximum;
	else if (EntityEx(player.MO).CheckInventory('Armor') <= 200)
		Priority[priort_Health] += priorv_Health_ArmorNotMaximum;

	//----------------------------------------
	// Game Mode
	//----------------------------------------
	if (gameInfo.GameType < HexenDefs::NUMGAMESNOTEAM)
	{
		int plInPlay = gameInfo.GetPlayerCount();
		if (player.PlayerPosition > 0)
			Priority[priort_GameMode] += priorv_GameMode_NotFirst;
		if (player.PlayerPosition == plInPlay - 1)
			Priority[priort_GameMode] += priorv_GameMode_Last;
		else if (player.PlayerPosition > 1)
			Priority[priort_GameMode] += priorv_GameMode_Loosing;

		if (!player.Score)
			Priority[priort_GameMode] += priorv_GameMode_NoScore;
	}
	else if (gameInfo.GameType >= HexenDefs::NUMGAMESNOTEAM && player.Team)
	{
		int tmInPlay = gameInfo.GetTeamCount();
		if (player.Team.Position > 0)
			Priority[priort_GameMode] += priorv_GameMode_NotFirst;
		if (player.Team.Position == tmInPlay - 1)
			Priority[priort_GameMode] += priorv_GameMode_Last;
		else if (player.Team.Position > 1)
			Priority[priort_GameMode] += priorv_GameMode_Loosing;

		if (!player.Team.Score)
			Priority[priort_GameMode] += priorv_GameMode_NoScore;
	}

	if (GetGameModeGoal(false))
		Priority[priort_GameMode] += priorv_GameMode_Normal;

	int prior_max;
	int prior_limit = -1;

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		Prior_Targets[i] = 0;
	}

	// [CW] sort prioritised targets
	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		prior_max = -1;
		for (j = 0; j < NUM_PRIORITIES; j++)
		{
			if (prior_limit >= 0 && Priority[j] >= prior_limit)
			{
				continue;
			}
			if (Priority[j] > prior_max ||
					Priority[j] == prior_max && P_Random() > 127)
			{
				Prior_Targets[i] = j;
				prior_max = Priority[j];
			}
		}

		prior_limit = Priority[Prior_Targets[i]];
	}

	ITarget = none;
}

//==========================================================================
//
//	GetHeaviestEnemyWeapon
//
//==========================================================================

int GetHeaviestEnemyWeapon()
{
	int i;
	Weapon wpn;
	int pl_weapon;
	int weapon = 0;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (gameInfo.Players[i]	&& gameInfo.Players[i] != player &&
			Actor(gameInfo.Players[i].MO) == enemy)
		{
			wpn = Player(gameInfo.Players[i]).BestWeapon();
			pl_weapon = wpn ? KArenaWeapon(wpn).Slot : 0;
			if (pl_weapon > weapon)
				weapon = pl_weapon;
		}
	}

	return weapon;
}

//==========================================================================
//
//	GetFirstPriorityTarget
//
//	[CW] Handles Bot hunt for Inventory items
//
//==========================================================================

Actor GetFirstPriorityTarget()
{
	Actor ee;
	Actor candidates[NUM_PRIORITIES];
	float dist[NUM_PRIORITIES];

	int i, priort;
	for (i = 0; i < NUM_PRIORITIES; i++)
		dist[i] = -1.0;

	candidates[priort_GameMode] = GetGameModeGoal(true);

	foreach botmo.AllThinkers(Actor, ee)
	{
		if (ee.bInvisible)
			continue;
		if (ee.bNoSector)
			continue;

		if (ee.IsA('Weapon'))
			priort = priort_Weapons;
		else if (ee.IsA('Ammo'))
			priort = priort_Ammo;
		else if (ee.IsA('Health') || ee.IsA('Armor'))
			priort = priort_Health;
		else if (ee.IsA('Arifact'))
			priort = priort_Artifacts;
		else
			continue;

		if (!Priority[priort])
			continue;

		if (dist[priort] < 0.0 || Length(ee.Origin - botmo.Origin) < dist[priort])
		{
			if (botmo.CanSee(ee) && CheckTo(ee.Origin, ee))
			{
				candidates[priort] = ee;
				dist[priort] = Length(ee.Origin - botmo.Origin);
			}
		}
	}

	for (i = 0; i < NUM_PRIORITIES; i++)
	{
		if (!Priority[Prior_Targets[i]])
			break;
		if (candidates[Prior_Targets[i]])
		{
			return candidates[Prior_Targets[i]];
		}
	}

	return none;
}

//==========================================================================
//
//	ProcessImmediate
//
//==========================================================================

void ProcessImmediate()
{
	// Whatever bot is doing, he should be ready to attack an enemy
	// TODO: if bot has high Evade priority he should not draw attention to himself...
	
	if (!missile)
		missile = FindMissile();

	if (!enemy)
		enemy = FindEnemy();

	if (!ITarget)
	{
		ITarget = GetFirstPriorityTarget();

		if (!ITarget)
		{
			// [FB] Determine our state (offense, defense) to make us search for specific path nodes
			if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_ctf)
			{
				switch(botstate.BState)
				{
					case bst_offense:
					{
						if (MainGameInfo(player.Level.Game).Teams[0] == player.Team)
							ITarget = GetNearestPathNode(class<Thinker>(BlueNode));
						else
							ITarget = GetNearestPathNode(class<Thinker>(RedNode));
					}
					break;
					case bst_defense:
					{
						if (MainGameInfo(player.Level.Game).Teams[0] == player.Team)
							ITarget = GetNearestPathNode(class<Thinker>(BlueGuardSpot));
						else
							ITarget = GetNearestPathNode(class<Thinker>(RedGuardSpot));
					}
					break;
					case bst_scoring:
					{
						if (MainGameInfo(player.Level.Game).Teams[0] == player.Team)
							ITarget = GetNearestPathNode(class<Thinker>(BlueGoalSpot));
						else
							ITarget = GetNearestPathNode(class<Thinker>(RedGoalSpot));
					}
					break;
				}
			}
			else
				ITarget = GetNearestPathNode(class<Thinker>(PathNode));
		}

		if (!ITarget && enemy && CheckTo(enemy.Origin, enemy))
		{
			ITarget = enemy;
		}
	}

	if (ITarget)
		print("BOT %s : my target is %n", player.PlayerName, GetClassName(ITarget.Class));

	bSoftContact = false;
	bMeleeUrge = false;
	bKeepDistant = false;

	if (ITarget)
	{
		bSoftContact =	bAttackOffsetValid ||
						(!ITarget.IsA('Pawn') && !ITarget.bSolid) ||
						ITarget.IsA('SoccerBall');
	}

	if (enemy)
	{
		bMeleeUrge = KArenaWeapon(player.ReadyWeapon).bBotChooseMelee && enemy.Player &&
			!KArenaWeapon(Player(enemy.Player).ReadyWeapon).bBotChooseMelee;
		bKeepDistant = !bMeleeUrge && !KArenaWeapon(player.ReadyWeapon).bBotChooseMelee;
	}
}

//==========================================================================
//
//	GetNearestEnemy
//
//==========================================================================

Actor GetNearestEnemy(optional bool bReachable)
{
	Actor oldEnemy = enemy;
	FindEnemy();
	if (!enemy)
		enemy = GetSpecialEnemy();
	if (!enemy && oldEnemy)
		enemy = oldEnemy;
	return enemy;
}

//==========================================================================
//
//	GetSpecialEnemy
//
//==========================================================================

Actor GetSpecialEnemy()
{
	switch (gameInfo.GameType)
	{
	case HexenDefs::game_xmas:
		return Actor(botmo.A_GetNearestEntity(ZXmasHavocTree));
	}
	return none;
}

//==========================================================================
//
//	GetGameModeGoal
//
//==========================================================================

Actor GetGameModeGoal(optional bool bReachable)
{
	Actor EE;
	Actor ee;
	float dist = -1.0;

	switch (gameInfo.GameType)
	{
	case HexenDefs::game_kth:
		{
			if (GameKTH(gameInfo.GameModel).State == GameKTH::state_heresiarch)
			{
				if (GameKTH(gameInfo.GameModel).plHeresiarch != player)
					EE = Actor(GameKTH(gameInfo.GameModel).plHeresiarch.MO);
				else
					EE = GetNearestEnemy(true);
			}
			else if (GameKTH(gameInfo.GameModel).State == GameKTH::state_freeramble)
				EE = GetNearestEnemy(true);
		}
		break;
	case HexenDefs::game_ctf:
		{
			// [FB] Get our state and set our actions based on this...
			switch (botstate.BState)
			{
				case bst_offense:
				{
					foreach botmo.AllThinkers(CTFBanner, ee)
					{
						// [FB] Check status of enemy flag
						if (CTFBanner(ee).Team != player.Team)
						{
							if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE ||
								CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST)
							{
								if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
								{
									if (!bReachable || CheckTo(ee.Origin, ee))
									{
										EE = ee;
										dist = Length(botmo.Origin - ee.Origin);
									}
								}
							}
							else if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__CARRIED)
							{
									// [FB] Flag is carried, check if we are carrying it
									if (CTFBanner(ee).Capturer == player)
										// [FB] We are carrying, set our state to scoring to change our goal
										botstate.BState = bst_scoring;
									else
										// [FB] Just support our team....
										EE = GetNearestEnemy(true);
							}
						}
					}
				}
				break;
				case bst_defense:
				{
					foreach botmo.AllThinkers(CTFBanner, ee)
					{
						// [FB] Check status of our flag
						if (CTFBanner(ee).Team == player.Team)
						{
							if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE)
								EE = GetNearestEnemy(true);
							else if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__CARRIED)
								EE = Actor(CTFBanner(ee).Capturer);
							else if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST)
							{
								if ((dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
								{
									if (!bReachable || CheckTo(ee.Origin, ee))
									{
										EE = ee;
										dist = Length(botmo.Origin - ee.Origin);
									}
								}
							}
						}
					}
				}
				break;
				case bst_scoring:
				{
					foreach botmo.AllThinkers(CTFBanner, ee)
					{
						// [FB] Check status of our flag
						if (CTFBanner(ee).Team == player.Team)
						{
							if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__BASE ||
								CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__LOST)
							{
								if (dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist)
								{
									if (!bReachable || CheckTo(ee.Origin, ee))
									{
										EE = ee;
										dist = Length(botmo.Origin - ee.Origin);
									}
								}
							}
							else if (CTFBanner(ee).Status == CTFBanner::BANNER_STATUS__CARRIED)
								EE = Actor(CTFBanner(ee).Capturer);
						}
					}
				}
				break;
			}
		}
	break;
	case HexenDefs::game_domination:
		{
			foreach botmo.AllThinkers(DominationSigil, ee)
			{
				if (DominationSigil(ee).Team != player.Team &&
					(dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
				{
					if (!bReachable || CheckTo(ee.Origin, ee))
					{
						EE = ee;
						dist = Length(botmo.Origin - ee.Origin);
					}
				}
			}
		}
		break;
	case HexenDefs::game_football:
		{
			// Get ball
			EE = Actor(botmo.A_GetNearestEntity(SoccerBall));

			bAttackOffsetValid = false;

			// [CW] set a target offset
			if (EE)
			{
				int i, team;
				Actor sts;
				GameFootball fb = GameFootball(gameInfo.GameModel);
				if (gameInfo.Teams[0] == player.Team)
					team = 1;
				else
					team = 0;

				// Get nearest goal target
				for (i = 0; i < fb.spot_targets.Num; i++)
				{
					if (fb.spot_targets[i].Args[0] != team)
						continue;
					ee = fb.spot_targets[i];
					if ((dist < 0.0 || Length(botmo.Origin - ee.Origin) < dist))
					{
						if (!bReachable || CheckTo(ee.Origin, ee))
						{
							sts = ee;
							dist = Length(botmo.Origin - ee.Origin);
						}
					}
				}

				if (sts)
				{
					AttackOffset = (Normalise(EE.Origin - sts.Origin) * (botmo.Radius * 2.0)) + EE.Origin;
					bAttackOffsetValid = true;
				}
			}
		}
		break;
	default:
		EE = GetNearestEnemy(true);
	}

	return EE;
}

//==========================================================================
//
//	GetNearestPathNode
//
//==========================================================================

Actor GetNearestPathNode(class<Thinker> NodeType)
{
	PathNode PN;
	PathNode pn;
	float dist = -1.0;

	bool visited;
	int i;

	PathNode previous;

	// TODO: make DEQUEUE instead of this bullshit
	if (nodes.Num > 32)
		nodes.Num = 0;
	if (nodes.Num)
		previous = nodes[nodes.Num - 1];

	foreach botmo.AllThinkers(NodeType, pn)
	{
		if (pn == node_current)
			continue;

		visited = false;
		for (i = 0; i < nodes.Num; i++)
		{
			if (nodes[i] == pn)
			{
				visited = true;
				break;
			}
		}

		if (visited)
			continue;

		if (dist < 0.0 || Length(pn.Origin - botmo.Origin) < dist)
		{
			if (CheckTo(pn.Origin))
			{
				PN = pn;
				dist = Length(pn.Origin - botmo.Origin);
			}
		}
	}

	if (PN)
	{
		if (node_current)
		{
			nodes.Num = nodes.Num + 1;
			nodes[nodes.Num - 1] = node_current;
		}
		node_current = PN;
	}
	else
	{
		if (node_current)
		{
			nodes.Num = 1;
			nodes[0] = node_current;
		}
		else
			nodes.Num = 0;
		node_current = previous;
	}
	return node_current;
}

defaultproperties
{
}
