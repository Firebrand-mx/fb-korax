//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: GameCTF.vc 508 2006-07-10 19:02:43Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class GameCTF : GameModel;

const int	MAXBANNERS	= 2;
const int	MINREQUIREDBANNERS = 2;	// ...how formal...

enum
{
	state_preparegame,
	state_gameplay,		// no actual game states here
	state_finished
};


array<CTFBanner>	Banners;
array<CTFBase>		spot_banners;	// Bases are all created during initialization
//array<bool>		bBannersCreated;
//array<bool>		bSpotBannersCreated;


//==========================================================================
//
//	AllowedTeams
//
//==========================================================================

int AllowedTeams()
{
	return 2;
}

//==========================================================================
//
//	BeginState
//
//	ACS callable
//
//==========================================================================

void BeginState(int newstate)
{
	int i, count1, count2;

	dprint("BeginState: %i", newstate);

	switch(newstate)
	{
	case state_preparegame:
		if (!PrepareGame())
		{
			dprint("GameCTF : failed to prepare game, delay start");
			State = -1;
			return;
		}

		dprint("GameCTF : starting game!");
		
		HandleEvent(event_playablestatebegins, none, 0,0,0,0);
		
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Teams[0] && Game.Teams[0].Players[i])
			   Game.Teams[0].Players[i].UpdateScore(HexenDefs::scoreevent_PlayerReset);
			if (Game.Teams[1] && Game.Teams[1].Players[i])
			   Game.Teams[1].Players[i].UpdateScore(HexenDefs::scoreevent_PlayerReset);
		}
		if (Game.Teams[0])
			Game.Teams[0].UpdateScore(HexenDefs::scoreevent_TeamReset);
		if (Game.Teams[1])
			Game.Teams[1].UpdateScore(HexenDefs::scoreevent_TeamReset);
		EndCurrentState(state_gameplay);
		return;

	case state_gameplay:
		if (!Game.Teams[0] || !Game.Teams[1])
		{
			dprint("GameCTF::BeginState : state_gameplay : not enough teams, ending game");
			EndCurrentState(state_finished);
			return;
		}
		count1 = 0;
		for (i = 0; i < spot_banners.Num; i++)
		{
			if (spot_banners[i])
				count1++;
		}
		count2 = 0;
		for (i = 0; i < Banners.Num; i++)
		{
			if (Banners[i])
				count2++;
		}
		
		if (count1 < MINREQUIREDBANNERS || count2 < MINREQUIREDBANNERS)
		{
			dprint("GameCTF::BeginState : state_gameplay : not enough banners and/or spot_banners, ending game");
			EndCurrentState(state_finished);
			return;
		}

		for (i = 0; i < Banners.Num; i++)
		{
			if (Banners[i])
				Banners[i].ReturnToBase(none, true);
		}
		Game.bcentreprint("go for it!");
		break;

	case state_finished:
		//
		// do something here?
		//
		break;
	};

	State = newstate;
}

//==========================================================================
//
//	IsInPlayableState
//
//==========================================================================

bool IsInPlayableState()
{
	return (State >= 0 && State == state_gameplay);
}

//==========================================================================
//
//	NotifyUpdateTeams
//
//	TODO: handle delayed banners
//
//==========================================================================

void NotifyUpdateTeams()
{
	dprint("GameCTF::NotifyUpdateTeams : State = %i, Teams[0] = %i, Teams[1] = %i", State, Game.Teams[0], Game.Teams[1]);
	if (!IsInPlayableState() && (Game.Teams[0] && Game.Teams[1]))
		BeginState(state_preparegame);
	else if (IsInPlayableState() && (!Game.Teams[0] || !Game.Teams[1]))
		EndCurrentState(state_finished);
}

//==========================================================================
//
//	NotifyPlayerDeath
//
//==========================================================================

void NotifyPlayerDeath(Player pl, EntityEx source)
{
	int i;
	for (i = 0; i < MAXBANNERS; i++)
	{
		if (Banners[i] && Banners[i].Capturer && Banners[i].Capturer == pl)
		{
			Banners[i].WasLost();
			break;
		}
	}
}

//==========================================================================
//
//	EndCurrentState
//
//	ACS callable
//
//==========================================================================

void EndCurrentState(int nextstate)
{
	if (nextstate == state_finished)
	{
		int i;
		for (i = 0; i < MAXBANNERS; i++)
		{
			if (Banners[i] && Banners[i].Capturer)
			{
				Banners[i].WasLost();
				break;
			}
		}
		Cleanup();
	}

	BeginState(nextstate);
}

//==========================================================================
//
//	Cleanup
//
//==========================================================================

void Cleanup()
{
	int i;
	/* for (i = 0; i < Banners.Num; i++)
	{
		if (bBannersCreated[i])
		{
			Banners[i].Destroy();
			bBannersCreated[i] = false;
		}
		Banners[i] = none;
	}*/

	for (i = 0; i < spot_banners.Num; i++)
	{
	//	if (bSpotBannersCreated[i])
		{
			spot_banners[i].Destroy();
	//		bSpotBannersCreated[i] = false;
		}
		spot_banners[i] = none;
	}
}

//==========================================================================
//
//	PrepareGame
//
//==========================================================================

bool PrepareGame()
{
	int i /* ,j*/, teams, teams_ready;
	int pairs;

	if (!Game.Teams[0] || !Game.Teams[1])
	{
		dprint("GameCTF : not enough teams");
		return false;
	}

	Cleanup();

	teams = AllowedTeams();
	teams_ready = Game.GetTeamCount();

	dprint("GameCTF : prepare game; allowed %i teams, present %i teams", teams, teams_ready);

	pairs = 0;

	CTFBanner banner;
	CTFBase base;

	foreach Level.AllThinkers(CTFBanner, banner)
	{
		if (banner.Args[0] >= teams)
		{
			dprint("GameCTF : initial banner (%i/%i) belongs to unsupported Team and will be disabled",
				banner.Args[0], banner.Args[1]);
			banner.Deactivate(none);
			continue;
		}

		Banners.Num = Banners.Num + 1;
		Banners[Banners.Num - 1] = banner;
		if (Banners.Num == MAXBANNERS)
			break;
	}

	//bBannersCreated.Num = Banners.Num;

	/* foreach Level.AllThinkers(CTFBase, base)
	{
		if (base.Args[0] >= teams)
		{
			dprint("GameCTF : initial base (%i/%i) belongs to unsupported Team and will be disabled",
				base.Args[0], base.Args[1]);
			base.Deactivate(none);
			continue;
		}

		spot_banners.Num = spot_banners.Num + 1;
		spot_banners[spot_banners.Num - 1] = base;
		if (spot_banners.Num == MAXBANNERS)
			break;
	}

	bSpotBannersCreated.Num = spot_banners.Num;*/

	//dprint("GameCTF : found %i active banners and %i active bases", Banners.Num, spot_banners.Num);
	dprint("GameCTF : found %i active banners", Banners.Num);


	for (i = 0; i < Banners.Num; i++)
	{
		/* for (j = 0; j < spot_banners.Num; j++)
		{
			if (Banners[i].Args[0] ==  spot_banners[j].Args[0] &&
				Banners[i].Args[1] ==  spot_banners[j].Args[1])
			{
				pairs++;
				Banners[i].BaseOrigin = spot_banners[j];
				spot_banners[j].Banner = Banners[i];
				if (Banners[i].Args[0] < teams_ready)
				{
					Banners[i].Team = Game.Teams[Banners[i].Args[0]];
					spot_banners[j].Team = Game.Teams[spot_banners[j].Args[0]];
					Banners[i].SetTranslation();
				}
				else
				{
					dprint("GameCTF : initial banner and base (%i/%i) belong to inactive Team and will be disabled until Team %i enters to the game",
						Banners[i].Args[0], Banners[i].Args[1], Banners[i].Args[0]);
					Banners[i].Deactivate(none);
					spot_banners[j].Deactivate(none);
				}
				break;
			}
		}*/

		//if (!Banners[i].BaseOrigin)
		//{
			//j = spot_banners.Num;
			spot_banners.Num = spot_banners.Num + 1;
			//bSpotBannersCreated.Num = bSpotBannersCreated.Num + 1;
			spot_banners[/*j*/i] = HexenLevelInfo(Level).Spawn(CTFBase, Banners[i].Origin);
			if (spot_banners[/*j*/i])
			{
				dprint("GameCTF : successfully spawned CTFBase at initial banner (%i/%i) position", 
					Banners[i].Args[0], Banners[i].Args[1]);
				pairs++;
				//bSpotBannersCreated[j] = true;
				Banners[i].BaseOrigin = spot_banners[/* j*/i];
				spot_banners[/* j*/i].Banner = Banners[i];
				spot_banners[/* j*/i].Args[0] = Banners[i].Args[0];
				spot_banners[/* j*/i].Args[1] = Banners[i].Args[1];
				if (Banners[i].Args[0] < teams_ready)
				{
					Banners[i].Team = Game.Teams[Banners[i].Args[0]];
					spot_banners[/* j*/i].Team = Game.Teams[spot_banners[/* j*/i].Args[0]];
					Banners[i].SetTranslation();
					// [FB] This is important for bots AI
					Banners[i].Status = CTFBanner::BANNER_STATUS__BASE;
				}
				else
				{
					dprint("GameCTF : banner and base (%i/%i) belong to inactive Team and will be disabled until Team %i enters to the game",
						Banners[i].Args[0], Banners[i].Args[1], Banners[i].Args[0]);
					Banners[i].Deactivate(none);
					spot_banners[/* j*/i].Deactivate(none);
				}
			}
			else
			{
				dprint("GameCTF : failed to spawn CTFBase at initial banner (%i/%i) position; banner (%i/%i) will be disabled",
					Banners[i].Args[0], Banners[i].Args[1], Banners[i].Args[0], Banners[i].Args[1]);
				Banners[i].Deactivate(none);
				//spot_banners.Num = spot_banners.Num - 1;
			}
		//}
	}

	/* for (i = 0; i < spot_banners.Num; i++)
	{
		if (!spot_banners[i].Banner)
		{
			j = Banners.Num;
			Banners.Num = Banners.Num + 1;
			bBannersCreated.Num = bBannersCreated.Num + 1;
			Banners[j] = HexenLevelInfo(Level).Spawn(CTFBanner, spot_banners[i].Origin);
			if (Banners[j])
			{
				dprint("GameCTF : successfully spawned CTFBanner at initial base (%i/%i) position",
					spot_banners[i].Args[0], spot_banners[i].Args[1]);
				pairs++;
				bBannersCreated[j] = true;
				Banners[j].BaseOrigin = spot_banners[i];
				spot_banners[i].Banner = Banners[j];
				Banners[i].Args[0] = spot_banners[j].Args[0];
				Banners[i].Args[1] = spot_banners[j].Args[1];
				if (Banners[j].Args[0] < teams_ready)
				{
					Banners[j].Team = Game.Teams[Banners[j].Args[0]];
					spot_banners[i].Team = Game.Teams[spot_banners[i].Args[0]];
					Banners[i].SetTranslation();
				}
				else
				{
					dprint("GameCTF : banner and base (%i/%i) belong to inactive Team and will be disabled until Team %i enters to the game",
						spot_banners[i].Args[0], spot_banners[i].Args[1], spot_banners[i].Args[0]);
					Banners[j].Deactivate(none);
					spot_banners[i].Deactivate(none);
				}
			}
			else
			{
				dprint("GameCTF : failed to spawn CTFBanner at initial base (%i/%i) position; base (%i/%i) will be disabled",
					spot_banners[i].Args[0], spot_banners[i].Args[1], spot_banners[i].Args[0], spot_banners[i].Args[1]);
				spot_banners[i].Deactivate(none);
				Banners.Num = Banners.Num - 1;
			}
		}
	}*/

	if (pairs < MINREQUIREDBANNERS)
	{
		dprint("GameCTF : not enough banners and/or bases, need %i pairs, got %i pairs", MINREQUIREDBANNERS, pairs);
		return false;
	}

	dprint("GameCTF : game prepared with %i active banner/base pairs", pairs);

	return true;
}

//==========================================================================
//
//	CommitCapture
//
//	[CW] Called for banner that was captured and brought to opponent's base.
//
//==========================================================================

void CommitCapture(CTFBanner Banner)
{
	// TADA!!
	// play some sound here
	Game.BroadcastLocalSound((P_Random() > 127 ? (P_Random() > 127 ?
			HexenDefs::lsid_ctf_fanfare1 : HexenDefs::lsid_ctf_fanfare3) : 
			(P_Random() > 127 ? HexenDefs::lsid_ctf_fanfare4 : 
			(P_Random() > 127 ? HexenDefs::lsid_ctf_fanfare6 : 
			(P_Random() > 127 ? HexenDefs::lsid_ctf_fanfare8 :
			HexenDefs::lsid_ctf_fanfare11)))),	false, 0.0);
	Game.bcentreprint(va("%s flag captured by %s! %s team scores!",
						/* Game.ColourNames[Banner.Team.Colour]*/Banner.Team.Name,
						Banner.Capturer.PlayerName,
						/* Game.ColourNames[Banner.Capturer.Team.Colour]*/Banner.Capturer.Team.Name));
	Banner.Capturer.UpdateScore(HexenDefs::scoreevent_CtfCapture);
	Banner.ReturnToBase(none, true);
}

defaultproperties
{
}
