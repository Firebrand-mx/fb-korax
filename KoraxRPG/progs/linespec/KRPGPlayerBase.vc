//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ## ###  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**				   ######  #####   ######
//**	               ##   ## ##  ## ##    ##
//**	     		   ##   ## ##  ## ##   
//**	               #####   #####  ##  ####
//**	     		   ## ###  ##     ###   ##
//**	     		   ##  ### ##      ######
//**
//**    $Id: template.vc 1305 2008-03-01 09:20:29Z dj_jl $
//**
//**    Copyright (C) 2004-2008 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class KRPGPlayerBase : PlayerEx;

int strength;
int intelligence;
int wisdom;

//
// [FB] Spell bar stuff
//
Inventory		SpellFirst;
Inventory		SpellPtr;
float			SpellTime;
int				SpellSize;

replication
{
	reliable if (!bIsClient)
		strength, intelligence, wisdom, SpellFirst,
		SpellPtr, SpellTime;
}

/* //==========================================================================
//
//	AddInventory
//
//==========================================================================

void AddInventory(KRPGInventory Item)*/

//==========================================================================
//
//	AddSpellItem
//
//==========================================================================

void AddSpellItem(Inventory Item)
{
	if (Item.bSpellBar && !SpellPtr)
	{
		// SpellPtr = Inventory(Item);
		// SpellFirst = Inventory(Item);
		SpellPtr = Item;
		SpellFirst = Item;
	}
}

//==========================================================================
//
//	GiveExperience
//
//==========================================================================

void GiveExperience(int Exp)
{
}

//==========================================================================
//
//	UpdateStats
//
//==========================================================================

void UpdateStats(int n_strength, int n_vitality, int n_speed, int n_intelligence,
		int n_wisdom)
{
}

//==========================================================================
//
//	GetPoints
//
//==========================================================================

int GetPoints()
{
}

//==========================================================================
//
//	SetPoints
//
//==========================================================================

void SetPoints(int value)
{
}

//==========================================================================
//
//	BuildCharacter
//
//==========================================================================

void BuildCharacter(int i_strength, int i_vitality, int i_speed, int i_intelligence,
		int i_wisdom)
{
}

//==========================================================================
//
//  ChangeWeaponEx
//
//  The actual changing of the weapon is done when the weapon psprite can
// do it (read: not in the middle of an attack).
//
//==========================================================================

final void ChangeWeaponEx(int newweapon)
{
	if (MorphTime)
	{
		return;
	}
	Weapon NewWpn = GetSlotChangeWeaponEx(newweapon);
	if (NewWpn && NewWpn != ReadyWeapon)
	{
		PendingWeapon = NewWpn;
	}
}

//==========================================================================
//
//	GetSlotChangeWeaponEx
//
//	[CW] KRPG: LineSpecialGameInfo.Weapons slots now store not final
//	weapon classes, but abstract weapon category classes.
//	Hence, for example, expression like
//	   GI.WeaponSlots[Slot].Weapons[i] == ReadyWeapon.Class
//	should be changed to
//	   ClassIsChildOf(ReadyWeapon.Class, GI.WeaponSlots[Slot].Weapons[i])
//	et cetera
//
//==========================================================================

final Weapon GetSlotChangeWeaponEx(int Slot)
{
	int			i;
	int			j;
	LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);

	if (ReadyWeapon)
	{
		for (i = 0; i < LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT; i++)
		{
			if (ClassIsChildOf(ReadyWeapon.Class, GI.WeaponSlots[Slot].Weapons[i]) ||
				(ReadyWeapon.bPoweredUp && ReadyWeapon.SisterWeapon &&
				ClassIsChildOf(ReadyWeapon.SisterWeapon.Class, GI.WeaponSlots[Slot].Weapons[i])
				))
			{
				for (j = (i + LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT - 1) %
					LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT; j != i;
					j = (j + LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT - 1) %
					LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT)
				{
					//Weapon Wpn = Weapon(EntityEx(MO).FindInventory(
					//	GI.WeaponSlots[Slot].Weapons[j]));
					// [CW] Temp, CHECKME!
					HexenWeapon Wpn;
					class<HexenWeapon> WpnCls;
					foreach AllClasses(HexenWeapon, WpnCls)
					{
						if (!FindClassState(WpnCls, 'Ready'))
						{
							//	Abstract class.
							continue;
						}
						if (!ClassIsChildOf(WpnCls, GI.WeaponSlots[Slot].Weapons[j]))
						{
							//	Wrong category
							continue;
						}

						WpnCls = class<HexenWeapon>(GetClassReplacement(WpnCls));
						Wpn = HexenWeapon(EntityEx(MO).FindInventory(WpnCls));
						if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false))
						{
							return ChoosePowered(Wpn);
						}
					}
				}
			}
		}
	}

	for (i = LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT - 1; i >= 0; i--)
	{
		// [CW] Temp, CHECKME!
		HexenWeapon Wpn;
		class<HexenWeapon> WpnCls;
		foreach AllClasses(HexenWeapon, WpnCls)
		{
			if (!FindClassState(WpnCls, 'Ready'))
			{
				//	Abstract class.
				continue;
			}
			if (!ClassIsChildOf(WpnCls, GI.WeaponSlots[Slot].Weapons[i]))
			{
				//	Wrong category
				continue;
			}

			WpnCls = class<HexenWeapon>(GetClassReplacement(WpnCls));
			Wpn = HexenWeapon(EntityEx(MO).FindInventory(WpnCls));
			if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false))
			{
				return ChoosePowered(Wpn);
			}
		}
	}

	return ReadyWeapon;
}


//==========================================================================
//
//  NextSpell
//
//==========================================================================

final void NextSpell()
{
	if (!bInventoryAlwaysOpen)
	{
		if (!SpellTime)
		{
			SpellTime = 5.0;
			return;
		}
		SpellTime = 5.0;
	}
	if (SpellPtr)
	{
		// Inventory Prev = KRPGInventory(SpellPtr).PrevSpl();
		Inventory Prev = SpellPtr.PrevSpl();
		if (Prev)
		{
			SpellPtr = Prev;
			AdjustSpellFirst();
		}
	}		
}

//==========================================================================
//
//  PreviousSpell
//
//==========================================================================

final void PreviousSpell()
{
	if (!bInventoryAlwaysOpen)
	{
		if (!SpellTime)
		{
			SpellTime = 5.0;
			return;
		}
		SpellTime = 5.0;
	}
	if (SpellPtr)
	{
		// Inventory Next = KRPGInventory(SpellPtr).NextSpl();
		Inventory Next = SpellPtr.NextSpl();
		if (Next)
		{
			SpellPtr = Next;
			AdjustSpellFirst();
		}
	}
}

//==========================================================================
//
//  SpellUse
//
//==========================================================================

final void SpellUse()
{
	// flag to denote that it's okay to use an artifact
	if (SpellTime)
	{
		SpellTime = 0.0;
	}
	else if (SpellPtr)
	{
		Actor(MO).UseSpell(SpellPtr);
	}
}

//==========================================================================
//
//  SpellTick
//
//==========================================================================

final void SpellTick(float deltaTime)
{
	// turn spell bar off after a certain amount of time
	if (SpellTime)
	{
		SpellTime -= deltaTime;
		if (SpellTime <= 0.0)
		{
			SpellTime = 0.0;
		}
	}
}

//==========================================================================
//
//	AdjustSpellFirst
//
//==========================================================================

final void AdjustSpellFirst()
{
	Inventory Item;

	if (!SpellPtr)
	{
		SpellFirst = none;
		return;
	}

	//	Count how many items are following the current one, also make sure
	// that first is not after this one.
	int NumFollowing = 0;
	// for (Item = KRPGInventory(SpellPtr).NextSpl(); Item; Item = KRPGInventory(Item).NextSpl())
	for (Item = SpellPtr.NextSpl(); Item; Item = Item.NextSpl())
	{
		NumFollowing++;
		if (SpellFirst == Item)
		{
			SpellFirst = SpellPtr;
		}
	}
	int FirstOffs = 0;
	// for (Item = SpellPtr; Item && Item != SpellFirst; Item = KRPGInventory(Item).PrevSpl())
	for (Item = SpellPtr; Item && Item != SpellFirst; Item = Item.PrevSpl())
	{
		FirstOffs++;
	}
	while (FirstOffs > SpellSize)
	{
		// SpellFirst = KRPGInventory(SpellFirst).NextSpl();
		SpellFirst = SpellFirst.NextSpl();
		FirstOffs--;
	}
	// while (NumFollowing + FirstOffs < SpellSize && KRPGInventory(SpellFirst).PrevSpl())
	while (NumFollowing + FirstOffs < SpellSize && SpellFirst.PrevSpl())
	{
		// SpellFirst = KRPGInventory(SpellFirst).PrevSpl();
		SpellFirst = SpellFirst.PrevSpl();
		FirstOffs++;
	}
}

defaultproperties
{
}
