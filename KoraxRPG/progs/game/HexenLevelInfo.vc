//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: HexenLevelInfo.vc 2579 2007-08-05 17:42:41Z dj_jl $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class HexenLevelInfo : LineSpecialLevelInfo;

const int BODYQUESIZE			= 32;
const int CORPSEQUEUESIZE		= 64;

EntityEx bodyque[BODYQUESIZE];
int bodyqueslot;

// Corpse queue for monsters
EntityEx corpseQueue[CORPSEQUEUESIZE];
int corpseQueueSlot;


//
// [KoraxRPG] Node Graph
//
const float	MAXNODELINKLENGTH		= 512.0;
bool bNodeGraphBuild;


//==========================================================================
//
//  SpawnSpecials
//
//	[KoraxRPG]
//
//==========================================================================

void SpawnSpecials()
{
	::SpawnSpecials();
	BuildNodeGraph();
}

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;
	EntityEx A;

	A = EntityEx(E);
	buttonSuccess = false;
	switch (Special)
	{
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, EntityEx A)
{
	int lineActivation;

	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType)
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if (lineActivation != SPAC_MCROSS)
		{
			// currently, monsters can only activate the MCROSS activation type
			return false;
		}
		if (line->flags & ML_SECRET)
			return false;	// never open secret doors
	}
	return true;
}

//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//	A_LocalQuake
//
//===========================================================================

bool A_LocalQuake(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	QuakeFocus focus;
	EntityEx target;
	int lastfound = 0;
	int success = false;

	// Find all quake foci
	do
	{
		target = EntityEx(FindMobjFromTID(Arg5, &lastfound));
		if (target)
		{
			focus = QuakeFocus(Spawn(QuakeFocus, target.Origin));
			if (focus)
			{
				focus.Richters = Arg1;
				focus.QuakeDuration = Arg2 >> 1;	// decremented every 2 tics
				focus.DamageRadius = itof(Arg3) * 64.0;
				focus.TremorRadius = itof(Arg4) * 64.0;
				success = true;
			}
		}
	}
	while (target);

	return success;
}

//==========================================================================
//
//  GetClassSpawnFlags
//
//==========================================================================

int GetPClassSpawnFlags()
{
	if (!Game.netgame)
	{
		// Single player
		return MainGameInfo(Game).classFlags[GetCvar('class')];
	}
#ifdef FIXME	//  Because of client/server and in-game joining we can't do this
	else if (!deathmatch)
	{
		// Cooperative
		int spawnMask = 0;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (GPlayers[i])
			{
				spawnMask |= classFlags[PlayerClass[i]];
			}
		}
		return spawnMask;
	}
#endif
	return 0;
}

//**************************************************************************
//
//
//	[KoraxRPG] Node Graph
//
//
//**************************************************************************

//===========================================================================
//
//  BuildNodeGraph
//
//===========================================================================

void BuildNodeGraph()
{
	dprint("CWAIEX : DLI::BuildNodeGraph : IN");
	BuildLinks();
	//BuildPaths();	// ?? TODO
	//BuildPathIntersections();	// ?? TODO
	dprint("CWAIEX : DLI::BuildNodeGraph : OUT");
}

//===========================================================================
//
//  BuildLinks
//
//	Builds common links between all nodes.
//
//===========================================================================

void BuildLinks()
{
	int i;
	Node		N_Base;
	Node		N_LinkCandidate;
	int			linked_count;
	bool		candidate_is_linked_to_base;
	int			candidate_linked_count;
	float		dest;
	float		dest_linked_max;

	//
	// Debug statistics
	//------------------------
	int			stats_TotalBaseNodes = 0;
	int			stats_TotalLinkedNodes = 0;
	int			stats_TotalUnlinkedNodes = 0;
	int			stats_AverageLinksPerNode = 0;
	int			stats_TotalLinks = 0;
	float		stats_MaximalLinkLength = 0.0;
	float		stats_MinimalLinkLength = -1.0;
	// etc etc etc.....
	//------------------------
	//

	dprint("CWAIEX : DLI::BuildLinks : IN");

	foreach AllThinkers(Node, N_Base)
	{
		stats_TotalBaseNodes++;

		N_LinkCandidate = none;
		linked_count = 0;
		dest = -1.0;
		dest_linked_max = -1.0;

		dprint(" -- take N_Base");

		for (i = 0; i < Node::MAXNODELINKS; i++)
		{
			if (N_Base.Links[i]._Node)
				linked_count++;
		}

		dprint(" -- N_Base Tag = %i", N_Base.TID);
		dprint(" -- linked count = %i", linked_count);
		
		if (linked_count >= Node::MAXNODELINKS)
		{
			stats_TotalLinkedNodes++;
			continue;
		}
		
		foreach AllThinkers(Node, N_LinkCandidate)
		{
			dprint(" -- take N_LinkCandidate");
			dprint(" -- N_LinkCandidate Tag = %i", N_LinkCandidate.TID);
			candidate_is_linked_to_base = false;
			candidate_linked_count = 0;
			if (N_LinkCandidate == N_Base)
			{
				dprint(" -- self as candidate, rejected");
				continue;
			}
			for (i = 0; i < Node::MAXNODELINKS; i++)
			{
				if (N_LinkCandidate.Links[i]._Node)
				{
					if (N_LinkCandidate.Links[i]._Node == N_Base)
					{
						candidate_is_linked_to_base = true;
						break;
					}						
					candidate_linked_count++;
				}
			}
			if (candidate_is_linked_to_base)
			{
				dprint(" -- candidate already linked to base, rejected");
				continue;
			}
			if (candidate_linked_count == Node::MAXNODELINKS)
			{
				dprint(" -- all candidate link slots used, rejected");
				continue;
			}

			dprint(" -- candidate linked count = %i", candidate_linked_count);

			dest = Length(N_Base.Origin - N_LinkCandidate.Origin);
			dprint(" -- candidate dest = %f", dest);
			if (dest <= MAXNODELINKLENGTH &&
				(dest_linked_max < 0.0 || dest < dest_linked_max) )
			{
				Node::nodelink_t _link;

				dprint(" -- dest accepted");

				if (BuildNodeLink(N_Base, N_LinkCandidate, &_link))
				{
					if (dest_linked_max < 0.0)
					{
						dprint(" -- free link for the base");
						N_Base.ApplyLink(&_link, linked_count, true);
						dprint(" -- candidate accepted as no %i", linked_count);
					}
					if (dest < dest_linked_max)
					{
						dprint(" -- link replacement");
						// Get linked node with maximal dest and replace it by a new one
						for (i = 0; i < Node::MAXNODELINKS; i++)
						{
							if (N_Base.Links[i].length == dest_linked_max)
							{
								linked_count--;
								stats_TotalLinks--;
								N_Base.ApplyLink(&_link, i, true);
								break;
							}
						}
						dprint(" -- candidate accepted as no %i", i);
					}

					linked_count++;
					stats_TotalLinks++;
					if (linked_count == Node::MAXNODELINKS)
					{
						// Store maximal link length
						dest_linked_max = -1.0;
						for (i = 0; i < Node::MAXNODELINKS; i++)
						{
							if (dest_linked_max < 0.0 || N_Base.Links[i].length > dest_linked_max)
								dest_linked_max = N_Base.Links[i].length;
						}
						dprint(" -- new max_dest = %f", dest_linked_max);
					}
				}
				else
					dprint(" -- candidate rejected");
			}
			else
				dprint(" -- dest rejected");
		}
		dprint(" -- no more candidates");


		if (linked_count)
			stats_TotalLinkedNodes++;
		else
			stats_TotalUnlinkedNodes++;
		stats_AverageLinksPerNode += linked_count;
		for (i = 0; i < linked_count; i++)
		{
			Node::nodelink_t * p_link = &N_Base.Links[i];
			if (stats_MaximalLinkLength < p_link->length)
				stats_MaximalLinkLength = p_link->length;
			if (stats_MinimalLinkLength < 0.0 || stats_MinimalLinkLength > p_link->length)
				stats_MinimalLinkLength = p_link->length;
		}

	}
	dprint(" -- no more bases");

	if (stats_TotalBaseNodes)
		stats_AverageLinksPerNode /= stats_TotalBaseNodes;

	//
	// Debug info output
	//------------------------
	print("");
	print(" ============= Node Graph Info =============");
	print("   Total Nodes found:               %i      ", stats_TotalBaseNodes);
	print("   Total Bidirect Links build:      %i      ", stats_TotalLinks);
	print("   Total Linked Nodes:              %i      ", stats_TotalLinkedNodes);
	print("   Total Unlinked Nodes:            %i      ", stats_TotalUnlinkedNodes);
	print("   Average Links per Node:          %i      ", stats_AverageLinksPerNode);
	print("   Maximal Link Length:             %f      ", stats_MaximalLinkLength);
	print("   Minimal Link Length:             %f      ", stats_MinimalLinkLength);
	print(" ===========================================");
	print("");
	//------------------------
	//

	bNodeGraphBuild = (stats_TotalBaseNodes > 0);

	dprint("CWAIEX : DLI::BuildLinks : OUT");
}

//===========================================================================
//
//  BuildNodeLink
//
//	Tries to build a link between two nodes and sets link parameters.
//
//===========================================================================

bool BuildNodeLink(Node N_From, Node N_To, Node::nodelink_t * _link)
{
	bool canreach;
	ReachTraverse::linkreach_traverse_data LRTRData;
	dprint("CWAIEX : DLI::BuildNodeLink : IN");
	dprint(" --- N_From tag = %i", N_From.TID);
	dprint(" --- N_To tag = %i", N_To.TID);

	canreach = BuildNodeLinkTraverse(N_From, N_To, &LRTRData);

	if (!canreach)
	{
		dprint("CWAIEX : DLI::BuildNodeLink : OUT FALSE");
		return false;
	}
	if (!LRTRData.intercepted_once && N_From.Sector != N_To.Sector)
	{
		dprint("CWAIEX : DLI::BuildNodeLink : OUT FALSE EX");
		return false;
	}
	
	_link->_Node = N_To;
	_link->length = Length(N_From.Origin - N_To.Origin);
	_link->minyspace = LRTRData.minyspace;
	_link->maxstepheight = LRTRData.maxstepheight;
	_link->maxdropoff = LRTRData.maxdropoff;
	
	dprint(" --- Link length = %f", _link->length);
	dprint(" --- Link minyspace = %f", _link->minyspace);
	dprint(" --- Link maxstepheight = %f", _link->maxstepheight);
	dprint(" --- Link maxdropoff = %f", _link->maxdropoff);

	dprint("CWAIEX : DLI::BuildNodeLink : OUT TRUE");
	return true;
}

//==========================================================================
//
//	BuildNodeLinkTraverse
//
//==========================================================================

bool BuildNodeLinkTraverse(Node N_From, Node N_To,
							ReachTraverse::linkreach_traverse_data * pLRTRData)
{
	dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : IN");

	intercept_t * in;
	pLRTRData->intercepted_once = false;
	pLRTRData->prev_sector = N_From.Sector;
	pLRTRData->minyspace = N_From.Sector->ceilingheight - N_From.Sector->floorheight;	
	pLRTRData->maxstepheight = 0.0;
	pLRTRData->maxdropoff = 0.0;


	foreach PathTraverse(in, N_From.Origin.x, N_From.Origin.y, N_To.Origin.x, N_To.Origin.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pLRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;
			float ceiling;
			float floor;
			float yspace;
			float fheightdelta;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
			{
				dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : OUT FALSE");
				return false;
			}


			// in case of two-sided lines we update link info
			if (in->line->frontsector == pLRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pLRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
			{
				// something was really messed up
				dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : OUT FALSE EX");
				return false;
			}

			if (p_sector->ceilingheight < pLRTRData->prev_sector->ceilingheight)
				ceiling = p_sector->ceilingheight;
			else
				ceiling = pLRTRData->prev_sector->ceilingheight;
			if (p_sector->floorheight > pLRTRData->prev_sector->floorheight)
				floor = p_sector->floorheight;
			else
				floor = pLRTRData->prev_sector->floorheight;
			yspace = ceiling - floor;
			fheightdelta = p_sector->floorheight - pLRTRData->prev_sector->floorheight;

			if (yspace < pLRTRData->minyspace)
				pLRTRData->minyspace = yspace;
			if (fheightdelta > 0.0)
			{
				if (fheightdelta > pLRTRData->maxstepheight)
					pLRTRData->maxstepheight = fheightdelta;
			}
			else if (fheightdelta < 0.0)
			{
				if (fheightdelta < -pLRTRData->maxdropoff)
					pLRTRData->maxdropoff = -fheightdelta;
			}

			pLRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
		}
	}

	dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : OUT TRUE");
	return true;
}


defaultproperties
{
	ExtPlayersBase = 9100;
}
