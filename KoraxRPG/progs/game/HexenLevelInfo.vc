//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: HexenLevelInfo.vc 2773 2007-11-09 23:11:21Z firebrand_kh $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class HexenLevelInfo : LineSpecialLevelInfo;

const int BODYQUESIZE			= 32;
const int CORPSEQUEUESIZE		= 64;

EntityEx bodyque[BODYQUESIZE];
int bodyqueslot;

// Corpse queue for monsters
EntityEx corpseQueue[CORPSEQUEUESIZE];
int corpseQueueSlot;

enum
{
	pt_ice_chunk
};


//
// [KoraxRPG] Node Graph
//
const float	MAXNODELINKLENGTH		= 512.0;
bool bNodeGraphBuild;

//
// New Action Specials

// [CW] in order not to mix these with common line specials,
//	their ids should be greater than 255;
//  AFAIK "Doom Builder" supports >255 linespecial values with
//  specific format tag set in configuration file; if mapper is using
//  different editor, he may still run those using scripts
enum
{
	//
	// Advanced thing manipulation

	ACTSPEC_Thing_Thrust3d			= 256,
	ACTSPEC_Thing_SetPlayerMOTag,			// sets TID to current player MO (using player's Number)
	ACTSPEC_Thing_SetTeam,

	//
	// Miscellaneous, that could be useful

	ACTSPEC_IsConditionTrue			= 755,	/* this id is taken equal to same actspec in Korax Arena*/
	ACTSPEC_RunACSConditional,

	//
	// Intelligent Actors
	//
	// Generic behavior
	ACTSPEC_IA_SetThreatReaction	= 800,

	// Orders
	ACTSPEC_IA_Order_CancelAll		= 900,
	ACTSPEC_IA_Order_CancelCurrent,
	ACTSPEC_IA_Order_StandStill,
	ACTSPEC_IA_Order_StandLook180,
	ACTSPEC_IA_Order_StandLook360,
	ACTSPEC_IA_Order_WalkTo,
	ACTSPEC_IA_Order_WalkPath,
	ACTSPEC_IA_Order_Patrol2pt,
	ACTSPEC_IA_Order_PatrolPath,
	ACTSPEC_IA_Order_PatrolLoop,
	ACTSPEC_IA_Order_Follow,		/* 910 */
	ACTSPEC_IA_Order_EvadePos,			
	ACTSPEC_IA_Order_EvadeThing,
	ACTSPEC_IA_Order_AttackAll,		
	ACTSPEC_IA_Order_AttackThing,


	ACTSPEC_Last
};

// [CW] Conditions for ACTSPEC_IsConditionTrue and ACTSPEC_RunACSConditional
enum
{
	CNDT_Unused		// just to be...
};


//==========================================================================
//
//  SpawnSpecials
//
//	[KoraxRPG]
//
//==========================================================================

void SpawnSpecials()
{
	::SpawnSpecials();
	BuildNodeGraph();
}

//==========================================================================
//
//  ExecuteActionSpecialForTID
//
//	[KoraxRPG]
//
//==========================================================================

bool ExecuteActionSpecialForTID(int Special, int TID, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side)
{
	Entity E;
	bool result = false;
	if (TID)
	{
		int searcher = -1;
		for (E = Entity(FindMobjFromTID(TID, &searcher)); E;
			E = Entity(FindMobjFromTID(TID, &searcher)))
		{
			if (E && ExecuteActionSpecial(Special, 0, Arg2, Arg3, Arg4, Arg5, Line, Side, E))
				result = true;
		}
	}
	else
	{
		foreach AllThinkers(Entity, E)
		{
			if (ExecuteActionSpecial(Special, 0, Arg2, Arg3, Arg4, Arg5, Line, Side, E))
				result = true;
		}
	}
	return result;
}

//==========================================================================
//
//  ExecuteActionSpecial
//
//	KRPG override for new action specials
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;

	buttonSuccess = false;

	if ( ( Special >= ACTSPEC_Thing_Thrust3d && Special < ACTSPEC_IsConditionTrue 
		&& Special != ACTSPEC_Thing_SetPlayerMOTag
		||
		Special >= ACTSPEC_IA_SetThreatReaction ) 
		&& (!E || ((Arg1 & 0x80000000) != 0)) )
	{
		buttonSuccess = ExecuteActionSpecialForTID(Special, Arg1 & 0x7fffffff, Arg2, Arg3, Arg4, Arg5, Line, Side);
		return buttonSuccess;
	}

	switch (Special)
	{
	//
	// Advanced thing manipulation
	case ACTSPEC_Thing_Thrust3d:
		if (E && E.IsA('Actor'))
		{
			A_Thing3dThrust(Actor(E), Arg2, Arg3, Arg4, Arg5);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_Thing_SetPlayerMOTag:
		if (Game.Players[Arg1] && Game.Players[Arg1].MO)
		{
			Game.Players[Arg1].MO.RemoveFromTIDList();
			Game.Players[Arg1].MO.InsertIntoTIDList(Arg2);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_Thing_SetTeam:
		if (E && E.IsA('Actor'))
		{
			Actor(E).SetTeam(Arg2);
			buttonSuccess = true;
		}
		break;


	//
	// Intelligent Actors
	//
	// Generic behavior
	case ACTSPEC_IA_SetThreatReaction:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_SetThreatReaction(Arg2, itof(Arg3));
			buttonSuccess = true;
		}
		break;

	// Orders
	case ACTSPEC_IA_Order_CancelAll:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderCancelAll();
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_CancelCurrent:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderCancelCurrent();
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_StandStill:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderStandStill(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_StandLook180:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderStandStill(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_StandLook360:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderStandStill(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_WalkTo:
		if (E && E.IsA('IntelligentActor'))
		{
			int s = -1;
			Entity target = FindMobjFromTID(Arg4, &s);
			IntelligentActor(E).A_OrderWalkTo(false, Arg2, itof(Arg3) / 1000.0,
										target ? target.Origin : E.Origin);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_WalkPath:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderWalkPath(false, false, false, Arg2, itof(Arg3) / 1000.0,
									Arg4, Arg5 & 0x7fffffff, (Arg5 & 0x80000000) != 0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_Patrol2pt:
		if (E && E.IsA('IntelligentActor'))
		{
			int s = -1;
			Entity target1 = FindMobjFromTID(Arg4, &s);
			s = -1;
			Entity target2 = FindMobjFromTID(Arg5, &s);
			IntelligentActor(E).A_OrderPatrol2Pt(false, Arg2, itof(Arg3) / 1000.0,
							target1 ? target1.Origin : E.Origin,
							target2 ? target2.Origin : E.Origin);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_PatrolPath:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderWalkPath(false, true, false, Arg2, itof(Arg3) / 1000.0,
									Arg4, Arg5 & (0x7fffffff), Arg5 & (0x80000000) != 0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_PatrolLoop:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderWalkPath(false, true, true, Arg2, itof(Arg3) / 1000.0,
									Arg4, Arg5 & (0x7fffffff), Arg5 & (0x80000000) != 0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_Follow:
		if (E && E.IsA('IntelligentActor'))
		{
			int s = -1;
			IntelligentActor(E).A_OrderFollowThing(false, Arg2, itof(Arg3) / 1000.0,
										FindMobjFromTID(Arg4, &s));
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_EvadePos:
		if (E && E.IsA('IntelligentActor'))
		{
			int s = -1;
			Entity target = FindMobjFromTID(Arg4, &s);
			IntelligentActor(E).A_OrderEvadePos(false, Arg2, itof(Arg3) / 1000.0,
										target ? target.Origin : E.Origin);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_EvadeThing:
		if (E && E.IsA('IntelligentActor'))
		{
			int s = -1;
			IntelligentActor(E).A_OrderEvadeThing(false, Arg2, itof(Arg3) / 1000.0,
										FindMobjFromTID(Arg4, &s));
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_AttackAll:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).A_OrderAttackAll(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_AttackThing:
		if (E && E.IsA('IntelligentActor'))
		{
			int s = -1;
			IntelligentActor(E).A_OrderAttackThing(false, Arg2, itof(Arg3) / 1000.0, FindMobjFromTID(Arg4, &s));
			buttonSuccess = true;
		}
		break;

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, EntityEx A)
{
	int lineActivation;

	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType)
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if (lineActivation != SPAC_MCROSS)
		{
			// currently, monsters can only activate the MCROSS activation type
			return false;
		}
		if (line->flags & ML_SECRET)
			return false;	// never open secret doors
	}
	return true;
}

//**************************************************************************
//
//	[KoraxRPG] New Action Specials
//
//**************************************************************************

//==========================================================================
//
//  A_Thing3dThrust
//
//  [CW] A three-dimensional vector variant of ThingThrust action special
//
//==========================================================================

void A_Thing3dThrust(Actor A, int angle2d, int angle3, int move, int move2)
{
	if (A)
	{
      if (angle3)
         Actor(A).Thrust3d(itof(angle2d), itof(angle3), itof(move));
      else
         Actor(A).Thrust3d2(itof(angle2d), itof(move), itof(move2));
	}
}

//==========================================================================
//
//  GetClassSpawnFlags
//
//==========================================================================

int GetPClassSpawnFlags()
{
	if (!Game.netgame)
	{
		// Single player
		return MainGameInfo(Game).classFlags[GetCvar('class')];
	}
#ifdef FIXME	//  Because of client/server and in-game joining we can't do this
	else if (!deathmatch)
	{
		// Cooperative
		int spawnMask = 0;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (GPlayers[i])
			{
				spawnMask |= classFlags[PlayerClass[i]];
			}
		}
		return spawnMask;
	}
#endif
	return 0;
}

//==========================================================================
//
//  UpdateParticle
//
//==========================================================================

void UpdateParticle(particle_t * p, float DeltaTime)
{
	float grav;

	grav = DeltaTime * p->gravity /*sv_gravity.value * 0.05*/;
	p->accel.z -= grav;
	
	switch (p->type)
	{
	case pt_ice_chunk:
		p->vel.x -= p->vel.x * DeltaTime;
		p->vel.y -= p->vel.y * DeltaTime;
		p->vel.z += p->accel.z * DeltaTime;
		break;
	}
	::UpdateParticle(p, DeltaTime);
}


//**************************************************************************
//
//
//	[KoraxRPG] Node Graph
//
//
//**************************************************************************

//===========================================================================
//
//  BuildNodeGraph
//
//===========================================================================

void BuildNodeGraph()
{
	//dprint("CWAIEX : DLI::BuildNodeGraph : IN");
	BuildLinks();
	BuildPaths();
	//BuildPathIntersections();	// ?? TODO
	//dprint("CWAIEX : DLI::BuildNodeGraph : OUT");
}

//===========================================================================
//
//  BuildLinks
//
//	Builds common links between all nodes.
//
//===========================================================================

void BuildLinks()
{
	int i;
	Node		N_Base;
	Node		N_LinkCandidate;
	int			linked_count;
	bool		candidate_is_linked_to_base;
	int			candidate_linked_count;
	float		dest;
	float		dest_linked_max;

	//
	// Debug statistics
	//------------------------
	int			stats_TotalBaseNodes = 0;
	int			stats_TotalLinkedNodes = 0;
	int			stats_TotalUnlinkedNodes = 0;
	int			stats_AverageLinksPerNode = 0;
	int			stats_TotalLinks = 0;
	float		stats_MaximalLinkLength = 0.0;
	float		stats_MinimalLinkLength = -1.0;
	// etc etc etc.....
	//------------------------
	//

	//dprint("CWAIEX : DLI::BuildLinks : IN");

	foreach AllThinkers(Node, N_Base)
	{
		stats_TotalBaseNodes++;

		N_LinkCandidate = none;
		linked_count = 0;
		dest = -1.0;
		dest_linked_max = -1.0;

		//dprint(" -- take N_Base");

		for (i = 0; i < Node::MAXNODELINKS; i++)
		{
			if (N_Base.Links[i]._Node)
				linked_count++;
		}

		//dprint(" -- N_Base Tag = %i", N_Base.TID);
		//dprint(" -- linked count = %i", linked_count);
		
		if (linked_count >= Node::MAXNODELINKS)
		{
			stats_TotalLinkedNodes++;
			continue;
		}
		
		foreach AllThinkers(Node, N_LinkCandidate)
		{
			//dprint(" -- take N_LinkCandidate");
			//dprint(" -- N_LinkCandidate Tag = %i", N_LinkCandidate.TID);
			candidate_is_linked_to_base = false;
			candidate_linked_count = 0;
			if (N_LinkCandidate == N_Base)
			{
				//dprint(" -- self as candidate, rejected");
				continue;
			}
			for (i = 0; i < Node::MAXNODELINKS; i++)
			{
				if (N_LinkCandidate.Links[i]._Node)
				{
					if (N_LinkCandidate.Links[i]._Node == N_Base)
					{
						candidate_is_linked_to_base = true;
						break;
					}						
					candidate_linked_count++;
				}
			}
			if (candidate_is_linked_to_base)
			{
				//dprint(" -- candidate already linked to base, rejected");
				continue;
			}
			if (candidate_linked_count == Node::MAXNODELINKS)
			{
				//dprint(" -- all candidate link slots used, rejected");
				continue;
			}

			//dprint(" -- candidate linked count = %i", candidate_linked_count);

			dest = Length(N_Base.Origin - N_LinkCandidate.Origin);
			//dprint(" -- candidate dest = %f", dest);
			if (dest <= MAXNODELINKLENGTH &&
				(dest_linked_max < 0.0 || dest < dest_linked_max) )
			{
				Node::nodelink_t _link;

				//dprint(" -- dest accepted");

				if (BuildNodeLink(N_Base, N_LinkCandidate, &_link))
				{
					if (dest_linked_max < 0.0)
					{
						//dprint(" -- free link for the base");
						N_Base.ApplyLink(&_link, linked_count, true);
						//dprint(" -- candidate accepted as no %i", linked_count);
					}
					if (dest < dest_linked_max)
					{
						//dprint(" -- link replacement");
						// Get linked node with maximal dest and replace it by a new one
						for (i = 0; i < Node::MAXNODELINKS; i++)
						{
							if (N_Base.Links[i].length == dest_linked_max)
							{
								linked_count--;
								stats_TotalLinks--;
								N_Base.ApplyLink(&_link, i, true);
								break;
							}
						}
						//dprint(" -- candidate accepted as no %i", i);
					}

					linked_count++;
					stats_TotalLinks++;
					if (linked_count == Node::MAXNODELINKS)
					{
						// Store maximal link length
						dest_linked_max = -1.0;
						for (i = 0; i < Node::MAXNODELINKS; i++)
						{
							if (dest_linked_max < 0.0 || N_Base.Links[i].length > dest_linked_max)
								dest_linked_max = N_Base.Links[i].length;
						}
						//dprint(" -- new max_dest = %f", dest_linked_max);
					}
				}
				//else
				//	dprint(" -- candidate rejected");
			}
			//else
			//	dprint(" -- dest rejected");
		}
		//dprint(" -- no more candidates");


		if (linked_count)
			stats_TotalLinkedNodes++;
		else
			stats_TotalUnlinkedNodes++;
		stats_AverageLinksPerNode += linked_count;
		for (i = 0; i < linked_count; i++)
		{
			Node::nodelink_t * p_link = &N_Base.Links[i];
			if (stats_MaximalLinkLength < p_link->length)
				stats_MaximalLinkLength = p_link->length;
			if (stats_MinimalLinkLength < 0.0 || stats_MinimalLinkLength > p_link->length)
				stats_MinimalLinkLength = p_link->length;
		}

	}
	//dprint(" -- no more bases");

	if (stats_TotalBaseNodes)
		stats_AverageLinksPerNode /= stats_TotalBaseNodes;

	//
	// Debug info output
	//------------------------
	print("");
	print(" ============= Node Graph Info =============");
	print("   Total Nodes found:               %i      ", stats_TotalBaseNodes);
	print("   Total Bidirect Links build:      %i      ", stats_TotalLinks);
	print("   Total Linked Nodes:              %i      ", stats_TotalLinkedNodes);
	print("   Total Unlinked Nodes:            %i      ", stats_TotalUnlinkedNodes);
	print("   Average Links per Node:          %i      ", stats_AverageLinksPerNode);
	print("   Maximal Link Length:             %f      ", stats_MaximalLinkLength);
	print("   Minimal Link Length:             %f      ", stats_MinimalLinkLength);
	print(" ===========================================");
	print("");
	//------------------------
	//

	bNodeGraphBuild = (stats_TotalBaseNodes > 0);

	//dprint("CWAIEX : DLI::BuildLinks : OUT");
}

//===========================================================================
//
//  BuildNodeLink
//
//	Tries to build a link between two nodes and sets link parameters.
//
//===========================================================================

bool BuildNodeLink(Node N_From, Node N_To, Node::nodelink_t * _link)
{
	bool canreach;
	ReachTraverse::linkreach_traverse_data LRTRData;
	//dprint("CWAIEX : DLI::BuildNodeLink : IN");
	//dprint(" --- N_From tag = %i", N_From.TID);
	//dprint(" --- N_To tag = %i", N_To.TID);

	canreach = BuildNodeLinkTraverse(N_From, N_To, &LRTRData);

	if (!canreach)
	{
		//dprint("CWAIEX : DLI::BuildNodeLink : OUT FALSE");
		return false;
	}
	if (!LRTRData.intercepted_once && N_From.Sector != N_To.Sector)
	{
		//dprint("CWAIEX : DLI::BuildNodeLink : OUT FALSE EX");
		return false;
	}
	
	_link->_Node = N_To;
	_link->length = Length(N_From.Origin - N_To.Origin);
	_link->minyspace = LRTRData.minyspace;
	_link->maxstepheight = LRTRData.maxstepheight;
	_link->maxdropoff = LRTRData.maxdropoff;
	
	//dprint(" --- Link length = %f", _link->length);
	//dprint(" --- Link minyspace = %f", _link->minyspace);
	//dprint(" --- Link maxstepheight = %f", _link->maxstepheight);
	//dprint(" --- Link maxdropoff = %f", _link->maxdropoff);

	//dprint("CWAIEX : DLI::BuildNodeLink : OUT TRUE");
	return true;
}

//==========================================================================
//
//	BuildNodeLinkTraverse
//
//==========================================================================

bool BuildNodeLinkTraverse(Node N_From, Node N_To,
							ReachTraverse::linkreach_traverse_data * pLRTRData)
{
	//dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : IN");

	intercept_t * in;
	pLRTRData->intercepted_once = false;
	pLRTRData->prev_sector = N_From.Sector;
	pLRTRData->minyspace = N_From.Sector->ceilingheight - N_From.Sector->floorheight;	
	pLRTRData->maxstepheight = 0.0;
	pLRTRData->maxdropoff = 0.0;


	foreach PathTraverse(in, N_From.Origin.x, N_From.Origin.y, N_To.Origin.x, N_To.Origin.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pLRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;
			float ceiling;
			float floor;
			float yspace;
			float fheightdelta;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
			{
				//dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : OUT FALSE");
				return false;
			}


			// in case of two-sided lines we update link info
			if (in->line->frontsector == pLRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pLRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
			{
				// something was really messed up
				//dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : OUT FALSE EX");
				return false;
			}

			if (p_sector->ceilingheight < pLRTRData->prev_sector->ceilingheight)
				ceiling = p_sector->ceilingheight;
			else
				ceiling = pLRTRData->prev_sector->ceilingheight;
			if (p_sector->floorheight > pLRTRData->prev_sector->floorheight)
				floor = p_sector->floorheight;
			else
				floor = pLRTRData->prev_sector->floorheight;
			yspace = ceiling - floor;
			fheightdelta = p_sector->floorheight - pLRTRData->prev_sector->floorheight;

			if (yspace < pLRTRData->minyspace)
				pLRTRData->minyspace = yspace;
			if (fheightdelta > 0.0)
			{
				if (fheightdelta > pLRTRData->maxstepheight)
					pLRTRData->maxstepheight = fheightdelta;
			}
			else if (fheightdelta < 0.0)
			{
				if (fheightdelta < -pLRTRData->maxdropoff)
					pLRTRData->maxdropoff = -fheightdelta;
			}

			pLRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
		}
	}

	//dprint("CWAIEX : DLI::PTR_BuildNodeLinkTraverse : OUT TRUE");
	return true;
}


//===========================================================================
//
//  BuildPaths
//
//	Make special connections between path nodes (if any of them exist)
//
//===========================================================================

void BuildPaths()
{
	PathNode	PN_Base;
	PathNode	PN_Candidate;
	int			PathIndex;
	int			PNIndex;
	bool		bPNLinked;

	//
	// Debug statistics
	//------------------------
	int			stats_TotalPathNodes = 0;
	int			stats_TotalLinkedPathNodes = 0;
	int			stats_TotalUnlinkedPathNodes = 0;
	int			stats_TotalPaths = 0;
	int			stats_AverageNodesPerPath = 0;
	float		stats_MaximalLinkLength = 0.0;
	float		stats_MinimalLinkLength = -1.0;
	float		stats_MaximalPathLength = 0.0;
	float		stats_MinimalPathLength = -1.0;
	// etc etc etc.....
	//------------------------
	//


	foreach AllThinkers(PathNode, PN_Base)
	{
		bPNLinked = false;
		stats_TotalPathNodes++;

		PathIndex = PN_Base.Args[PathNode::ARG__PATHINDEX];
		PNIndex = PN_Base.Args[PathNode::ARG__NODEINDEX];

		// Find next path node
		PN_Candidate = none;
		foreach AllThinkers(PathNode, PN_Candidate)
		{
			if (PN_Candidate == PN_Base)
				continue;

			if (PN_Candidate.Args[PathNode::ARG__PATHINDEX] == PathIndex &&
					PN_Candidate.Args[PathNode::ARG__NODEINDEX] == PNIndex + 1)
			{
				PN_Base.FW = PN_Candidate;
				bPNLinked = true;
				break;
			}
		}

		// Find prev path node
		PN_Candidate = none;
		foreach AllThinkers(PathNode, PN_Candidate)
		{
			if (PN_Candidate == PN_Base)
				continue;

			if (PN_Candidate.Args[PathNode::ARG__PATHINDEX] == PathIndex &&
					PN_Candidate.Args[PathNode::ARG__NODEINDEX] == PNIndex - 1)
			{
				PN_Base.BW = PN_Candidate;
				bPNLinked = true;
				break;
			}
		}

		if (bPNLinked)
			stats_TotalLinkedPathNodes++;
		else
			stats_TotalUnlinkedPathNodes++;
	}

	//
	// Debug info output
	//------------------------
	print("");
	print(" ================ Paths Info ===============");
	print("   Total Path Nodes found:          %i      ", stats_TotalPathNodes);
	print("   Total Linked Path Nodes:         %i      ", stats_TotalLinkedPathNodes);
	print("   Total Unlinked Path Nodes:       %i      ", stats_TotalUnlinkedPathNodes);
	print(" ===========================================");
	print("");
	//------------------------
	//
}

defaultproperties
{
	ExtPlayersBase = 9100;
}
