//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: Actor.vc 2707 2007-09-07 17:47:04Z dj_jl $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : ScriptedEntity
	abstract;

const float MORPHTIME 		= 40.0;
const float MAULATORTIME 	= 25.0;

const float TELEFOGHEIGHT	= 32.0;


//
// [KoraxRPG] Advanced AI
//
const float	DEFAULT_THREAT_VICINITY		= MISSILERANGE;

TVec *			pTargetVec;

bool			bIgnoreTeams;
int				Team;

//
// [KoraxRPG] Actor Conditions
//
LinkedList Conditions;


//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================

final int HITDICE(int a)
{
	return (1 + (P_Random() & 7)) * a;
}

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	// Remove from creature queue
	if (bMonster && bCorpse)
	{
		A_DeQueueCorpse();
	}

	::Destroyed();
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
	::Died(source, inflictor);

	NotifyConditions(ActorCondition::notify_RecepientDead, source, 0);
}

//==========================================================================
//
//	KilledByPlayer
//
//==========================================================================

void KilledByPlayer(EntityEx source)
{
	// Check for frag changes
	if (bIsPlayer)
	{
		if (source.Player.bIsBot)
		{
			Player(source.Player).Bot.Killed(self);
		}

		if (Player.bIsBot)
		{
			Player(Player).Bot.Died(Actor(source));
		}

		if (self == source)
		{
			// Self-frag
			Player.Frags--;
		}
		else
		{
			source.Player.Frags++;
		}
	}
}

//==========================================================================
//
//	PlayerKilled
//
//==========================================================================

void PlayerKilled(EntityEx source, EntityEx inflictor)
{
	// Count environment kills against you
	if (!source)
	{
		Player.Frags--;
	}
}

//**************************************************************************
//
//
//	[KoraxRPG] Advanced AI
//
//
//**************************************************************************

//==========================================================================
//
//	LookForEnemy
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool LookForEnemy(bool allaround, optional bool nearest,
					optional TVec At, optional float maxdist, optional Actor ExcludeActor)
{
	Actor		mo;
	float		an;
	float		dist;
	float		min_dist;

	if (!specified_nearest)
		nearest = true;

	if (!specified_At)
		At = Origin;

	Target = none;
	min_dist = -1.0;

	foreach AllThinkers(Actor, mo)
	{
		if (mo == self)
			continue;	// self

		if (specified_ExcludeActor)
		{
			if (mo == ExcludeActor)
				continue;
		}

		if (!mo.bShootable || mo.bNonShootable || mo.bDormant || mo.bInvulnerable || mo.bNeverTarget)
			continue;

		if (mo.Health <= 0)
			continue;	// dead

		if (!bIgnoreTeams && (Team == mo.Team))
			continue;	// friendly

		if (!CanSee(mo))
			continue;	// out of sight

		if (specified_maxdist)
		{
			if (Length(mo.Origin - At) > maxdist)
				continue;
		}

		if (P_Random() > 200)
			continue;	// sometimes skip

		dist = DistTo(mo);

		if (!allaround)
		{
			an = AngleMod360(atan2(mo.Origin.y - Origin.y,
				mo.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				//dist = DistTo(mo);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		if (nearest)
		{
			if (min_dist < 0.0 || min_dist > dist)
			{
				min_dist = dist;
				Target = mo;
			}

			continue;
		}

		Target = mo;
		return true;
	}


	return Target != none;
}

//==========================================================================
//
//	A_LookEx
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool A_LookEx(bool autoSetChase)
{
	Actor	targ;

	Threshold = 0;	// any shot will wake up
	pTargetVec = NULL;
	targ = Actor(Sector->SoundTarget);

	if (targ && targ.bShootable && (bIgnoreTeams || targ.Team != Team))
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForEnemy(false))
					return false;
			}
		}
	}
	else
	{
		if (!LookForEnemy(bLookAllAround))
			return false;
	}

	// go into chase state
	if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (autoSetChase)
		SetState(SeeState);
	return true;
}

//==========================================================================
//
//	A_ChaseEx
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool A_ChaseEx(bool autoSetIdle)
{
	float delta;

	if (ReactionCount)
	{
		ReactionCount--;
	}

	//  Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	if (!pTargetVec)
	{
		Error("A_ChaseEx: called with pTargetVec = NULL");
		return false;
	}

	//if (!pTargetVec && Target)
	//	pTargetVec = &Target.Origin;

	bInCombat = true;
	// modify target threshold
	if (Threshold)
	{
		if (!pTargetVec || (Target && Target.Health <= 0))
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (Target && !Target.bShootable)
	{
		//[CW] ??
		/*// look for a new target
		if (LookForEnemy(true))
		{
			return true;	// got a new target
		}*/
		if (autoSetIdle)
		{
			SetState(IdleState);
			bInCombat = false;
		}
		return false;
	}

	if (LineSpecialGameInfo(Level.Game).bNightmareFastChase &&
		Level.Game.fastparm)
	{
		// Monsters move faster in nightmare mode
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	// turn towards movement direction if not there yet
	if (MoveDir < 8)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	// do not attack twice in a row
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm)
		{
			NewChaseDirEx();
		}
		return true;
	}

	// check for melee attack
	if (MeleeState && CheckMeleeRange())
	{
		if (AttackSound)
		{
			PlaySound(AttackSound, CHAN_WEAPON);
		}
		SetState(MeleeState);
		return true;
	}

	// check for missile attack
	if (MissileState)
	{
		if (Level.Game.fastparm || !MoveCount)
		{
			if (CheckMissileRange())
			{
				SetState(MissileState);
				bJustAttacked = true;
				return true;
			}
		}
	}

	//[CW] ??
	/*// possibly choose another target
	if (Level.Game.netgame && !Threshold)
	{
		if (!CanSee(Target))
		{
			if (LookForEnemy(true))
				return true;	// got a new target
		}
	}*/

	// chase towards enemy
	if (--MoveCount < 0 || !StepMove())
	{
		NewChaseDirEx();
	}

	// make active sound
	if (P_Random() < 3)
	{
		PlayActiveSound();
	}

	return true;
}

//=============================================================================
//
// NewChaseDirEx
//
//	[KoraxRPG] Advanced AI
//
//=============================================================================

void NewChaseDirEx()
{
	float deltax;
	float deltay;

	if (!pTargetVec)
	{
		Error("NewChaseDirEx: called with pTargetVec = NULL");
		return;
	}

	deltax = pTargetVec->x - Origin.x;
	deltay = pTargetVec->y - Origin.y;

	tmtrace_t tmtrace;
	CheckRelPosition(&tmtrace, Origin);

	// Try to move away from a dropoff
	if (FloorZ - tmtrace.DropOffZ > MaxDropoffHeight &&
		Origin.z <= FloorZ && !bDropOff && !bOnMobj && !bFloat)
	{
		avoiddropoff_t a;
		// We call CheckDropoff here to determine if the
		// bounding box actually needs to be used below
		CheckDropOff(&a);

		if (a.deltax || a.deltay)
		{
			// [Graf Zahl] I have changed TryMove to only apply this logic when
			// being called from here. bAavoidingDropoff activates the code that
			// allows monsters to move away from a dropoff. This is different from
			// MBF which requires unconditional use of the altered logic and therefore
			// forcing a massive change in the monster behavior to use this.

			// use different dropoff movement logic in TryMove
			bAvoidingDropoff = true;
			DO_NewChaseDir(a.deltax, a.deltay);
			bAvoidingDropoff = false;
		
			// If moving away from dropoff, set movecount to 1 so that
			// small steps are taken to get monster away from dropoff.
			MoveCount = 1;
			return;
		}
	}
	DO_NewChaseDir(deltax, deltay);
}

//==========================================================================
//
//	CanReach
//
//	[KoraxRPG] Advanced AI
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional Entity TargetEntity)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!TargetEntity)
	{
		TargetEntity = none;
	}
	
	canreach = DoCanReachPathTraverse(TargetPos, &CRTRData);
	
	if (TargetEntity)
	{
		if (CRTRData.linetarget != TargetEntity)
			return false;
	}
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							ReachTraverse::reach_traverse_data_t * pCRTRData)
{
	intercept_t * in;
	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pCRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
				return false;


			// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			if (p_sector->ceilingheight < pCRTRData->prev_sector->floorheight - Height ||
				p_sector->floorheight + Height > pCRTRData->prev_sector->ceilingheight)
				// will stuck in low ceiling...
				return false;
			if (p_sector->floorheight > pCRTRData->prev_sector->floorheight + MaxStepHeight)
				// will stuck in high floor
				return false;
			if (p_sector->floorheight < pCRTRData->prev_sector->floorheight - MaxDropoffHeight)
				// must avoid dropoffs
				return false;

			pCRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
			////if (in->Thing.Origin.z <= CRTRData.prev_sector->floorheight + Height)
				pCRTRData->linetarget = Actor(in->Thing);
		}
	}

	return true;
}

//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================

final void AutoUseHealth(int saveHealth)
{
	int i;
	int count;

	Inventory normal = FindInventory(ArtiHealth);
	Inventory super = FindInventory(ArtiSuperHealth);
	if ((Level.Game.gameskill == sk_baby) && normal &&
		(normal.Amount * 25 >= saveHealth))
	{
		// Use quartz flasks
		count = (saveHealth + 24) / 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
			if (!(--normal.Amount))
			{
				// Used last of a type - compact the artifact list
				normal.Destroy();
			}
		}
	}
	else if (super && super.Amount * 100 >= saveHealth)
	{
		// Use mystic urns
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			if (!(--super.Amount))
			{
				// Used last of a type - compact the artifact list
				super.Destroy();
			}
		}
	}
	else if ((Level.Game.gameskill == sk_baby)
		&& ((super ? super.Amount * 100 : 0) +
		(normal ? normal.Amount * 25 : 0) >= saveHealth))
	{
		// Use mystic urns and quartz flasks
		count = (saveHealth + 24) / 25;
		saveHealth -= count * 25;
		for (i = 0; normal && i < count; i++)
		{
			Health += 25;
			if (!(--normal.Amount))
			{
				// Used last of a type - compact the artifact list
				normal.Destroy();
				normal = none;
			}
		}
		count = (saveHealth + 99) / 100;
		for (i = 0; super && i < count; i++)
		{
			Health += 100;
			// The same as in HERETIC
			if (!(--super.Amount))
			{
				// Used last of a type - compact the artifact list
				super.Destroy();
				super = none;
			}
		}
	}
	Player.Health = Health;
}

//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================

final void SpawnDirt(float radius)
{
	float angle;
	TVec org;
	class<Actor> dtype;
	Actor dirt;

	angle = 360.0 * Random();
	org.x = Origin.x + radius * cos(angle);
	org.y = Origin.y + radius * sin(angle);
	org.z = Origin.z + Random() * 2.0 + 1.0;
	switch (P_Random() % 6)
	{
	case 0:
		dtype = Dirt1;
		break;
	case 1:
		dtype = Dirt2;
		break;
	case 2:
		dtype = Dirt3;
		break;
	case 3:
		dtype = Dirt4;
		break;
	case 4:
		dtype = Dirt5;
		break;
	case 5:
		dtype = Dirt6;
		break;
	}
	dirt = Spawn(dtype, org);
	if (dirt)
	{
		dirt.Velocity.z = Random() * 4.0 * 35.0;
	}
}


//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

final TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//===========================================================================
//
//	PlayerIsMorphed
//
//===========================================================================

bool PlayerIsMorphed()
{
	return !!Player(Player).MorphTime;
}

//==========================================================================
//
//	GetBaseViewHeight
//
//==========================================================================

float GetBaseViewHeight()
{
	return Player::VIEWHEIGHT;
}

//============================================================================
//
//  A_PlayerScream
//
//============================================================================

final void A_PlayerScream()
{
	// Handle the different player death screams
	if (Velocity.z <= -39.0 * 35.0)
	{
		// Falling splat
		PlaySound('*splat', CHAN_VOICE);
	}
	else if (Health > -50)
	{
		// Normal death sound
		PlaySound('*death', CHAN_VOICE);
	}
	else if (Health > -100)
	{
		// Crazy death sound
		PlaySound('*crazydeath', CHAN_VOICE);
	}
	else
	{
		// Extreme death sound
		PlaySound('*xdeath', CHAN_VOICE);
	}
}

//============================================================================
//
//	A_FreezeDeath
//
//============================================================================

final void A_FreezeDeath()
{
	StateTime = 2.0 + Random() * 8.0 + Random() * 8.0;
	bSolid = true;
	bShootable = true;
	bNoBlood = true;
	bPushable = true;
	bTelestomp = true;
	bSlide = true;
	bNoPassMobj = false;
	bDynamicLight = false;
	Height *= 4.0;
	PlaySound('FreezeDeath', CHAN_VOICE);
	Translation = 0;	//no translation
	bIceCorpse = true;

	if (bIsPlayer)
	{
		Player(Player).DamageFlash = 0.0;
		Player(Player).BonusFlash = 0.0;
	}
	else
	{
		if (bMonster && Special)
		{
			// Initiate monster death actions
			Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
				Args[3], Args[4], NULL, 0, self);
		}
	}
}

//============================================================================
//
//  A_FreezeDeathChunks
//
//============================================================================

final void A_FreezeDeathChunks()
{
	int i;
	Actor A;

	if (Length(Velocity) > 1.0)
	{
		StateTime = 3.0;
		return;
	}
	PlaySound('FreezeShatter', CHAN_VOICE);

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (!Level.Game.Players[i])
			continue;
		if (!Level.Game.Players[i].bSpawned)
			continue;
		PlayerEx(Level.Game.Players[i]).ParticleEffect(256, LineSpecialLevelInfo::pt_static, HexenLevelInfo::pt_ice_chunk,
			Origin + vector(Radius, Radius, Height), 0.8, vector(64.0, 64.0, 96.0), 0.6, 6.0,
			80.0, RGB(127, 130, 240), 10.0, 16.0);
	}
	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		A.SetState(GetStatePlus(A.IdleState, P_Random() % 3));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		A.SetState(GetStatePlus(A.IdleState, P_Random() % 3));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	if (bIsPlayer)
	{
		// attach the player's view to a chunk of ice
		A = Spawn(IceChunkHead, Origin + vector(0.0, 0.0, Player::VIEWHEIGHT));
		A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
		A.Player = Player;
		A.bIsPlayer = true;
		Player = none;
		bIsPlayer = false;
		A.Health = Health;
		A.Angles.yaw = Angles.yaw;
		A.Player.MO = A;
		A.Angles.pitch = 0.0;
	}
	RemoveFromTIDList();
	SetState(FindState('FreeTargMobj'));
	bHidden = true;
}

//==========================================================================
//
//  A_AddPlayerCorpse
//
//==========================================================================

final void A_AddPlayerCorpse()
{
	if (HexenLevelInfo(Level).bodyqueslot >= HexenLevelInfo::BODYQUESIZE)
	{
		// Too many player corpses - remove an old one
		HexenLevelInfo(Level).bodyque[HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo::BODYQUESIZE].Destroy();
	}
	HexenLevelInfo(Level).bodyque[HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo::BODYQUESIZE] = self;
	HexenLevelInfo(Level).bodyqueslot++;
}

//============================================================================
//
//  A_CheckBurnGone
//
//============================================================================

final void A_CheckBurnGone()
{
	if (Special2 == 666)
	{
		SetState(FindState('BurnGone'));
	}
}

//==========================================================================
//
//  A_QueueCorpse
//
//  Throw another corpse on the queue.
//
//==========================================================================

final void A_QueueCorpse()
{
	EntityEx corpse;

	if (HexenLevelInfo(Level).corpseQueueSlot >=
		HexenLevelInfo::CORPSEQUEUESIZE)
	{
		// Too many corpses - remove an old one
		corpse = HexenLevelInfo(Level).corpseQueue[
			HexenLevelInfo(Level).corpseQueueSlot %
			HexenLevelInfo::CORPSEQUEUESIZE];
		if (corpse)
			corpse.Destroy();
	}
	HexenLevelInfo(Level).corpseQueue[
		HexenLevelInfo(Level).corpseQueueSlot %
		HexenLevelInfo::CORPSEQUEUESIZE] = self;
	HexenLevelInfo(Level).corpseQueueSlot++;
}

//============================================================================
//
//  A_DeQueueCorpse
//
//  Remove a mobj from the queue (for resurrection)
//
//============================================================================

final void A_DeQueueCorpse()
{
	int slot;

	for (slot = 0; slot < HexenLevelInfo::CORPSEQUEUESIZE; slot++)
	{
		if (HexenLevelInfo(Level).corpseQueue[slot] == self)
		{
			HexenLevelInfo(Level).corpseQueue[slot] = none;
			break;
		}
	}
}

//==========================================================================
//
//  A_PigPain
//
//==========================================================================

final void A_PigPain()
{
	A_Pain();
	if (Origin.z <= FloorZ)
	{
		Velocity.z = 3.5 * 35.0;
	}
}

//==========================================================================
//
//	A_PlayerBurnScream
//
//==========================================================================

final void A_PlayerBurnScream()
{
	PlaySound('*burndeath', CHAN_VOICE);
}

//**************************************************************************
//
//
//	[KoraxRPG] Actor Condtions
//
//
//**************************************************************************

//==========================================================================
//
//	CastCondition
//
//==========================================================================

ActorCondition CastCondition(class<ActorCondition> ConditionClass, bool accumulative,
											Actor Instigator, int level, float life_duration)
{
	if (!Conditions)
	{
		Conditions = LinkedList(SpawnObject(LinkedList));
		if (!Conditions) return none;
	}

	ActorCondition AC;

	if (accumulative)
		AC = GetCondition(ConditionClass, Instigator, level);

	if (AC)
	{
		float limit;

		if (AC.MaxAccumulatedLifePerLevel < 0.0)
			AC.LifeTime += life_duration;
		else
		{
			limit = AC.MaxAccumulatedLifePerLevel * itof(AC.Level);
			if (AC.LifeTime >= limit)
				AC = none;	// [CW] to mark that no condition is added
			else
			{
				AC.LifeTime += life_duration;
				if (AC.LifeTime > limit)
					AC.LifeTime = limit;
			}
		}
	}
	else
	{
		AC = ActorCondition(Spawn(ConditionClass));

		if (AC)
		{
			LinkedReferer ref = LinkedReferer(SpawnObject(LinkedReferer));
			ref.refObject = AC;
			AC.Referer = ref;
			Conditions.Add(ref);

			AC.ARecepient = self;
			AC.EInstigator = Instigator;
			AC.Level = level;
			AC.LifeDuration = life_duration;
			AC.Activate();
		}
	}

	if (AC)
	{
		if (Player && AC.CastMessage)
			Player.cprint(AC.CastMessage);
		if (AC.CastSound)
			PlaySound(AC.CastSound, CHAN_VOICE);
	}

	return AC;
}

//==========================================================================
//
//	GetCondition
//
//==========================================================================

ActorCondition GetCondition(class<ActorCondition> ConditionClass, Actor Instigator, int level)
{
	if (Conditions && Conditions.refHead)
	{
		LinkedReferer acref = LinkedReferer(Conditions.refHead);
		while (acref)
		{
			ActorCondition ac = ActorCondition(acref.refObject);
			if (ac.Class == ConditionClass &&
					ac.EInstigator == Instigator &&
					ac.Level == level)
			{
				return ac;
			}
			acref = LinkedReferer(acref.refNext);
		};
	}

	return none;
}

//==========================================================================
//
//	NotifyConditions
//
//==========================================================================

void NotifyConditions(int notification, EntityEx E, int param)
{
	if (Conditions && Conditions.refHead)
	{
		LinkedReferer acref = LinkedReferer(Conditions.refHead);
		while (acref)
		{
			ActorCondition(acref.refObject).Notify(notification, E, param);
			acref = LinkedReferer(acref.refNext);
		};
	}
}


states
{
Crunch:
	GIBS A -1
	Stop
}

defaultproperties
{
	SoundClass = 'fighter';
	CrunchSound = '*splat';

	// KoraxRPG
	bIgnoreTeams = false;
	Team = 0;
}
