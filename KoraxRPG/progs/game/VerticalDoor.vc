//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class VerticalDoor : SectorMover;

int			Type;
float		TopHeight;
float		Speed;
int			Direction;	// 1 = up, 0 = waiting at top, -1 = down
float		TopWait;	// tics to wait at the top (keep in case a door going down is reset)
float		TopTime;	// when it reaches 0, start going down

float		BotDist;
float		OldFloorDist;

TVec		BotSpot;

int			LightTag;

//==========================================================================
//
//	Init
//
//==========================================================================

void Init(sector_t* InSector, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int InType)
{
	float		Height;
	TVec		Spot;

	Sector = InSector;
	Sector->CeilingData = self;

	Type = InType;
	Speed = itof(Arg2) * 35.0 / 8.0;
	TopWait = itof(Arg3) / 35.0;
	switch (Type)
	{
	case DOOREV_Close:
		Height = Level.FindLowestCeilingSurrounding(Sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(Sector->ceiling.normal, Spot);
		Direction = -1;
		SectorStartSequence(Sector, GetSeqTrans(Sector->seqType, SEQ_Door));
		break;

	case DOOREV_CloseWaitOpen:
		LightTag = Arg4;
		TopHeight = Sector->ceiling.dist;
		TopWait *= 4.0;
		Direction = -1;
		SectorStartSequence(Sector, GetSeqTrans(Sector->seqType, SEQ_Door));
		break;

	case DOOREV_Raise:
	case DOOREV_RaiseLocked:
	case DOOREV_Open:
		//	Get light tag depending on type.
		if (Type == DOOREV_Open)
		{
			LightTag = Arg3;
		}
		else if (Type == DOOREV_Raise)
		{
			LightTag = Arg4;
		}
		else
		{
			LightTag = Arg5;
			Type = DOOREV_Raise;
		}

		//HACK delay 0 means open
		if (Type == DOOREV_Raise && !Arg3)
		{
			Type = DOOREV_Open;
		}

		Height = Level.FindLowestCeilingSurrounding(Sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(Sector->ceiling.normal, Spot);
		Direction = 1;
		SectorStartSequence(Sector, GetSeqTrans(Sector->seqType, SEQ_Door));
		break;

	case DOOREV_RaiseIn5Mins:
		Direction = 2;
		Height = Level.FindLowestCeilingSurrounding(Sector, &Spot);
		Spot.z = Height - 4.0;
		TopHeight = DotProduct(Sector->ceiling.normal, Spot);
		TopTime = 5.0 * 60.0;
		break;
	}

	Height = Level.FindHighestFloorPoint(Sector, &BotSpot);
	BotDist = DotProduct(vector(BotSpot.x, BotSpot.y, Height),
		Sector->ceiling.normal);
	OldFloorDist = Sector->floor.dist;
}

//==========================================================================
//
//	InitCloseIn30
//
//	Spawn a door that closes after 30 seconds
//
//==========================================================================

void InitCloseIn30(sector_t* InSector)
{
	float		Height;

	Sector = InSector;
	Sector->CeilingData = self;

	Direction = 0;
	Type = DOOREV_Raise;
	Speed = 70.0;
	TopTime = 30.0;
	Height = Level.FindHighestFloorPoint(Sector, &BotSpot);
	BotDist = DotProduct(vector(BotSpot.x, BotSpot.y, Height),
		Sector->ceiling.normal);
	OldFloorDist = Sector->floor.dist;
	TopHeight = Sector->ceiling.dist;
	LightTag = 0;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

bool ReUse(int InType, line_t* Line, Actor Thing)
{
	if (InType == DOOREV_Raise && Type == DOOREV_Raise)
	{
		// ONLY FOR "RAISE" DOORS, NOT "OPEN"s
		if (Direction == -1)
		{
			Direction = 1;	// go back up
			return true;
		}
		else if (GET_SPAC(Line->flags) != SPAC_PUSH)
			// [RH] activate push doors don't go back down when you
			//		run into them (otherwise opening them would be
			//		a real pain).
		{
			if (!Thing || !Thing.bIsPlayer || Thing.Player.bIsBot)
				return false;	// JDC: bad guys never close doors
			Direction = -1;	// start going down immediately
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	int res;

	if (Sector->floor.dist != OldFloorDist)
	{
		OldFloorDist = Sector->floor.dist;
		BotDist = DotProduct(Sector->ceiling.normal, vector(BotSpot.x,
			BotSpot.y, GetPlanePointZ(&Sector->floor, BotSpot)));
	}

	switch (Direction)
	{
	case 0:	// WAITING
		TopTime -= deltaTime;
		if (TopTime <= 0.0)
			switch (Type)
			{
			case DOOREV_Raise:
				Direction = -1;	// time to go back down
				SectorStartSequence(Sector, GetSeqTrans(Sector->seqType, SEQ_Door));
				break;
			case DOOREV_CloseWaitOpen:
				Direction = 1;
				SectorStartSequence(Sector, GetSeqTrans(Sector->seqType, SEQ_Door));
				break;
			default:
				break;
			}
		break;

	case 2:
		//  INITIAL WAIT
		TopTime -= deltaTime;
		if (TopTime <= 0.0)
		{
			TopTime = 0.0;
			switch (Type)
			{
			case DOOREV_RaiseIn5Mins:
				Direction = 1;
				Type = DOOREV_Raise;
				SectorStartSequence(Sector, GetSeqTrans(Sector->seqType, SEQ_Door));
				break;
			}
		}
		break;

	case -1:	// DOWN
		res = MovePlane(Sector, Speed * deltaTime, BotDist, false, 1,
			Direction, false);

		// killough 10/98: implement gradual lighting effects
		if (LightTag && TopHeight != -Sector->floor.dist)
		{
			EV_LightTurnOnPartway(LightTag, (Sector->ceiling.dist +
				Sector->floor.dist) / (TopHeight + Sector->floor.dist));
		}

		if (res == RES_PASTDEST)
		{
			SectorStopSequence(Sector);
			switch (Type)
			{
			case DOOREV_Raise:
			case DOOREV_Close:
				Finished();	// unlink and free
				break;
			case DOOREV_CloseWaitOpen:
				Direction = 0;
				TopTime = TopWait;
				break;
			default:
				break;
			}
		}
		else if (res == RES_CRUSHED)
		{
			switch (Type)
			{
			case DOOREV_Close:	// DON'T GO BACK UP!
				break;
			default:
				Direction = 1;
				break;
			}
		}
		break;

	case 1:	// UP
		res = MovePlane(Sector, Speed * deltaTime, TopHeight, false, 1,
			Direction, false);

		//	killough 10/98: implement gradual lighting effects
		if (LightTag && TopHeight != -Sector->floor.dist)
		{
			EV_LightTurnOnPartway(LightTag, (Sector->ceiling.dist +
				Sector->floor.dist) / (TopHeight + Sector->floor.dist));
		}

		if (res == RES_PASTDEST)
		{
			SectorStopSequence(Sector);
			switch (Type)
			{
			case DOOREV_Raise:
				Direction = 0;	// wait at top
				TopTime = TopWait;
				break;
			case DOOREV_Open:
			case DOOREV_CloseWaitOpen:
				Finished();	// unlink and free
				break;
			default:
				break;
			}
		}
		break;
	}
}

//==========================================================================
//
//  EV_LightTurnOnPartway
//
//	killough 10/98
//
//	Turn sectors tagged to line lights on to specified or max neighbor level
//
//	Passed the tag of sector(s) to light and a light level fraction between
// 0 and 1. Sets the light to min on 0, max on 1, and interpolates
// in-between. Used for doors with gradual lighting effects.
//
//==========================================================================

void EV_LightTurnOnPartway(int Tag, float Frac)
{
	sector_t*	temp;
	sector_t*	sector;
	int			i;
	int			j;
	int			bright;
	int			min;

	if (Frac < 0.0)
		Frac = 0.0;
	else if (Frac > 1.0)
		Frac = 1.0;

	//	Search all sectors for ones with same tag as activating line
	i = -1;
	for (i = FindSectorFromTag(Tag, i); i >= 0;
		i = FindSectorFromTag(Tag, i))
	{
		sector = &GLevel.Sectors[i];
		bright = 0;
		min = sector->params.lightlevel;

		for (j = 0; j < sector->linecount; j++)
		{
			temp = Level.getNextSector(sector->lines[j], sector);
			if (temp)
			{
				if (temp->params.lightlevel > bright)
				{
					bright = temp->params.lightlevel;
				}
				if (temp->params.lightlevel < min)
				{
					min = temp->params.lightlevel;
				}
			}
		}
		sector->params.lightlevel = ftoi(Frac * itof(bright) +
			(1.0 - Frac) * itof(min));
	}
}

defaultproperties
{
}

//**************************************************************************
//
//  $Log$
//  Revision 1.3  2006/02/06 19:43:04  firebrand_kh
//  Added latest Vavoom changes
//
//  Revision 1.7  2006/02/05 18:50:55  dj_jl
//  Moved common utils to level info class or built-in.
//
//  Revision 1.6  2005/12/27 22:22:28  dj_jl
//  Created level info class, moved action special handling to it.
//
//  Revision 1.5  2005/11/20 12:40:55  dj_jl
//  Implemented support for sound sequence extensions.
//
//  Revision 1.4  2005/03/01 14:39:33  dj_jl
//  Big update of line specials.
//
//  Revision 1.3  2005/01/25 17:45:15  dj_jl
//  Constants for common line specials
//  Updated special utilites.
//
//  Revision 1.2  2004/11/22 07:36:27  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.1  2002/10/26 16:32:27  dj_jl
//  New style of defining classes.
//
//**************************************************************************
