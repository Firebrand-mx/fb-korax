
//**************************************************************************
//
//
//	[KoraxRPG] Advanced AI
//
//
//**************************************************************************

//==========================================================================
//
//	SetTeam
//
//==========================================================================

void SetTeam(int team)
{
	Team = team;

	//
	// TODO: special code needed for Intelligent Actors
	//

	if (bCombatant && Target && Actor(Target).Team == Team)
	{
		Target = none;
		SetState(IdleState);
	}

	Actor A;
	foreach AllThinkers(Actor, A)
	{
		if (A.bCombatant && A.Target == self && A.Team == Team)
		{
			A.Target = none;
			// A.SetState(IdleState);
		}
	}
}

//==========================================================================
//
//	CanSense
//
//==========================================================================

bool CanSense(EntityEx Other)
{
	return bSenseAlways || CanSee(Other);
}

//==========================================================================
//
//	CanBeAttacked
//
//	Returns TRUE if Actor can be attacked by any other actor. Method
//	does not check if attack can have any success, so Invulnerable actors
//	still count as attackable.
//
//==========================================================================

bool CanBeAttacked()
{
	return bShootable && !bNonShootable &&
		bCombatant /* [CW] may be ignored in some cases? */ &&
		Health > 0;
}

//==========================================================================
//
//	IsOkayToTarget
//
//==========================================================================

bool IsOkayToTarget(Actor Other)
{
	return Other && Other.bShootable && !Other.bNonShootable && !Other.bDormant && !Other.bNeverTarget &&
		!Other.bInvulnerable /* [CW] questionable */ &&
		Other.bCombatant /* [CW] may be ignored in some cases? */ &&
		Other.Health > 0 &&
		(bIgnoreTeams || Team != Actor(Other).Team);
}


const float	DEFAULT_THREAT_VICINITY			= MISSILERANGE;

//==========================================================================
//
//	LookForEnemy
//
//==========================================================================

bool LookForEnemy(bool allaround, optional bool nearest,
					optional TVec At, optional float maxdist, optional Actor ExcludeActor)
{
	Actor		mo;
	float		an;
	float		dist;
	float		min_dist;

	if (!specified_nearest)
		nearest = true;

	if (!specified_At)
		At = Origin;

	if (!specified_maxdist)
		maxdist = DEFAULT_THREAT_VICINITY;

	Actor NewTarget;
	min_dist = -1.0;

	foreach AllThinkers(Actor, mo)
	{
		if (mo == self)
			continue;	// self

		if (mo == ExcludeActor)
			continue;

		/* if (!mo.bShootable || mo.bNonShootable || mo.bDormant || mo.bInvulnerable || mo.bNeverTarget)
			continue;

		if (mo.Health <= 0)
			continue;	// dead

		// [CW] Do not allow to target other actors than either monsters or players
		if (!mo.bIsPlayer && !mo.bMonster)
			continue;

		if (!bIgnoreTeams && (Team == Actor(mo).Team))
			continue;	// friendly
		*/
		if (!IsOkayToTarget(mo))
			continue;

		// TODO: extra parameter to ignore this
		if (!CanSense(mo))
			continue;	// out of senses

		if (Length(mo.GetCentre() - At) > maxdist)
			continue;

		if (P_Random() > 200)
			continue;	// sometimes skip

		if (!bSenseAlways && !allaround && At == Origin)
		{
			dist = DistTo(mo);
			an = AngleMod360(atan2(mo.Origin.y - Origin.y,
				mo.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				//dist = DistTo(mo);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		dist = Length(mo.GetCentre() - At);

		if (nearest)
		{
			if (min_dist < 0.0 || min_dist > dist)
			{
				min_dist = dist;
				NewTarget = mo;
			}

			continue;
		}
		else
		{
			NewTarget = mo;
		}

		break;
	}

	if (NewTarget)
		Target = NewTarget;
	return NewTarget != none;
}

//==========================================================================
//
//	CanReach
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional EntityEx TargetEntity,
			  // [CW] use these three to override default passability calculations
			  optional float MaxPassableStep,
			  optional float MaxPassableDropOff,
			  optional float MinPassableOpening,
			  optional bool bCanUseLines)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!specified_TargetEntity)
		TargetEntity = none;

	if (!specified_MaxPassableStep)
		MaxPassableStep = MaxStepHeight;
	if (!specified_MaxPassableDropOff)
		MaxPassableDropOff = MaxDropoffHeight;
	if (!specified_MinPassableOpening)
		MinPassableOpening = Height;
	
	canreach = DoCanReachPathTraverse(TargetPos, &CRTRData,
		MaxPassableStep, MaxPassableDropOff, MinPassableOpening, bCanUseLines);
	
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;
	
	if (canreach && TargetEntity)
	{
	//
		// [CW] CHECKME ---
		//
		//if (CRTRData.linetarget != TargetEntity)
		//	return false;

		// [FB]  3d Floor checks...
		float dist;
		if (TargetEntity.Origin.z > Origin.z)
		{
			dist = Origin.z + Height;

			if (TargetEntity.Origin.z > dist)
				return false;
		}
		if (TargetEntity.Origin.z <= Origin.z)
		{
			dist = Origin.z - (TargetEntity.Origin.z + TargetEntity.Height);
			// [FB] Always evaluate a positive distance
			dist = dist < 0.0 ? -dist : dist;

			if (dist > MaxPassableDropOff)
				return false;
		}
	}

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
// [FB] Added partial 3d floor support, needs to be checked and corrected...
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							ReachTraverse::reach_traverse_data_t * pCRTRData,
							float MaxPassableStep,
							float MaxPassableDropOff,
							float MinPassableOpening,
							bool bCanUseLines)
{
	intercept_t * in;

	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		//
		// [CW] For slope recognition
		float distance_bak;
		float distance_traced;		// distance traced total
		float distance_traced_last;	// distance traced last iteration

		pCRTRData->intercepted_once = true;

		distance_bak = distance_traced;
		distance_traced = Length(Origin - TargetPos) * in->frac;
		distance_traced_last = distance_traced - distance_bak;

		if (in->bIsALine)
		{
			sector_t * p_sector;
			TVec tracedir;
			TVec hit_point;
			opening_t* opening;	// [FB] For 3d floors
			float traceZ = Origin.z; // Z coordinate of the trace
			//
			// [CW] For slope recognition
			float slope_angle;

			// [CW] A unit vector determines the direction of tracing
			//		Needed to get the hit_point for each 2-sided line found
			tracedir = Normalise(TargetPos - Origin);
			tracedir.z = 0.0;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					(in->line->flags & ML_BLOCKEVERYTHING) ||
					!in->line->backsector)
				return false;

			// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			pCRTRData->prev_sector = p_sector;

			// [FB] partial 3d floor support...
			tracedir.x = cos(Angles.yaw);
			tracedir.y = sin(Angles.yaw);
			tracedir.z = FloorZ;
			hit_point = Origin + distance_traced * tracedir;
			hit_point.z = traceZ;
			opening = LineOpenings(in->line, hit_point);
			opening = FindOpening(opening, hit_point.z, hit_point.z + Height);

			// only valid openings
			if (!opening)
			{
				return false;
			}
			if ((opening->range <= MinPassableOpening) ||
				(opening->lowfloor - opening->bottom > MaxPassableStep) ||
				(opening->lowfloor - opening->bottom > MaxPassableDropOff))
				return false;

			// [CW] Now, when we have the best opening available, we must check
			//		if the best is actually the passable
			//
			// [CW]
			//
			//		From what I saw in engine code, -
			//		opening->top is the lowest ceiling between previous and next sector;
			//		opening->bottom is the highest floor between previous and next sector;
			//		opening->range is distance between opening->top and opening->bottom;
			//		opening->lowfloor is the lowest floor between previous and next sector;
			//

			//
			// [CW] Check floor planes for slopes
			//
			if (traceZ != opening->bottom && traceZ != opening->lowfloor)
			{
				// There is definitely a slope;
				// [FB] Checks for sloped floors on both sides
				if (
					(opening->floor->maxz <= opening->highceilingplane->minz &&
					opening->highceilingplane->minz >= opening->floor->minz)
					||
					(opening->lowfloorplane->maxz <= opening->ceiling->minz &&
					opening->ceiling->minz >= opening->floor->minz)
					)
				{
					// [FB] This is actually a slope, so calculate angles
					slope_angle = atan2(opening->bottom - traceZ, distance_traced_last);
				}

				// Check if slope angle is too high to ascend
				if (slope_angle >= 70.0)
				{
					return false;
				}

				// Make our "ghost" actor stand at the end of the slope
				traceZ = opening->bottom;
			}

			if ((opening->range < MinPassableOpening) // cannot fit through, do not bother
				||
				// OK, actor fits through...
				// so use traceZ to know which height is actor's "ghost" previous position
				(traceZ >= opening->bottom && ((traceZ - opening->bottom) > MaxPassableDropOff ||
					((opening->bottom - opening->lowfloor) > MaxPassableDropOff)))
					// drop from highest floor to lowest one is too much to accept it
				||
				(traceZ <= opening->lowfloor && ((opening->lowfloor - traceZ) > MaxPassableStep ||
					((opening->bottom - opening->lowfloor) > MaxPassableStep)))
					// raise from lowest floor to highest one is too much to step there
				)
			{
				return false;
			}
			
			// [FB] Check for ceiling slopes on both sides
			if (
				(opening->floor->minz <= opening->highceilingplane->maxz &&
				opening->highceilingplane->minz >= opening->floor->maxz)
				||
				(opening->lowfloorplane->minz <= opening->ceiling->maxz &&
				opening->ceiling->minz >= opening->floor->maxz)
				)
			{
				if (opening->highceilingplane->minz < Height ||
					opening->ceiling->minz < Height)
				{
					// [FB] We'll get stuck on this slope
					return false;
				}
			}
			// [FB] This should partially cover it...

			// [CW] Update height position;
			if (traceZ == opening->bottom)
				traceZ = opening->lowfloor;
			else
				traceZ = opening->bottom;
		}
		else
		{
			// TODO: check this precisely...
			pCRTRData->linetarget = Actor(in->Thing);
			
			if (!pCRTRData->linetarget)
				continue; // something out there

			if (pCRTRData->linetarget.bSolid)
			{
				if (pCRTRData->linetarget.Height > MaxPassableStep &&
						!pCRTRData->linetarget.bShootable)
					return false;
			}
		}
	}

	return true;
}

//==========================================================================
//
//	GetNearestEntity
//
//==========================================================================

final EntityEx GetNearestEntity(class<EntityEx> EClass, optional bool bReachable)
{
	EntityEx EE;
	EntityEx ee;
	float dist = -1.0;

	foreach AllThinkers(EClass, ee)
	{
		if (dist < 0.0 || Length(ee.Origin - Origin) < dist)
		{
			if (bReachable && !CanReach(ee.Origin))
				continue;
			EE = ee;
			dist = Length(ee.Origin - Origin);
		}
	}

	return EE;
}
