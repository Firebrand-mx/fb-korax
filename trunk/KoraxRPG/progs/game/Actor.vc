//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: Actor.vc 2707 2007-09-07 17:47:04Z dj_jl $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : ScriptedEntity
	abstract;

const float MORPHTIME 		= 40.0;
const float MAULATORTIME 	= 25.0;

const float TELEFOGHEIGHT	= 32.0;


//
// [KoraxRPG] Advanced behavior
//
bool			bXYAnchored;	// Stuck in floor/ceiling (won't move freely along X & Y axes)
bool			bZAnchored;		// Stuck in floor/ceiling (won't move freely along Z axis)

bool			bCombatant;		// fighting actor

bool			bLiving;		// has a chance to spawn "dying spirit" on death
								// [CW] currently just for fun, though it may get some sense later


//
// [KoraxRPG] Advanced AI
//
const float	DEFAULT_THREAT_VICINITY		= MISSILERANGE;

TVec *			pTargetVec;

const float HIGH_ALERTNESS				= 10.0;

float			Alertness;		// while alert, creature will look for enemies all around
bool			bIgnoreTeams;
int				Team;

//
// [KoraxRPG] Actor Conditions
//
LinkedList Conditions;


//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================

final int HITDICE(int a)
{
	return (1 + (P_Random() & 7)) * a;
}

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	// Remove from creature queue
	if (bMonster && bCorpse)
	{
		A_DeQueueCorpse();
	}

	::Destroyed();
}

//==========================================================================
//
//  Thrust3d
//
//	[CW] A three-dimensional vector variant of Thrust, that
//		 uses vector angles and single vector length.
//
//==========================================================================

void Thrust3d(float angle2d, float angle3, float move)
{
	Thrust(angle2d, move * cos(angle3));
	Velocity.z += move * sin(angle3) * 35.0;
}

//==========================================================================
//
//  Thrust3d2
//
//	[CW] Variant of Thrust3d, that allows explicit definition
//	     of horizontal and vertical velocities.
//
//==========================================================================

void Thrust3d2(float angle2d, float move2d, float move3)
{
	Thrust(angle2d, move2d);
	Velocity.z += move3 * 35.0;
}

//==========================================================================
//
//	Physics
//
//==========================================================================

bool Physics(float DeltaTime)
{
	if (bXYAnchored)
	{
		Velocity.x = 0.0;
		Velocity.y = 0.0;
	}

	if (bZAnchored)
		Velocity.z = 0.0;

	return ::Physics(DeltaTime);
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	if (Alertness > 0.0)
		Alertness -= deltaTime;
	::Tick(deltaTime);
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
	::Died(source, inflictor);

	NotifyConditions(ActorCondition::notify_RecepientDead, source, 0);

	if (bLiving && P_Random() < 33)
	{
		Spawn(DyingSpirit, Origin);
	}
}

//==========================================================================
//
//  OkayToSwitchTarget
//
//==========================================================================

bool OkayToSwitchTarget(EntityEx source)
{
	Alertness = HIGH_ALERTNESS;

	// [CW] TODO: add extra conditions here?
	if (source.IsA('Actor') && !bIgnoreTeams && Team == Actor(source).Team)
	{
		return false;
	}

	return ::OkayToSwitchTarget(source);
}

//==========================================================================
//
//	KilledByPlayer
//
//==========================================================================

void KilledByPlayer(EntityEx source)
{
	// Check for frag changes
	if (bIsPlayer)
	{
		if (source.Player.bIsBot)
		{
			Player(source.Player).Bot.Killed(self);
		}

		if (Player.bIsBot)
		{
			Player(Player).Bot.Died(Actor(source));
		}

		if (self == source)
		{
			// Self-frag
			Player.Frags--;
		}
		else
		{
			source.Player.Frags++;
		}
	}
}

//==========================================================================
//
//	PlayerKilled
//
//==========================================================================

void PlayerKilled(EntityEx source, EntityEx inflictor)
{
	// Count environment kills against you
	if (!source)
	{
		Player.Frags--;
	}
}

//**************************************************************************
//
//
//	[KoraxRPG] Advanced AI
//
//
//**************************************************************************

//==========================================================================
//
//	SetTeam
//
//==========================================================================

void SetTeam(int team)
{
	Team = team;

	//
	// TODO: special code needed for Intelligent Actors
	//

	if (bCombatant && Target && Actor(Target).Team == Team)
	{
		Target = none;
		SetState(IdleState);
	}

	Actor A;
	foreach AllThinkers(Actor, A)
	{
		if (A.bCombatant && A.Target == self && A.Team == Team)
		{
			A.Target = none;
			A.SetState(IdleState);
		}
	}
}

//==========================================================================
//
//	LookForEnemy
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool LookForEnemy(bool allaround, optional bool nearest,
					optional TVec At, optional float maxdist, optional Actor ExcludeActor)
{
	Actor		mo;
	float		an;
	float		dist;
	float		min_dist;

	if (!specified_nearest)
		nearest = true;

	if (!specified_At)
		At = Origin;

	if (!specified_maxdist)
		maxdist = DEFAULT_THREAT_VICINITY;

	if (!specified_ExcludeActor)
		ExcludeActor = none;

	Actor NewTarget;
	min_dist = -1.0;

	foreach AllThinkers(Actor, mo)
	{
		if (mo == self)
			continue;	// self

		if (mo == ExcludeActor)
			continue;

		if (!mo.bShootable || mo.bNonShootable || mo.bDormant || mo.bInvulnerable || mo.bNeverTarget)
			continue;

		if (mo.Health <= 0)
			continue;	// dead

		if (!bIgnoreTeams && (Team == mo.Team))
			continue;	// friendly

		// TODO: extra parameter to ignore this
		if (!CanSee(mo))
			continue;	// out of sight

		if (Length(mo.GetCentre() - At) > maxdist)
			continue;

		if (P_Random() > 200)
			continue;	// sometimes skip

		if (!allaround && At == Origin)
		{
			dist = DistTo(mo);
			an = AngleMod360(atan2(mo.Origin.y - Origin.y,
				mo.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				//dist = DistTo(mo);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		dist = Length(mo.GetCentre() - At);

		if (nearest)
		{
			if (min_dist < 0.0 || min_dist > dist)
			{
				min_dist = dist;
				NewTarget = mo;
			}

			continue;
		}
		else
			NewTarget = mo;

		break;
	}

	if (NewTarget)
		Target = NewTarget;
	return NewTarget != none;
}

//==========================================================================
//
//	A_LookEx
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool A_LookEx(bool autoSetChase)
{
	Actor	targ;

	Threshold = 0;	// any shot will wake up
	pTargetVec = NULL;
	targ = Actor(Sector->SoundTarget);

	if (targ && targ.bShootable && (bIgnoreTeams || Team != targ.Team))
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForEnemy(false || (Alertness > 0.0)))
					return false;
			}
		}
	}
	else
	{
		if (!LookForEnemy(bLookAllAround || (Alertness > 0.0)))
			return false;
	}

	Alertness = HIGH_ALERTNESS;

	// go into chase state
	if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (autoSetChase)
		SetState(SeeState);
	return true;
}

//==========================================================================
//
//	A_LookExAuto
//
//	[KoraxRPG]
//
//==========================================================================

final void A_LookExAuto()
{
	A_LookEx(true);
}

//==========================================================================
//
//	A_MoveEx
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool A_MoveEx(bool autoSetIdle, bool autoSetAttack, optional bool Evade)
{
	float delta;

	if (!specified_Evade)
		Evade = false;

	if (ReactionCount)
		ReactionCount--;

	//  Remove muzzle flash
	if (bMuzzleFlash)
		bMuzzleFlash = false;

	if (!pTargetVec)
	{
		Error("Actor::A_MoveEx: called with pTargetVec = NULL");
		return false;
	}

	bInCombat = true;
	// modify target threshold
	if (Threshold)
	{
		if (Target && Target.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (!Evade && Target && !Target.bShootable)
	{
		if (autoSetIdle)
		{
			SetState(IdleState);
			bInCombat = false;
		}
		else
			Target = none;

		return false;
	}

	if (LineSpecialGameInfo(Level.Game).bNightmareFastChase &&
		Level.Game.fastparm)
	{
		// Monsters move faster in nightmare mode
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	// do not attack twice in a row
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm)
		{
			NewChaseDirEx(Evade);
		}
		return true;
	}

	// check for melee attack
	if (autoSetAttack && !Evade && MeleeState && CheckMeleeRange())
	{
		if (AttackSound)
		{
			PlaySound(AttackSound, CHAN_WEAPON);
		}
		SetState(MeleeState);
		return true;
	}

	// check for missile attack
	if (autoSetAttack && MissileState)
	{
		if (Level.Game.fastparm || !MoveCount)
		{
			if (CheckMissileRange())
			{
				SetState(MissileState);
				bJustAttacked = true;
				return true;
			}
		}
	}

	// chase towards enemy
	if (--MoveCount < 0 || !StepMoveEx())
	{
		NewChaseDirEx(Evade);
	}

	// make active sound
	if (P_Random() < 3)
	{
		PlayActiveSound();
	}

	return true;
}

//==========================================================================
//
//  StepMoveEx
//
//  Move in the current direction, returns false if the move is blocked.
//
//	[CW] Contents use mostly from original StepMove;
//	     Difference is in making MoveDir unused, use free movement angle instead
//
//==========================================================================

final bool StepMoveEx()
{
	float tryx, deltax, origx;
	float tryy, deltay, origy;
	float maxmove;
	int steps;
	float xspeed;
	float yspeed;
	int i;
	bool try_ok;

	line_t *ld;
	int good;

	if (bBlasted)
		return true;

	// Instead of yanking non-floating monsters to the ground,
	// let gravity drop them down, unless they're moving down a step.
	if (!bNoGravity && Origin.z > FloorZ && !bOnMobj)
	{
		if (Origin.z > FloorZ + MaxStepHeight)
		{
			return false;
		}
		else
		{
			Origin.z = FloorZ;
		}
	}

	origx = Origin.x;
	origy = Origin.y;
	deltax = StepSpeed * cos(Angles.yaw);
	deltay = StepSpeed * sin(Angles.yaw);
	tryx = origx + deltax;
	tryy = origy + deltay;

	// Like P_XYMovement this should do multiple moves if the step size is too large
	maxmove = Radius;
	steps = 1;

	if (maxmove > 0.0)
	{ 
		xspeed = fabs(deltax);
		yspeed = fabs(deltay);

		if (xspeed > yspeed)
		{
			if (xspeed > maxmove)
			{
				steps = 1 + ftoi(xspeed / maxmove);
			}
		}
		else
		{
			if (yspeed > maxmove)
			{
				steps = 1 + ftoi(yspeed / maxmove);
			}
		}
	}

	try_ok = true;
	tmtrace_t tmtrace;
	for (i = 1; i < steps; i++)
	{
		try_ok = TryMoveEx(&tmtrace, vector(origx + (deltax / itof(steps * i)), origy +
					(deltay / itof(steps * i)), Origin.z));
		if (!try_ok)
			break;
	}

	// killough 3/15/98: don't jump over dropoffs:
	if (try_ok)
		try_ok = TryMoveEx(&tmtrace, vector(tryx, tryy, Origin.z));

	if (!try_ok)
	{
		// open any specials
		if (bFloat && tmtrace.bFloatOk)
		{
			// must adjust height
			if (Origin.z < tmtrace.FloorZ)
				Origin.z += FloatSpeed * Level.Game.frametime;
			else
				Origin.z -= FloatSpeed * Level.Game.frametime;

			// Check to make sure there's nothing in the way of the float
			if (TestMobjZ())
			{
				bInFloat = true;
				return true;
			}
		}

		if (!tmtrace.NumSpecHit)
			return false;

		//MoveDir = DI_NODIR;

		// if the special is not a door that can be opened, return false
		//
		// killough 8/9/98: this is what caused monsters to get stuck in
		// doortracks, because it thought that the monster freed itself
		// by opening a door, even if it was moving towards the doortrack,
		// and not the door itself.
		//
		// killough 9/9/98: If a line blocking the monster is activated,
		// return true 90% of the time. If a line blocking the monster is
		// not activated, but some other line is, return false 90% of the
		// time. A bit of randomness is needed to ensure it's free from
		// lockups, but for most cases, it returns the correct result.
		//
		// Do NOT simply return false 1/4th of the time (causes monsters to
		// back out when they shouldn't, and creates secondary stickiness).

		good = 0;
		while (tmtrace.NumSpecHit--)
		{
			ld = tmtrace.SpecHit[tmtrace.NumSpecHit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (LineSpecialLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_USE) ||
			    (bActivatePushWall && LineSpecialLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_PUSH)))
			{
				good |= ld == tmtrace.BlockingLine ? 1 : 2;//true;
			}
		}
		return good && ((Random() >= 203.0) ^ (good & 1));
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat && !bNoGravity)
	{
		if (Origin.z > FloorZ)
		{
			HitFloorType();
		}
		Origin.z = FloorZ;
	}
	return true;
}

//==========================================================================
//
//	A_ChaseExAuto
//
//	[KoraxRPG]
//
//==========================================================================

final void A_ChaseExAuto()
{
	A_MoveEx(true, true, false);
}

//==========================================================================
//
//	A_Evade
//
//	[KoraxRPG]
//
//==========================================================================

final void A_EvadeAuto()
{
	A_MoveEx(true, true, true);
}

//=============================================================================
//
// NewChaseDirEx
//
//	[KoraxRPG] Advanced AI
//
//=============================================================================

final void NewChaseDirEx(optional bool bEvade)
{
	float deltax;
	float deltay;

	if (!pTargetVec)
	{
		Error("NewChaseDirEx: called with pTargetVec = NULL");
		return;
	}

	if (!specified_bEvade)
		bEvade = false;

	if (bEvade)
	{
		deltax = Origin.x - pTargetVec->x;
		deltay = Origin.y - pTargetVec->y;
	}
	else
	{
		deltax = pTargetVec->x - Origin.x;
		deltay = pTargetVec->y - Origin.y;
	}

	tmtrace_t tmtrace;
	CheckRelPosition(&tmtrace, Origin);

	// Try to move away from a dropoff
	if (FloorZ - tmtrace.DropOffZ > MaxDropoffHeight &&
		Origin.z <= FloorZ && !bDropOff && !bOnMobj && !bFloat)
	{
		avoiddropoff_t a;
		// We call CheckDropoff here to determine if the
		// bounding box actually needs to be used below
		CheckDropOff(&a);

		if (a.deltax || a.deltay)
		{
			// [Graf Zahl] I have changed TryMove to only apply this logic when
			// being called from here. bAavoidingDropoff activates the code that
			// allows monsters to move away from a dropoff. This is different from
			// MBF which requires unconditional use of the altered logic and therefore
			// forcing a massive change in the monster behavior to use this.

			// use different dropoff movement logic in TryMove
			bAvoidingDropoff = true;
			DO_NewChaseDirEx(a.deltax, a.deltay);
			bAvoidingDropoff = false;
		
			// If moving away from dropoff, set movecount to 1 so that
			// small steps are taken to get monster away from dropoff.
			MoveCount = 1;
			return;
		}
	}
	DO_NewChaseDirEx(deltax, deltay);

	// If strafing, set movecount to strafecount so that old Doom
	// logic still works the same, except in the strafing part
	if (strafecount)
		MoveCount = strafecount;
}

//==========================================================================
//
//  DO_NewChaseDirEx
//
//	[CW] an attempt to make movement free of MoveDir presets (any angle)
//
//==========================================================================

final void DO_NewChaseDirEx(float deltax, float deltay)
{
	float oldang = Angles.yaw;
	Angles.yaw = atan2(deltay, deltax);
	if (!TryWalkEx())
	{
		if (P_Random() & 1)
		{
			Angles.yaw += 45.0 + Random() * 90.0;
		}
		else
		{
			Angles.yaw -= 45.0 + Random() * 90.0;
		}

		if (!TryWalkEx())
		{
			Angles.yaw = -oldang;
			TryWalkEx();
		}
	}
}

//==========================================================================
//
//  TryWalkEx
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

final bool TryWalkEx()
{
	if (!StepMoveEx())
	{
		return false;
	}
	MoveCount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//	CanReach
//
//	[KoraxRPG] Advanced AI
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional Entity TargetEntity)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!TargetEntity)
	{
		TargetEntity = none;
	}
	
	canreach = DoCanReachPathTraverse(TargetPos, &CRTRData);
	
	if (TargetEntity)
	{
		if (CRTRData.linetarget != TargetEntity)
			return false;
	}
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							ReachTraverse::reach_traverse_data_t * pCRTRData)
{
	intercept_t * in;
	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pCRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
				return false;


			// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			if (p_sector->ceilingheight < pCRTRData->prev_sector->floorheight - Height ||
				p_sector->floorheight + Height > pCRTRData->prev_sector->ceilingheight)
				// will stuck in low ceiling...
				return false;
			if (p_sector->floorheight > pCRTRData->prev_sector->floorheight + MaxStepHeight)
				// will stuck in high floor
				return false;
			if (p_sector->floorheight < pCRTRData->prev_sector->floorheight - MaxDropoffHeight)
				// must avoid dropoffs
				return false;

			pCRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
			////if (in->Thing.Origin.z <= CRTRData.prev_sector->floorheight + Height)
				pCRTRData->linetarget = Actor(in->Thing);
		}
	}

	return true;
}

//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================

final void AutoUseHealth(int saveHealth)
{
	int i;
	int count;

	Inventory normal = FindInventory(ArtiHealth);
	Inventory super = FindInventory(ArtiSuperHealth);
	if ((Level.Game.gameskill == sk_baby) && normal &&
		(normal.Amount * 25 >= saveHealth))
	{
		// Use quartz flasks
		count = (saveHealth + 24) / 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
			if (!(--normal.Amount))
			{
				// Used last of a type - compact the artifact list
				normal.Destroy();
			}
		}
	}
	else if (super && super.Amount * 100 >= saveHealth)
	{
		// Use mystic urns
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			if (!(--super.Amount))
			{
				// Used last of a type - compact the artifact list
				super.Destroy();
			}
		}
	}
	else if ((Level.Game.gameskill == sk_baby)
		&& ((super ? super.Amount * 100 : 0) +
		(normal ? normal.Amount * 25 : 0) >= saveHealth))
	{
		// Use mystic urns and quartz flasks
		count = (saveHealth + 24) / 25;
		saveHealth -= count * 25;
		for (i = 0; normal && i < count; i++)
		{
			Health += 25;
			if (!(--normal.Amount))
			{
				// Used last of a type - compact the artifact list
				normal.Destroy();
				normal = none;
			}
		}
		count = (saveHealth + 99) / 100;
		for (i = 0; super && i < count; i++)
		{
			Health += 100;
			// The same as in HERETIC
			if (!(--super.Amount))
			{
				// Used last of a type - compact the artifact list
				super.Destroy();
				super = none;
			}
		}
	}
	Player.Health = Health;
}

//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================

final void SpawnDirt(float radius)
{
	float angle;
	TVec org;
	class<Actor> dtype;
	Actor dirt;

	angle = 360.0 * Random();
	org.x = Origin.x + radius * cos(angle);
	org.y = Origin.y + radius * sin(angle);
	org.z = Origin.z + Random() * 2.0 + 1.0;
	switch (P_Random() % 6)
	{
	case 0:
		dtype = Dirt1;
		break;
	case 1:
		dtype = Dirt2;
		break;
	case 2:
		dtype = Dirt3;
		break;
	case 3:
		dtype = Dirt4;
		break;
	case 4:
		dtype = Dirt5;
		break;
	case 5:
		dtype = Dirt6;
		break;
	}
	dirt = Spawn(dtype, org);
	if (dirt)
	{
		dirt.Velocity.z = Random() * 4.0 * 35.0;
	}
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

final TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//===========================================================================
//
//	PlayerIsMorphed
//
//===========================================================================

bool PlayerIsMorphed()
{
	return !!Player(Player).MorphTime;
}

//==========================================================================
//
//	GetBaseViewHeight
//
//==========================================================================

float GetBaseViewHeight()
{
	return Player::VIEWHEIGHT;
}

//============================================================================
//
//  A_PlayerScream
//
//============================================================================

final void A_PlayerScream()
{
	// Handle the different player death screams
	if (Velocity.z <= -39.0 * 35.0)
	{
		// Falling splat
		PlaySound('*splat', CHAN_VOICE);
	}
	else if (Health > -50)
	{
		// Normal death sound
		PlaySound('*death', CHAN_VOICE);
	}
	else if (Health > -100)
	{
		// Crazy death sound
		PlaySound('*crazydeath', CHAN_VOICE);
	}
	else
	{
		// Extreme death sound
		PlaySound('*xdeath', CHAN_VOICE);
	}
}

//============================================================================
//
//	A_FreezeDeath
//
//============================================================================

final void A_FreezeDeath()
{
	StateTime = 2.0 + Random() * 8.0 + Random() * 8.0;
	bSolid = true;
	bShootable = true;
	bNoBlood = true;
	bPushable = true;
	bTelestomp = true;
	bSlide = true;
	bNoPassMobj = false;
	bDynamicLight = false;
	Height *= 4.0;
	PlaySound('FreezeDeath', CHAN_VOICE);
	Translation = 0;	//no translation
	bIceCorpse = true;

	if (bIsPlayer)
	{
		Player(Player).DamageFlash = 0.0;
		Player(Player).BonusFlash = 0.0;
	}
	else
	{
		if (bMonster && Special)
		{
			// Initiate monster death actions
			Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
				Args[3], Args[4], NULL, 0, self);
		}
	}
}

//============================================================================
//
//  A_FreezeDeathChunks
//
//============================================================================

final void A_FreezeDeathChunks()
{
	int i;
	Actor A;

	if (Length(Velocity) > 1.0)
	{
		StateTime = 3.0;
		return;
	}
	PlaySound('FreezeShatter', CHAN_VOICE);

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (!Level.Game.Players[i])
			continue;
		if (!Level.Game.Players[i].bSpawned)
			continue;
		PlayerEx(Level.Game.Players[i]).ParticleEffect(256, LineSpecialLevelInfo::pt_static, HexenLevelInfo::pt_ice_chunk,
			Origin + vector(Radius, Radius, Height), 0.8, vector(64.0, 64.0, 96.0), 0.6, 6.0,
			80.0, RGB(127, 130, 240), 10.0, 16.0);
	}
	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		A.SetState(GetStatePlus(A.IdleState, P_Random() % 3));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		A.SetState(GetStatePlus(A.IdleState, P_Random() % 3));
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	if (bIsPlayer)
	{
		// attach the player's view to a chunk of ice
		A = Spawn(IceChunkHead, Origin + vector(0.0, 0.0, Player::VIEWHEIGHT));
		A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
		A.Player = Player;
		A.bIsPlayer = true;
		Player = none;
		bIsPlayer = false;
		A.Health = Health;
		A.Angles.yaw = Angles.yaw;
		A.Player.MO = A;
		A.Angles.pitch = 0.0;
	}
	RemoveFromTIDList();
	SetState(FindState('FreeTargMobj'));
	bHidden = true;
}

//==========================================================================
//
//  A_AddPlayerCorpse
//
//==========================================================================

final void A_AddPlayerCorpse()
{
	if (HexenLevelInfo(Level).bodyqueslot >= HexenLevelInfo::BODYQUESIZE)
	{
		// Too many player corpses - remove an old one
		HexenLevelInfo(Level).bodyque[HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo::BODYQUESIZE].Destroy();
	}
	HexenLevelInfo(Level).bodyque[HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo::BODYQUESIZE] = self;
	HexenLevelInfo(Level).bodyqueslot++;
}

//============================================================================
//
//  A_CheckBurnGone
//
//============================================================================

final void A_CheckBurnGone()
{
	if (Special2 == 666)
	{
		SetState(FindState('BurnGone'));
	}
}

//==========================================================================
//
//  A_QueueCorpse
//
//  Throw another corpse on the queue.
//
//==========================================================================

final void A_QueueCorpse()
{
	EntityEx corpse;

	if (HexenLevelInfo(Level).corpseQueueSlot >=
		HexenLevelInfo::CORPSEQUEUESIZE)
	{
		// Too many corpses - remove an old one
		corpse = HexenLevelInfo(Level).corpseQueue[
			HexenLevelInfo(Level).corpseQueueSlot %
			HexenLevelInfo::CORPSEQUEUESIZE];
		if (corpse)
			corpse.Destroy();
	}
	HexenLevelInfo(Level).corpseQueue[
		HexenLevelInfo(Level).corpseQueueSlot %
		HexenLevelInfo::CORPSEQUEUESIZE] = self;
	HexenLevelInfo(Level).corpseQueueSlot++;
}

//============================================================================
//
//  A_DeQueueCorpse
//
//  Remove a mobj from the queue (for resurrection)
//
//============================================================================

final void A_DeQueueCorpse()
{
	int slot;

	for (slot = 0; slot < HexenLevelInfo::CORPSEQUEUESIZE; slot++)
	{
		if (HexenLevelInfo(Level).corpseQueue[slot] == self)
		{
			HexenLevelInfo(Level).corpseQueue[slot] = none;
			break;
		}
	}
}

//==========================================================================
//
//  A_PigPain
//
//==========================================================================

final void A_PigPain()
{
	A_Pain();
	if (Origin.z <= FloorZ)
	{
		Velocity.z = 3.5 * 35.0;
	}
}

//==========================================================================
//
//	A_PlayerBurnScream
//
//==========================================================================

final void A_PlayerBurnScream()
{
	PlaySound('*burndeath', CHAN_VOICE);
}

//**************************************************************************
//
//
//	[KoraxRPG] Actor Condtions
//
//
//**************************************************************************

//==========================================================================
//
//	CastCondition
//
//==========================================================================

ActorCondition CastCondition(class<ActorCondition> ConditionClass, bool accumulative,
											Actor Instigator, int level, float life_duration)
{
	if (!Conditions)
	{
		Conditions = LinkedList(SpawnObject(LinkedList));
		if (!Conditions) return none;
	}

	ActorCondition AC;

	if (accumulative)
		AC = GetCondition(ConditionClass, Instigator, level);

	if (AC)
	{
		float limit;

		if (AC.MaxAccumulatedLifePerLevel < 0.0)
			AC.LifeTime += life_duration;
		else
		{
			limit = AC.MaxAccumulatedLifePerLevel * itof(AC.Level);
			if (AC.LifeTime >= limit)
				AC = none;	// [CW] to mark that no condition is added
			else
			{
				AC.LifeTime += life_duration;
				if (AC.LifeTime > limit)
					AC.LifeTime = limit;
			}
		}
	}
	else
	{
		AC = ActorCondition(Spawn(ConditionClass));

		if (AC)
		{
			LinkedReferer ref = LinkedReferer(SpawnObject(LinkedReferer));
			ref.refObject = AC;
			AC.Referer = ref;
			Conditions.Add(ref);

			AC.ARecepient = self;
			AC.EInstigator = Instigator;
			AC.Level = level;
			AC.LifeDuration = life_duration;
			AC.Activate();
		}
	}

	if (AC)
	{
		if (Player && AC.CastMessage)
			Player.cprint(AC.CastMessage);
		if (AC.CastSound)
			PlaySound(AC.CastSound, CHAN_VOICE);
	}

	return AC;
}

//==========================================================================
//
//	GetCondition
//
//==========================================================================

ActorCondition GetCondition(class<ActorCondition> ConditionClass, Actor Instigator, int level)
{
	if (Conditions && Conditions.refHead)
	{
		LinkedReferer acref = LinkedReferer(Conditions.refHead);
		while (acref)
		{
			ActorCondition ac = ActorCondition(acref.refObject);
			if (ac.Class == ConditionClass &&
					ac.EInstigator == Instigator &&
					ac.Level == level)
			{
				return ac;
			}
			acref = LinkedReferer(acref.refNext);
		};
	}

	return none;
}

//==========================================================================
//
//	NotifyConditions
//
//==========================================================================

void NotifyConditions(int notification, EntityEx E, int param)
{
	if (Conditions && Conditions.refHead)
	{
		LinkedReferer acref = LinkedReferer(Conditions.refHead);
		while (acref)
		{
			ActorCondition(acref.refObject).Notify(notification, E, param);
			acref = LinkedReferer(acref.refNext);
		};
	}
}


states
{
Crunch:
	GIBS A -1
	Stop
}

defaultproperties
{
	SoundClass = 'fighter';
	CrunchSound = '*splat';
}
