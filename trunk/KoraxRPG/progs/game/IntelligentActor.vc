//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ## ###  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**				   ######  #####   ######
//**	               ##   ## ##  ## ##    ##
//**	     		   ##   ## ##  ## ##   
//**	               #####   #####  ##  ####
//**	     		   ## ###  ##     ###   ##
//**	     		   ##  ### ##      ######
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2008 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class IntelligentActor : Actor;

//
// [KoraxRPG] Advanced AI
//

const float ACCEPTABLE_WAYPOINT_VICINITY	= 96.0;
const float ACCEPTABLE_TASKLEADER_VICINITY	= 512.0;

enum
{
	THREATREACTION__NONE,			// do not react on any threat at all
	THREATREACTION__LOHEALTH,		// react only if damaged by thread source and health dropped below 1/3
	THREATREACTION__DAMAGE,			// react only if damaged by threat source (at any health)
	THREATREACTION__SEE,			// react on any seen threat in preset range (see Behavior.ThreatVicinity)
	THREATREACTION__DETECT			// react on any threat detected by any means in preset range
};

struct pawn_behavior_t
{
	int				ThreatReaction;
	float			ThreatVicinity;			// maximal distance of threat source to react on

	bool			bNoWanderDuringAttack;	// shoot enemy if possible without wandering around
	bool			bEvadeMelee;
	bool			bRunOnEvade;

	bool			bCanGroup;				// can join task leader
	bool			bCanBeTaskLeader;



	bool			bKnowFTargetPos;		// if TRUE, pawn knows current FTarget position.

	bool			bLostFTarget;			// if TRUE, pawn has just lost an FTarget,
											// i.e. he can not see it and/or reach him;
											// if both bKnowEnemyPos and bLostEnemy flags
											// are TRUE, this means that pawn can SEE FTarget,
											// but cannot REACH it
	int				LostFTargetTolerance;	// how long a pawn will try to find lost FTarget
											// until he finally decides to build new route
											// or retarget
											// (in times DoChase is called)
	int				LostFTargetTime;		// how much strokes left until route build/retarget



	bool			bNeverUseRoutes;		// obvious..
	bool			bBuildingRoute;				// 
	int				RouteBuildContinuesCount;	//
	int				RouteBuildIterationsCount;	//
	bool			bUsingRoute;			// if TRUE, pawn walks along the route
	int				RouteRebuildRate;		// how often this pawn rebuilds its
											// route from scratch
											// (lower value mean higher rate)
											// (in times DoChase is called)
	int				RouteRebuildRateLow;	// special rate used in case when pawn failed
											// to build a route; it should be at least a bit
											// lower than RouteRebuildRate (use higher value)
	int				RouteRebuildTime;		// how much strokes left until route rebuild
	//int				CheckFTargetPosRate;	// how often pawn checks its target's position
	//int				CheckFTargetPosTime;	// how much strokes left until target's position check
	float			FTargetPosChangeLimit;	// when target is beyond this range relative
											// to its previous known position, pawn should
											// rebuild the route;
											// (pawns with ranged attack may perhaps have higher values)
};

pawn_behavior_t		Behavior;

struct generic_target_t
{
	TVec		Pos;
	EntityEx	Thing;
	Node		Node;
};

generic_target_t	FGnTarget;			// final aim
generic_target_t	IGnTarget;			// immediate aim
TVec				LastKnownPosition;	// for moving targets

EntityEx			LastAttacker;	// the one attacked this IA last time


IntelligentActor	TaskLeader;



//
// [KoraxRPG] Actor Tasks
//

LinkedList		Tasks;
ActorTask		CurrentTask;

enum
{
	TASK_PRIORITY_ABSOLUTE		= 0,

	TASK_PRIORITY_THREAT_BASE	= 0,
	TASK_PRIORITY_THREAT_GRADE1	= 1,
	TASK_PRIORITY_THREAT_GRADE2	= 2,
	TASK_PRIORITY_THREAT_GRADE3	= 3,
	TASK_PRIORITY_THREAT_GRADE4	= 4
};

enum
{
	STATE_ACTION__NONE,
	STATE_ACTION__LOOK,
	STATE_ACTION__CHASE,
	STATE_ACTION__EVADE,
	STATE_ACTION__SPECIAL
};

const float		AI_ROUTINE_DELAY = 1.0;

float			AITime;
int				StateAction;


// [CW] Heh, my first delegate in VavoomC =)))
delegate bool DoMove(bool Evade, state AIdleState, state AMeleeState,
				  state AMissileState, bool PlayActive);


//==========================================================================
//
//	BeginPlay
//
//==========================================================================

void BeginPlay()
{
	::BeginPlay();
	DoMove = A_NormalDoMove;	// [CW] Assign a delegate to default method
}

//==========================================================================
//
//	Destroy
//
//==========================================================================

void Destroy()
{
	if (Tasks)
		Tasks.Destroy();
	if (CurrentRoute)
		CurrentRoute.Destroy();
	if (RouteList)
		RouteList.Destroy();
	::Destroy();
}

//==========================================================================
//
//  OkayToSwitchTarget
//
//==========================================================================

bool OkayToSwitchTarget(EntityEx source)
{
	LastAttacker = source;

	bool okaytoswitch = true;

	switch (Behavior.ThreatReaction)
	{
	case THREATREACTION__NONE:
		okaytoswitch = false; break;
	case THREATREACTION__LOHEALTH:
		if (Health > default.Health / 3)
			okaytoswitch = false;
		break;
	case THREATREACTION__DAMAGE:
		if (!LastAttacker)
			okaytoswitch = false;
		break;
	}

	okaytoswitch = okaytoswitch && ::OkayToSwitchTarget(source);

	//
	// [CW] We know that Damage method will set new Target itself,
	// so we have to set F & I generic target datas
	if (okaytoswitch)
	{
		//generic_target_t gnTarget;
		//gnTarget.Thing = source;
		//if (!CurrentTask)
		//	A_SetFinalTarget(&gnTarget);
		//  A_SetImmediateTarget(&gnTarget);
		A_OrderAttackThing(true,
			TASK_PRIORITY_THREAT_BASE +
					((Health <= default.Health / 3) ? THREATREACTION__LOHEALTH : THREATREACTION__DAMAGE),
			0.0, source);
	}

	return okaytoswitch;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
	if (Tasks)
		Tasks.Destroy();
	if (CurrentRoute)
		CurrentRoute.Destroy();
	if (RouteList)
		RouteList.Destroy();

	Tasks = none;
	CurrentRoute = none;
	RouteList = none;

	A_SetFinalTarget(NULL);
	A_SetImmediateTarget(NULL);

	::Died(source, inflictor);
}

//==========================================================================
//
//	A_AISetReflectiveInvulnerable
//
//==========================================================================

final void A_AISetReflectiveInvulnerable()
{
	StateAction = STATE_ACTION__SPECIAL;
	::A_SetReflectiveInvulnerable();
}

//==========================================================================
//
//	A_AIUnSetReflectiveInvulnerable
//
//==========================================================================

final void A_AIUnSetReflectiveInvulnerable()
{
	StateAction = STATE_ACTION__SPECIAL;
	::A_UnSetReflectiveInvulnerable();
}

//==========================================================================
//
//	A_AIResurrect
//
//==========================================================================

final void A_AIResurrect()
{
	::A_Resurrect();
	AITime = 0.0;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	::Tick(deltaTime);

	if (Health > 0)
	{

		if (Tasks && Tasks.refHead)
			ActorTask(Tasks.refHead).Tick(deltaTime);

		AITime -= deltaTime;
		if (AITime < 0.0)
		{
			/*// [CW] evil coder easter-egg... :))))))))
			if (P_Random() < 200 && P_Random() < 100 && P_Random() < 10 && P_Random() < 5 && P_Random() <= 1)
			{
				FatalError("I am tired of this stupid game... should we play tetris instead?");
				return;
			}*/

			if (Health <= 0 ||
					bDormant ||
					StateAction == STATE_ACTION__SPECIAL)
				AITime = 0.0;
			else
			{
				A_DoAI();
				AITime = AI_ROUTINE_DELAY;
			}
		}
	}
}

//============================================================================
//
//  A_NormalDoMove
//
//============================================================================

bool A_NormalDoMove(bool Evade, state AIdleState, state AMeleeState,
				  state AMissileState, bool PlayActive)
{
	return A_DoMove(Evade, false/*FastChase*/, AIdleState, AMeleeState, AMissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase/*NightmareFast*/, PlayActive);
}

//============================================================================
//
//  A_FastDoMove
//
//============================================================================

bool A_FastDoMove(bool Evade, state AIdleState, state AMeleeState,
				  state AMissileState, bool PlayActive)
{
	return A_DoMove(Evade, true/*FastChase*/, AIdleState, AMeleeState, AMissileState,
		true/*NightmareFast*/, PlayActive);
}


//**************************************************************************
//
//
//	[KoraxRPG] Advanced AI
//
//
//**************************************************************************

//==========================================================================
//
//	A_SetFinalTarget
//
//==========================================================================

void A_SetFinalTarget(generic_target_t * pGnTarget)
{
	if (pGnTarget)
	{
		Behavior.bKnowFTargetPos = true;
		FGnTarget.Thing = (pGnTarget->Thing && !pGnTarget->Thing.IsA('Node')) ? pGnTarget->Thing : none;
		FGnTarget.Node = Node((pGnTarget->Thing && pGnTarget->Thing.IsA('Node')) ? pGnTarget->Thing : none);
		FGnTarget.Pos = pGnTarget->Thing ? pGnTarget->Thing.GetCentre() : pGnTarget->Pos;
		LastKnownPosition = FGnTarget.Pos;
	}
	else
	{
		FGnTarget.Thing = none;
		FGnTarget.Node = none;
		FGnTarget.Pos = Origin;	// just in case
	}
}

//==========================================================================
//
//	A_SetImmediateTarget
//
//==========================================================================

void A_SetImmediateTarget(generic_target_t * pGnTarget)
{
	if (pGnTarget)
	{
		IGnTarget.Thing = (pGnTarget->Thing && !pGnTarget->Thing.IsA('Node')) ? pGnTarget->Thing : none;
		IGnTarget.Node = Node((pGnTarget->Thing && pGnTarget->Thing.IsA('Node')) ? pGnTarget->Thing : none);
		IGnTarget.Pos = pGnTarget->Thing ? pGnTarget->Thing.GetCentre() : pGnTarget->Pos;
	}
	else
	{
		IGnTarget.Thing = none;
		IGnTarget.Node = none;
		IGnTarget.Pos = Origin;	// just in case
	}
}

//==========================================================================
//
//	A_DoAI
//
//==========================================================================

void A_DoAI()
{
	if (StateAction == STATE_ACTION__CHASE)
		A_CheckThreat();
	DoTasks();
}

//==========================================================================
//
//	A_CheckThreat
//
//==========================================================================

void A_CheckThreat()
{
	bool bThreatened = false;

	switch (Behavior.ThreatReaction)
	{
	case THREATREACTION__NONE:
		break;
	default:
		// bEvadeMelee flag makes IA take evasive action if enemy is too close
		if (Behavior.bEvadeMelee)
		{
			EntityEx EThreat = none;
			if (Target && Length(Target.Origin - Origin) <= Target.MeleeRange * 3.0)
				EThreat = Target;
			else if (LastAttacker && LastAttacker != Target)
			{
				if ((Behavior.ThreatReaction == THREATREACTION__LOHEALTH && Health <= default.Health / 3 ||
						Behavior.ThreatReaction >= THREATREACTION__DAMAGE) &&
						Length(LastAttacker.Origin - Origin) <= LastAttacker.MeleeRange * 3.0)
					EThreat = LastAttacker;
			}

			if (EThreat && P_Random() < 150)
			{
				bThreatened = true;
				A_OrderEvadeThing(true, 0, 1.0 + Random() * 4.0, EThreat);
				break;
			}
		}

		if (Behavior.ThreatReaction >= THREATREACTION__DETECT)
		{
			if (!Target || !Threshold)
			{
				Actor targ = Actor(Sector->SoundTarget);
				// [CW] Do not allow to target other actors than either monsters or KRPGActors
				if (targ && !targ.IsA('KRPGActor') && !targ.bMonster)
					targ = none;
				if (targ && targ != Target &&
					targ.bShootable && !targ.bNeverTarget &&
					(bIgnoreTeams || Team != Actor(targ).Team))
				{
					float dist;
					if (Target)
					{
						float dt = DistTo(Target);
						dist = dt > Behavior.ThreatVicinity ? Behavior.ThreatVicinity : dt;
					}
					else
						dist = Behavior.ThreatVicinity;

					if (DistTo(targ) <= Behavior.ThreatVicinity)
					{
						Target = targ;
						Threshold = BASETHRESHOLD;
						// TODO: use Ambush flag?
						Alertness = HIGH_ALERTNESS;

						bThreatened = true;
						A_OrderAttackThing(true, TASK_PRIORITY_THREAT_BASE +
							CanSee(Target) ? THREATREACTION__SEE : THREATREACTION__DETECT, 0.0, Target);
						if (StateAction == STATE_ACTION__LOOK)
							SetState(SeeState);
						break;
					}
				}
			}
		}

		if (Behavior.ThreatReaction >= THREATREACTION__SEE)
		{
			if (!Target || !Threshold)
			{
				float dist;
				if (Target)
				{
					float dt = DistTo(Target);
					dist = dt > Behavior.ThreatVicinity ? Behavior.ThreatVicinity : dt;
				}
				else
					dist = Behavior.ThreatVicinity;
				
				if (LookForEnemy(bLookAllAround || (Alertness > 0.0), true, GetCentre(), dist, Actor(Target)))
				{
					Alertness = HIGH_ALERTNESS;

					bThreatened = true;
					dprint("%i orders itself AttackThing %i with priority %i", self, Target,
						TASK_PRIORITY_THREAT_BASE + Behavior.ThreatReaction);
					A_OrderAttackThing(true, TASK_PRIORITY_THREAT_BASE + THREATREACTION__SEE, 0.0, Target);
					if (StateAction == STATE_ACTION__LOOK)
						SetState(SeeState);
					break;
				}
			}
		}
	}

	LastAttacker = none;

	if (bThreatened)
	{
		if (SightSound && StateAction == STATE_ACTION__LOOK)
		{
			if (bBoss)
			{
				// Full volume
				PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
			}
			else
			{
				PlaySound(SightSound, CHAN_VOICE);
			}
		}
		else if (StateAction == STATE_ACTION__CHASE)
		{
			PlayActiveSound();
		}
	}
}

//==========================================================================
//
//	A_LookAI
//
//==========================================================================

final void A_LookAI()
{
	// TODO: check, do we need to reset FGn & IGn targets when SeeState was just set

	StateAction = STATE_ACTION__LOOK;

	Threshold = 0;	// any shot will wake up
	Target = none;
	pTargetVec = NULL;

	A_CheckThreat();
}

//==========================================================================
//
//	A_ChaseAI
//
//==========================================================================

final void A_ChaseAI()
{
	StateAction = STATE_ACTION__CHASE;

	// Update known info about target position, if this is a moving target
	if (FGnTarget.Thing)
	{
		if (CanSense(FGnTarget.Thing) || Sector->SoundTarget == FGnTarget.Thing)
		{
			Behavior.bKnowFTargetPos = true;
			LastKnownPosition = FGnTarget.Thing.GetCentre();
		}
		else
		{
			Behavior.bKnowFTargetPos = false;
		}
	}

	if (!Behavior.bNeverUseRoutes)
		DoRoute();

	// [CW] This looks a bit clumsy, perhaps should modify later..
	// ( Then again, may be not. (c) Korax )
	if (FGnTarget.Thing && !Behavior.bUsingRoute)
		IGnTarget.Pos = LastKnownPosition;

	if (Behavior.bUsingRoute && IGnTarget.Node)
		pTargetVec = &IGnTarget.Node.Origin;
	else if (TaskLeader)
		pTargetVec = &TaskLeader.Origin;
	else
		pTargetVec = &IGnTarget.Pos;

	if (CurrentTask)
	{
		if (CurrentTask.Order == ActorTask::ORDER__EVADEPOS ||
			CurrentTask.Order == ActorTask::ORDER__EVADETHING)
		{
			if (Behavior.bRunOnEvade)
				Speed *= 2.0;
			//A_MoveEx(false, true, true);
			if (DoMove)
				DoMove(true, none, MeleeState, MissileState, true);
			if (Behavior.bRunOnEvade)
				Speed /= 2.0;
			return;
		}
	}

	if (/*A_MoveEx(false, true)*/DoMove && DoMove(false, none, MeleeState, MissileState, true))
	{
		// [CW] Still has Target to attack
	}
	else
	{
		//
		// [CW] No current Target, think out what to do next
		//

		if (!CurrentTask && (IGnTarget.Thing == FGnTarget.Thing || IGnTarget.Pos == FGnTarget.Pos))
			// we have to check Thing and Pos in case Thing is 'none' in both I & F
		{
			// Final target gone, kill the route if any, prepare for new task
			A_CleanRoutes();
			A_SetFinalTarget(NULL);
			A_SetImmediateTarget(NULL);
			bInCombat = false;
			SetState(IdleState);
		}
		else
		{
			// Final target is still there, go for it
			if (Behavior.bUsingRoute)
			{
				if (!CurrentRoute)
				{
					Error("InteligentActor::A_ChaseAI: CurrentRoute reference is not set to an object while bUsingRoute flag is TRUE");
					return;
				}
				IGnTarget.Thing = none;
				IGnTarget.Node = CurrentRoute.Nodes[RouteWayIndex];
				IGnTarget.Pos = IGnTarget.Node.Origin;
			}
			else
			{
				A_SetImmediateTarget(&FGnTarget);
			}
		}
	}
}

//**************************************************************************
//
//
//	[KoraxRPG] Actor Tasks
//
//
//**************************************************************************

//==========================================================================
//
//  A_SetThreatReaction
//
//==========================================================================

void A_SetThreatReaction(int Reaction, float Vicinity)
{
	Behavior.ThreatReaction = Reaction;
	Behavior.ThreatVicinity = Vicinity;
}

//==========================================================================
//
//  A_OrderCancelAll
//
//==========================================================================

void A_OrderCancelAll()
{
	if (Tasks)
	{
		Tasks.DestroyAll();
		CurrentTask = none;

		AITime = 0.0;

		if (StateAction != STATE_ACTION__LOOK)
			SetState(IdleState);
	}
}

//==========================================================================
//
//  A_OrderCancelCurrent
//
//==========================================================================

void A_OrderCancelCurrent()
{
	if (Tasks && Tasks.refHead)
	{
		Tasks.refHead.Destroy();
		CurrentTask = none;

		AITime = 0.0;

		if (StateAction != STATE_ACTION__LOOK)
			SetState(IdleState);
	}
}

//==========================================================================
//
//  A_IssueOrder
//
//==========================================================================

ActorTask A_IssueOrder(bool situative, int order, int priority, float duration)
{
	if (Health <= 0)
		return none;

	if (!Tasks)
	{
		Tasks = LinkedList(SpawnObject(LinkedList));
		if (!Tasks)
			return none;
	}
	else if (situative && CurrentTask)
	{
		if (CurrentTask.Priority < priority)
			return none;
		if (CurrentTask.bSituative && CurrentTask.Priority >= priority)
			CurrentTask.Destroy();
	}

	ActorTask AT = ActorTask(SpawnObject(ActorTask));

	if (AT)
	{
		AT.bSituative = situative;
		AT.Order = order;
		AT.Priority = priority;
		AT.Duration = duration;
		AT.Time = duration;

		Tasks.Add(AT);

		AITime = 0.0;
	}

	return AT;
}

//==========================================================================
//
//  A_OrderAttackAll
//
//==========================================================================

void A_OrderAttackAll(bool situative, int priority, float duration)
{
	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__ATTACKALL, priority, duration);
	
	if (AT)
		AT.bTargetMustBeAlive = true;
}

//==========================================================================
//
//  A_OrderAttackThing
//
//==========================================================================

void A_OrderAttackThing(bool situative, int priority, float duration, EntityEx Thing)
{
	if (!Thing)
	{
		Error("IntelligentActor::A_OrderAttackThing : Thing reference not set to an instance of an object");
		return;
	}

	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__ATTACKTHING, priority, duration);
	
	if (AT)
	{
		AT.bTargetMustBeAlive = true;

		AT.GnTarget.Pos = Thing.Origin;
		AT.GnTarget.Thing = Thing;
	}
}

//==========================================================================
//
//  A_OrderStandStill
//
//==========================================================================

void A_OrderStandStill(bool situative, int priority, float duration)
{
	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__STANDSTILL, priority, duration);
}

//==========================================================================
//
//  A_OrderFollowThing
//
//==========================================================================

void A_OrderFollowThing(bool situative, int priority, float duration, EntityEx Thing)
{
	if (!Thing)
	{
		Error("IntelligentActor::A_OrderFollowThing : Thing reference not set to an instance of an object");
		return;
	}

	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__FOLLOW, priority, duration);
	
	if (AT)
	{
		AT.bTargetMustBeAlive = true;

		AT.GnTarget.Pos = Thing.Origin;
		AT.GnTarget.Thing = Thing;
	}
}

//==========================================================================
//
//  A_OrderEvadeThing
//
//==========================================================================

void A_OrderEvadeThing(bool situative, int priority, float duration, EntityEx Thing)
{
	if (!Thing)
	{
		Error("IntelligentActor::A_OrderEvadeThing : Thing reference not set to an instance of an object");
		return;
	}

	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__EVADETHING, priority, duration);
	
	if (AT)
	{
		AT.bTargetMustBeAlive = true;

		AT.GnTarget.Pos = Thing.Origin;
		AT.GnTarget.Thing = Thing;
	}
}

//==========================================================================
//
//  A_OrderEvadePos
//
//==========================================================================

void A_OrderEvadePos(bool situative, int priority, float duration, TVec position)
{
	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__EVADEPOS, priority, duration);

	if (AT)
		AT.GnTarget.Pos = position;
}

//==========================================================================
//
//  A_OrderWalkTo
//
//==========================================================================

void A_OrderWalkTo(bool situative, int priority, float duration, TVec position)
{
	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__WALKTO, priority, duration);
	
	if (AT)
		AT.GnTarget.Pos = position;
}

//==========================================================================
//
//  A_OrderPatrol2Pt
//
//==========================================================================

void A_OrderPatrol2Pt(bool situative, int priority, float duration, TVec position1, optional TVec position2)
{
	if (!specified_position2)
		position2 = Origin;

	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__PATROL2PT, priority, duration);
	
	if (AT)
	{
		AT.GnTarget.Pos = position1;
		AT.NextPos = position2;
	}
}

//==========================================================================
//
//  A_OrderPatrolPath
//
//==========================================================================

void A_OrderWalkPath(bool situative, bool Patrol, bool Looped,
					 int priority, float duration, int PathIndex, int NodeIndex, optional bool BackDir)
{
	if (!Node)
	{
		Error("IntelligentActor::A_OrderWalkPath : FirstNode reference not set to an instance of an object");
		return;
	}

	bool bFound = false;
	PathNode FirstNode = none;

	foreach AllThinkers(PathNode, FirstNode)
	{
		if (FirstNode.Args[PathNode::ARG__PATHINDEX] == PathIndex &&
			FirstNode.Args[PathNode::ARG__NODEINDEX] == NodeIndex)
		{
			bFound = true;
			break;
		}
	}

	if (!bFound)
		return;

	if (!specified_BackDir)
		BackDir = false;

	ActorTask AT = A_IssueOrder(situative,
									Patrol ? (	Looped ? ActorTask::ORDER__PATROLLOOP :	ActorTask::ORDER__PATROLPATH)
									: ActorTask::ORDER__WALKPATH,
									priority, duration);
	
	if (AT)
	{
		AT.GnTarget.Node = FirstNode;
		AT.GnTarget.Pos = FirstNode.Origin;
		AT.Direction = BackDir;
	}
}

//==========================================================================
//
//  A_OrderWander
//
//==========================================================================

void A_OrderWander(bool situative, int priority, float duration, optional TVec position, optional float radius)
{
	ActorTask AT = A_IssueOrder(situative, ActorTask::ORDER__WANDER, priority, duration);

	if (AT)
	{
		if (!specified_position)
			position = Origin;
		if (!specified_radius)
			radius = 0.0;

		AT.GnTarget.Pos = position;
		AT.Radius = radius;
	}
}

//==========================================================================
//
//	DoTasks
//
//==========================================================================

void DoTasks()
{
	if (Tasks)
	{
		bool taskCompleted = false;

		if (CurrentTask && CurrentTask.CheckCompleted())
		{
			if (CurrentTask.Duration > 0.0 && CurrentTask.Time <= 0.0)
				CurrentTask.Order = ActorTask::ORDER__NONE;

			taskCompleted = true;
			switch (CurrentTask.Order)
			{
			case ActorTask::ORDER__PATROL2PT:
				{
					TVec v = CurrentTask.GnTarget.Pos;
					CurrentTask.GnTarget.Pos = CurrentTask.NextPos;
					CurrentTask.NextPos = v;
				}
				break;
			case ActorTask::ORDER__WALKPATH:
			case ActorTask::ORDER__PATROLPATH:
			case ActorTask::ORDER__PATROLLOOP:
				{
					PathNode PN;
					if (CurrentTask.Direction)
						PN = PathNode(CurrentTask.GnTarget.Node).BW;
					else
						PN = PathNode(CurrentTask.GnTarget.Node).FW;

					if (!PN)
					{
						if (CurrentTask.Order == ActorTask::ORDER__WALKPATH)
							CurrentTask.Destroy();
						else
						{
							if (CurrentTask.Order == ActorTask::ORDER__PATROLPATH)
							{
								CurrentTask.Direction = !CurrentTask.Direction;
								if (CurrentTask.Direction)
									PN = PathNode(CurrentTask.GnTarget.Node).BW;
								else
									PN = PathNode(CurrentTask.GnTarget.Node).FW;
							}
							else
							{
								if (CurrentTask.Direction)
									PN = PathNode(CurrentTask.GnTarget.Node).GetPathTail();
								else
									PN = PathNode(CurrentTask.GnTarget.Node).GetPathHead();
							}
						}
					}

					if (PN)
					{
						CurrentTask.GnTarget.Node = PN;
						CurrentTask.GnTarget.Pos = PN.Origin;
					}
				}
				break;
			case ActorTask::ORDER__ATTACKALL:
				bIgnoreTeams = default.bIgnoreTeams;
				CurrentTask.GnTarget.Thing = none;
				break;
			default:
				CurrentTask.Destroy();
				break;
			};

			CurrentTask = none;
		}

		if (Tasks.refHead)
		{
			//
			// TODO: Handle priorities
			//
			ActorTask AT = ActorTask(Tasks.refHead);
			ActorTask at = ActorTask(Tasks.refHead);
			while (at.refNext)
			{
				at = ActorTask(at.refNext);
				if (at.Priority < AT.Priority)
					AT = at;
			};

			AT.MoveInFront();			

			//
			// Perform first-priority task
			//
			PerformTask(ActorTask(Tasks.refHead));
		}
		else if (taskCompleted)
		{
			if (StateAction != STATE_ACTION__LOOK)
			{
				SetState(IdleState);
			}
		}
	}
}

//==========================================================================
//
//	PerformTask
//
//==========================================================================

void PerformTask(ActorTask AT)
{
	ActorTask OldTask = CurrentTask;
	CurrentTask = AT;

	AT.Owner = self;

	switch (AT.Order)
	{
	case ActorTask::ORDER__STANDSTILL:
		{
			if (AT != OldTask)
			{
				if (StateAction != STATE_ACTION__LOOK)
					SetState(IdleState);
			}
		}
		break;
	case ActorTask::ORDER__ATTACKTHING:
	case ActorTask::ORDER__ATTACKALL:
		{
			if (AT != OldTask)
			{
				if (AT.GnTarget.Thing)
				{
					Target = EntityEx(AT.GnTarget.Thing); // FIXME
				}
				else
				{
					bIgnoreTeams = true;
					LookForEnemy(true, true);
				}

				if (Target)
				{
					Threshold = BASETHRESHOLD;
					AT.GnTarget.Thing = Target;
					A_SetFinalTarget(&AT.GnTarget);
					A_SetImmediateTarget(&AT.GnTarget);
					if (StateAction != STATE_ACTION__CHASE)
						SetState(SeeState);
				}
				else
				{
					if (StateAction != STATE_ACTION__LOOK)
						SetState(IdleState);
				}
			}
		}
		break;
	case ActorTask::ORDER__FOLLOW:
		if (AT != OldTask)
		{
			A_SetFinalTarget(&AT.GnTarget);
			A_SetImmediateTarget(&AT.GnTarget);
			if (StateAction != STATE_ACTION__CHASE)
				SetState(SeeState);
		}
		break;
	case ActorTask::ORDER__EVADEPOS:
	case ActorTask::ORDER__EVADETHING:
		if (AT.GnTarget.Thing)
			pTargetVec = &AT.GnTarget.Thing.Origin;
		else
			pTargetVec = &AT.GnTarget.Pos;

		if (AT != OldTask)
		{
			if (StateAction != STATE_ACTION__EVADE)
			{
				state EvState = FindState('Evade');

				if (EvState && StateAction != STATE_ACTION__EVADE)
					SetState(EvState);
				else if (StateAction != STATE_ACTION__CHASE)
					SetState(SeeState);

			/*{
				if (Behavior.bRunOnEvade)
					StepSpeed *= 2.0;
				A_MoveEx(false, true);
				if (Behavior.bRunOnEvade)
					StepSpeed /= 2.0;
			}*/
			}
		}

		break;
	case ActorTask::ORDER__WALKTO:
	case ActorTask::ORDER__WALKPATH:
	case ActorTask::ORDER__PATROL2PT:
	case ActorTask::ORDER__PATROLPATH:
	case ActorTask::ORDER__PATROLLOOP:
		{
			if (AT != OldTask)
			{
				A_SetFinalTarget(&AT.GnTarget);
				A_SetImmediateTarget(&AT.GnTarget);
				if (StateAction != STATE_ACTION__CHASE)
					SetState(SeeState);
			}
		}
		break;
	case ActorTask::ORDER__WANDER:
		{
			if (AT != OldTask)
			{
				generic_target_t gt;
				// Set next random point
				if ((!CurrentTask.Radius ||
					Length(Origin - CurrentTask.GnTarget.Pos) < CurrentTask.Radius) &&
					P_Random() < 64)
				{
					A_OrderStandStill(false, CurrentTask.Priority, 1.5 + Random() * 8.0);
					if (StateAction != STATE_ACTION__LOOK)
						SetState(IdleState);
					break;
				}
				else
				{
					if (CurrentTask.Radius)
					{
						gt.Pos.x = CurrentTask.GnTarget.Pos.x + (Random() - 0.5) * CurrentTask.Radius;
						gt.Pos.y = CurrentTask.GnTarget.Pos.y + (Random() - 0.5) * CurrentTask.Radius;
						gt.Pos.z = CurrentTask.GnTarget.Pos.z;
					}
					else
					{
						do
						{
							gt.Pos.x = Origin.x + (Random() - 0.5) * 256.0;
							gt.Pos.y = Origin.y + (Random() - 0.5) * 256.0;
							gt.Pos.z = Origin.z;
						}
						while (!CanReach(gt.Pos, none));
					}
				}
				
				CurrentTask.NextPos = gt.Pos;
				A_SetFinalTarget(&gt);
				A_SetImmediateTarget(&gt);
				if (StateAction != STATE_ACTION__CHASE)
					SetState(SeeState);
			}
		}
		break;
	}

	return;
}



//**************************************************************************
//
//
//	[KoraxRPG] Route Management
//
//
//**************************************************************************

const int			RouteBuildContinuesLimit = 16;
const int			RouteBuildIterationsLimit = 16;

Node				CurrentNode;		// a node this pawn is currently linked with


LinkedList			RouteList;		// used during waypoints building
Route				CurrentRoute;	// route (list of waypts) currently used
int					RouteWayIndex;	// Index of the waypoint pawn currently goes to

//==========================================================================
//
//	A_CleanRoutes
//
//==========================================================================

void A_CleanRoutes()
{
	Behavior.bBuildingRoute = false;
	Behavior.bUsingRoute = false;

	Behavior.RouteBuildContinuesCount = 0;
	Behavior.RouteBuildIterationsCount = 0;
	Behavior.RouteRebuildTime = 0;

	if (RouteList)
	{
		RouteList.Destroy();
		RouteList = none;
	}
	if (CurrentRoute)
	{
		CurrentRoute.Destroy();
		CurrentRoute = none;
	}
}

//==========================================================================
//
//	DoRoute
//
//==========================================================================

void DoRoute()
{
	if (!KRPGLevelInfo(Level).bNodeGraphBuild)
		return;

	// update timers
	if (Behavior.RouteRebuildTime > 0)
		Behavior.RouteRebuildTime--;
	//if (Behavior.bUsingRoute && Behavior.CheckFTargetPosTime > 0)
	//	Behavior.CheckFTargetPosTime--;
	if (Behavior.bLostFTarget && Behavior.LostFTargetTime > 0)
		Behavior.LostFTargetTime--;

	//
	// [CW]
	//
	// Now, here's the task: IA may use route method to reach not only
	// things (entity objects), but custom map positions as well.
	// We must remember this all the way 'round here.
	// Also, important - FGnTarget should be used here as a final target,
	// IGnTarget is to set up next node, Entity::Target is no use here at all.
	//
	// If FGnTarget.Thing is set, FGnTarget.Pos is used to store the target
	// thing position at certain moments of time only, this is needed to
	// check if target has moved far away from it's previous position.
	//
	//

	
	if (	FGnTarget.Thing ?
		(Behavior.bKnowFTargetPos && CanReach(FGnTarget.Thing.Origin, FGnTarget.Thing)) :
		CanReach(FGnTarget.Pos, none)	)
	{
		//print("canreach");
		if (FGnTarget.Thing && (Behavior.bLostFTarget || Behavior.bUsingRoute))
		{
			//print("Target is reachable!");
			Behavior.bLostFTarget = false;
		}
		TaskLeader = none;
		A_CleanRoutes();
		// Set immediate target
		IGnTarget.Thing = FGnTarget.Thing;
		IGnTarget.Node = Node((FGnTarget.Thing && FGnTarget.Thing.IsA('Node')) ? FGnTarget.Thing : none);
		IGnTarget.Pos = FGnTarget.Thing ? FGnTarget.Thing.Origin : FGnTarget.Pos;
		return;
	}
	else if (TaskLeader)
	{
		if (TaskLeader.Health > 0 &&
			(TaskLeader.FGnTarget.Thing == FGnTarget.Thing ||
				!TaskLeader.FGnTarget.Thing && TaskLeader.FGnTarget.Pos == FGnTarget.Pos))
		{
			if (CanReach(TaskLeader.Origin, none))
			{
				IGnTarget.Node = none;
				return;
			}

			Node N = FindAcceptableTargetNode(TaskLeader.Origin, none, true);
			if (N)
			{
				Behavior.bUsingRoute = true;
				IGnTarget.Node = N;
				return;
			}
		}
		TaskLeader = none;
	}
	else if (Behavior.bUsingRoute)
	{
		//print("use route, checkpostime = %i", Behavior.CheckFTargetPosTime);
		///////// If check target pos timer run out, pawn should reconsider its target position
		//////////if (FGnTarget.Thing && Behavior.CheckFTargetPosTime <= 0)
		{
			//print("checking enemy movement delta...");
			// If enemy moved away too far from his previous stored position,
			// update that position and force rebuild route
			if (Length(LastKnownPosition - FGnTarget.Pos) > Behavior.FTargetPosChangeLimit)
			{
				//print("Target moved too far away, must remake route");
				Behavior.RouteRebuildTime = 0;
				FGnTarget.Pos = LastKnownPosition;
			}
			//else
			//	Behavior.CheckFTargetPosTime = Behavior.CheckFTargetPosRate;

			//FGnTarget.Pos = LastKnownPosition;
		}

		if (Behavior.RouteRebuildTime > 0)
		{
			// check target route waypoint vicinity
			AcceptTargetNode();
			return;
		}
	}
	else/* if (FGnTarget.Thing)*/
	{
		if (Behavior.bLostFTarget)
		{
			//print("still lost ftarget %i, must rebild %i", Behavior.LostFTargetTime, Behavior.RouteRebuildTime);
			if (Behavior.LostFTargetTime > 0 || Behavior.RouteRebuildTime > 0)
				return;
		}
		else
		{
			//print("Set lost ftarget");
			Behavior.bLostFTarget = true;
			Behavior.LostFTargetTime = Behavior.LostFTargetTolerance;
			return;
		}
	}

	// Try get a task leader and follow him
	if (Behavior.bCanGroup)
	{
		if (TaskLeader || JoinTaskLeader())
			return;
	}

	// Well, it looks like it is right time for pawn to build a route
	if (FGnTarget.Thing)
	{
		if (Behavior.bKnowFTargetPos)
			BuildRoute(FGnTarget.Thing.Origin, FGnTarget.Thing);
		else
			BuildRoute(LastKnownPosition, none);
	}
	else
		BuildRoute(FGnTarget.Pos, none);
}

//==========================================================================
//
//	JoinTaskLeader
//
//==========================================================================

bool JoinTaskLeader()
{
	IntelligentActor IA;
	float dist;
	float min_dist = -1.0;

	TaskLeader = none;
	foreach AllThinkers(IntelligentActor, IA)
	{
		if (IA != self && IA != FGnTarget.Thing &&
			IA.Behavior.bCanBeTaskLeader && !IA.TaskLeader &&
			IA.Health > 0)
		{
			if (IA.FGnTarget.Thing == FGnTarget.Thing ||
				!IA.FGnTarget.Thing && IA.FGnTarget.Pos == FGnTarget.Pos)
			{
				dist = DistTo(IA);
				if (dist <= ACCEPTABLE_TASKLEADER_VICINITY && (min_dist < 0.0 || dist < min_dist))
				{
					if (CanSee(IA) && CanReach(IA.Origin))
					{
						min_dist = dist;
						TaskLeader = IA;
					}
				}
			}
		}
	}

	return TaskLeader != none;
}

//==========================================================================
//
//	BuildRoute
//
//	Tries to build a route using nodes.
//	AimActor is optional.
//
//==========================================================================

void BuildRoute(TVec AimPos, EntityEx AimEntity)
{
	int i;

	/*if (Behavior.bBuildingRoute)
		print("Try continue build route");
	else
		print("Try build route");*/

	Behavior.bUsingRoute = false;

	if (!Behavior.bBuildingRoute)
	{
		CurrentNode = FindNearestReachableNode();
		if (CurrentNode == none)
		{
			//print("no current node");
			return;			// no luck
		}

		//print("CurrentNode = %i", CurrentNode.TID);

		FGnTarget.Node = FindAcceptableTargetNode(AimPos, AimEntity, false);

		if (FGnTarget.Node == none)
		{
			//print("no final target node");
			return;				// no luck
		}
		
		//print("Final Target node = %i", FGnTarget.Node.TID);
	}

	if (BuildWaypoints(CurrentNode, FGnTarget.Node))
	{
		// succeeded, route was build, so set next path node to go to

		if (CurrentRoute)
		{
			Behavior.bUsingRoute = true;
			//Behavior.CheckFTargetPosTime = Behavior.CheckFTargetPosRate;

			/*//// DEBUG -------------------------- DEBUG
			print("succeeded build route, TID = %i", TID);
			int ii;
			for (ii = 0; ii < CurrentRoute.Size; ii++)
			{
				print("   --- %i", CurrentRoute.Nodes[ii].TID);
			}
			//// DEBUG -------------------------- DEBUG*/
		}
		//else
		//	print("no current route --> target is too close, TID = %i", TID);
		
		Behavior.bLostFTarget = false;
		Behavior.RouteRebuildTime = Behavior.RouteRebuildRate;

		RouteWayIndex = 0;
		IGnTarget.Node = CurrentNode;
	}
	else
	{
		if (Behavior.bBuildingRoute)
		{
			//print("delayed build route, TID = %i", TID);
		}
		else
		{
			//print("failed build route, TID = %i", TID);
			Behavior.RouteRebuildTime = Behavior.RouteRebuildRateLow;
			RouteWayIndex = -1;
		}
	}
}

//==========================================================================
//
//	SetNextTargetNode
//
//==========================================================================

void SetNextTargetNode()
{
	if (!Behavior.bUsingRoute)
		return;

	//print("set next node");
	
	if (IGnTarget.Node)
	{
		RouteWayIndex++;
		if (RouteWayIndex >= Route::WAYLISTSIZE ||
				CurrentRoute.Nodes[RouteWayIndex] == none)
		{
			//print("route finished");
			Behavior.bUsingRoute = false;
		}
		else
		{
			IGnTarget.Node = CurrentRoute.Nodes[RouteWayIndex];
			//print("new target node = %i", IGnTarget.Node.TID);
		}
	}
	else
	{
		// something wrong has happened
		//print("Lost route!!!");
		Behavior.bUsingRoute = false;
	}
}

//==========================================================================
//
//	AcceptTargetNode
//
//	Checks whether actor is in vicinity of target node
//
//==========================================================================

void AcceptTargetNode()
{
	if (!Behavior.bUsingRoute)
		return;

	if (!IGnTarget.Node)
		return;

	if (Length(Origin - IGnTarget.Node.Origin) <= ACCEPTABLE_WAYPOINT_VICINITY)
	{
		//print("node accepted! %i", IGnTarget.Node.TID);
		CurrentNode = IGnTarget.Node;
		SetNextTargetNode();
	}
}

//==========================================================================
//
//	FindNearestReachableNode
//
//	Method seeks for a nearest node which is reachable directly from
//	this actor's current position.
//
//==========================================================================

Node FindNearestReachableNode()
{
	float		distance;
	float		compdist;
	Node		_Node;
	Node		NodeSelected;
	
	NodeSelected = none;
	distance = -1.0;
	
	foreach AllThinkers(Node, _Node)
	{
		//dprint("Actor::FindNearestReachableNode : _Node = %i", _Node.TID);
		compdist = Length(_Node.Origin - Origin);
		if (distance < 0.0 || compdist < distance)
		{
			//dprint("Actor::FindNearestReachableNode : check canreach");
			if (CanReach(_Node.Origin, none))
			{
				//dprint("Actor::FindNearestReachableNode : remember this one");
				distance = compdist;
				NodeSelected = _Node;
			}
		}
	}
	return NodeSelected;
}

//==========================================================================
//
//	FindAcceptableTargetNode
//
//	Method seeks for a node, FROM WHICH this actor can reach its designated
//	target directly, or, at least, shoot it using missile attack.
//
//	VTarget - exact target location;
//	ETarget - a target actor (optional);
//	bReachableFromHere - when set this flag makes the method try only nodes
//          that are reachable directly from this actor's current position.
//
//	If no ETarget is given, method tries only nodes that have direct route
//	to VTarget, otherwise it also checks which nodes could be possible
//	positions for missile attack.
//
//==========================================================================

Node FindAcceptableTargetNode(TVec VTarget, EntityEx ETarget, bool bReachableFromHere)
{
	float		distance;
	float		compdist;
	Node		_Node;
	Node		NodeSelectedCanReach;
	Node		NodeSelectedCanSee;
	TVec		OriginalOrigin;		// [CW] I like how it sounds :)
	TAVec		OriginalAngles;
	TVec		VectorToTarget;
	
	distance = -1.0;
	OriginalOrigin = Origin;
	OriginalAngles = Angles;
	
	foreach AllThinkers(Node, _Node)
	{
		if (bReachableFromHere)
		{
			if (!CanReach(_Node.Origin, none))
				continue;
		}

		compdist = Length(_Node.Origin - VTarget);
		if (distance < 0.0 || compdist < distance)
		{
			UnlinkFromWorld();
			Origin = _Node.Origin;
			LinkToWorld();
			VectorToTarget = (VTarget - Origin);
			VectorAngles(&VectorToTarget, &Angles);
			
			if (CanReach(VTarget, ETarget))
			{
				distance = compdist;
				NodeSelectedCanReach = _Node;
			}
			else if (MissileState && ETarget && CanSee(ETarget))
			{
				distance = compdist;
				NodeSelectedCanSee = _Node;
			}

			if (bReachableFromHere)
			{
				UnlinkFromWorld();
				Origin = OriginalOrigin;
				LinkToWorld();
			}
		}
	}
	
	if (!bReachableFromHere)
	{
		UnlinkFromWorld();
		Origin = OriginalOrigin;
		LinkToWorld();
	}
	Angles = OriginalAngles;

	return (MissileState && (!NodeSelectedCanReach || NodeSelectedCanSee && Length(NodeSelectedCanSee.Origin - VTarget) < 
								Length(NodeSelectedCanReach.Origin - VTarget)))
				? NodeSelectedCanSee : NodeSelectedCanReach;
}




//**************************************************************************
//
//
//	[KoraxRPG] Route Building
//
//
//**************************************************************************

//==========================================================================
//
//	BuildWaypoints
//
//==========================================================================

bool BuildWaypoints(Node N_From, Node N_To)
{
	int i;
	
	//print("try build waypoints");
	
	//
	// Algorythm for optimal route build, as written in AI Tutorial :)
	//
	//	 create a list P
	//	 add the start node S, to P giving it one element
	//	 Until first path of P ends with G, or P is empty
	//		extract the first path from P
    //		extend first path one step to all neighbors creating X new paths
    //		reject all paths with loops
    //			for all paths that end at the same node,
	//								keep only the shortest one.
	//		add each remaining new path to of P
    //		Sort all paths by total underestimate, shortest first.
	//	 If G found -> success. Else -> failure.
	//
	//	total underestimate is:
	//		distance of partial path travelled + straight-line distance
	//										from last node in path to goal
	//
	//

	bool						failed;
	LinkedList					route_list;
	Route						R;

	failed = false;
	if (Behavior.bBuildingRoute)
	{
		//print("continue %i", Behavior.RouteBuildContinuesCount);
		Behavior.RouteBuildContinuesCount++;
		Behavior.RouteBuildIterationsCount = 0;
	}
	else
	{
		// TODO: think this out
		if (CurrentRoute)
		{
			CurrentRoute.Destroy();
			CurrentRoute = none;
		}

		if (N_From == N_To)
		{
			//print("succeeded (same node)");
			return true;
		}

		Behavior.bBuildingRoute = true;
		Behavior.RouteBuildContinuesCount = 0;
		Behavior.RouteBuildIterationsCount = 0;

		if (RouteList)
			Error ("Actor::BuildWaypoints : RouteList existed before Route build was started");

		RouteList = LinkedList(SpawnObject(LinkedList));
	
		R = Route(SpawnObject(Route));
		R.Nodes[0] = N_From;
		R.Size = 1;
		RouteList.Add(R);
	}

	route_list = LinkedList(SpawnObject(LinkedList));

	while (!IsNodeInRoute(Route(RouteList.refHead), N_To))
	{
		if (Behavior.RouteBuildIterationsCount == RouteBuildIterationsLimit)
		{
			if (Behavior.RouteBuildContinuesCount == RouteBuildContinuesLimit)
			{
				failed = true;
				break;
			}

			route_list.Destroy();
			return false;
		}
		//else
		//	print("iteration %i", Behavior.RouteBuildIterationsCount);

		if (route_list.refHead)
			Error ("Actor::BuildWaypoints : temporary route list is not empty at the beginning of iteration");

		R = Route(RouteList.refHead);
		route_list.Add(R);
		ExtendRoute(route_list, N_To);
		if (route_list.refHead != none)
			AddExtendedRoutes(route_list, RouteList);
		ExcludeExcessRoutes(RouteList);
		if (RouteList.refHead == none)
		{
			failed = true;
			break;
		}
		
		Behavior.RouteBuildIterationsCount++;
	};
	
	Behavior.bBuildingRoute = false;

	if (!failed)
	{
		// Store successful route, destroy others
		CurrentRoute = Route(RouteList.refHead);
		RouteList.refHead.UnlinkFromList();
	}
	
	route_list.Destroy();
	RouteList.Destroy();
	RouteList = none;

	return !failed;
}

//==========================================================================
//
//	IsNodeInRoute
//
//==========================================================================

bool IsNodeInRoute(Route R, Node N)
{
	int i;
	
	//dprint("IsNodeInRoute : nodes currently in list:");
	for (i = 0; i < R.Size; i++)
	{
		//dprint("    ---- %i", R.Nodes[i].TID);
		if (R.Nodes[i] == N)
			return true;
	}
	
	return false;
}

//==========================================================================
//
//	ExtendRoute
//
//	It is assumed that route list passed to this method contains
//	only one route that need to be extended.
//
//==========================================================================

void ExtendRoute(LinkedList route_list, Node NDest)
{
	if (route_list.refHead == none)
		return;

	int i, j;
	bool found;
	float PreviousMeasure;
	float LinkMeasureFactor;
	Route R;
	Route ExtendableRoute;
	Node NExtendable;
	
	ExtendableRoute = Route(route_list.refHead);
	
	//dprint("ExtendRoute : ExtendableRoute.Measure = %f", ExtendableRoute.Measure);
	//dprint("ExtendRoute : ExtendableRoute.Size = %i", ExtendableRoute.Size);
	
	PreviousMeasure = ExtendableRoute.Measure;
	NExtendable = ExtendableRoute.Nodes[ExtendableRoute.Size - 1];
	
	//dprint("ExtendRoute : NExtendable.TID = %i", NExtendable.TID);
	
	// Do extension
	for (i = 0; i < /*Node::MAXNODELINKS*/NExtendable.Links.Num; i++)
	{
		if (NExtendable.Links[i]._Node)
		{
			//dprint("ExtendRoute : try link to %i", NExtendable.Links[i]._Node.TID);
			found = false;
			// Check if this node isn't already in route
			for (j = 0; j < Route(route_list.refHead).Size; j++)
			{
				//dprint("ExtendRoute : compare w old %i", Route(route_list.refHead).Nodes[j].TID);
				if (Route(route_list.refHead).Nodes[j] == NExtendable.Links[i]._Node)
				{
					found = true;
					break;
				}
			}
			if (found)
				continue;
		
			// Test current link for pawn's reachability
			LinkMeasureFactor = GetNodeLinkMeasureFactor(NExtendable, i);
			//dprint("ExtendRoute : LinkMeasureFactor = %f", LinkMeasureFactor);
			
			if (LinkMeasureFactor <= 0.0)
			{
				continue;
			}
			
			R = Route(SpawnObject(Route));
			route_list.Add(R);
			ExtendableRoute = R;

			// Calculate underestimate
			if (PreviousMeasure > 0.0)
				ExtendableRoute.Measure = PreviousMeasure - Length(NDest.Origin - NExtendable.Origin);
			else
				ExtendableRoute.Measure = 0.0;
			ExtendableRoute.Measure += NExtendable.Links[i].length * LinkMeasureFactor;
			ExtendableRoute.Measure += Length(NDest.Origin - NExtendable.Links[i]._Node.Origin);
			//dprint("ExtendRoute : total measure for this extension = %f", ExtendableRoute.Measure);
			
			// Copy head route original nodes to the new one
			for (j = 0; j < Route(route_list.refHead).Size; j++)
				ExtendableRoute.Nodes[j] = Route(route_list.refHead).Nodes[j];
				
			// Add new node
			ExtendableRoute.Nodes[j] = NExtendable.Links[i]._Node;
			ExtendableRoute.Size = j + 1;
		}
	}
	
	
	// Remove original head route
	route_list.DestroyObject(route_list.refHead);
}

//==========================================================================
//
//	GetNodeLinkMeasureFactor
//
//	Actors with special movement restrictions or extra abilities should
//	override this function to reflect their peculiarities.
//
//==========================================================================

float GetNodeLinkMeasureFactor(Node NOrigin, int iLink)
{
	// Default test is made to know if pawn has physical chance
	// to pass by the link

	// Minimal vertical space
	if (NOrigin.Links[iLink].minyspace < Height)
		return -1.0;

	// Maximal step
	if (NOrigin.Links[iLink].maxstepheight > MaxStepHeight)
		return -1.0;

	// Maximal dropoff
	if (NOrigin.Links[iLink].maxdropoff > MaxDropoffHeight)
		return -1.0;

	return 1.0;
}

//==========================================================================
//
//	ExcludeExcessRoutes
//
//==========================================================================

void ExcludeExcessRoutes(LinkedList route_list)
{
	if (route_list.refHead == none)
		return;
	
	int i;
	bool found, lightest_saved, rpass_excluded;
	Route RPass;
	Route RSeek;
	Route RSeekEnd;
	Route RExclude;
	Node NEnding;
	float LighterMeasure;
	
	//dprint("ExcludeExcessRoutes");
	
	RPass = Route(route_list.refHead);
	while (RPass != none)
	{
		//dprint("ExcludeExcessRoutes : rpass go");
	
		// Remember RPass'es last Node and route Measure
		NEnding = RPass.Nodes[RPass.Size - 1];
		LighterMeasure = RPass.Measure;
		
		// Pass through the left of the route list, seeking for routes with same ending
		found = false;
		RSeek = Route(RPass.refNext);
		while (RSeek != none)
		{
			if (RSeek.Nodes[RSeek.Size - 1] == NEnding)
			{
				found = true;
				if (RSeek.Measure < LighterMeasure)
					LighterMeasure = RSeek.Measure;
			}
			
			RSeekEnd = RSeek;
			RSeek = Route(RSeek.refNext);
		};
		
		// If any route with same ending was found, remove each of them, that have
		// heavier measure than stored in LighterMeasure
		if (found)
		{
			found = false;				// [CW] used here for detecting last check candidate
			rpass_excluded = false;
			lightest_saved = false;
			
			RSeek = RPass;
			while (RSeek != none)
			{
				RExclude = none;
				if (RSeek.Nodes[RSeek.Size - 1] == NEnding)
				{
					if (RSeek.Measure > LighterMeasure)
						RExclude = RSeek;
					else if (RSeek.Measure == LighterMeasure)
					{
						if (lightest_saved)
							RExclude = RSeek;
						else
							lightest_saved = true;
					}
				}
				if (RSeek.Size == Route::WAYLISTSIZE)
					RExclude = RSeek;
			
				if (RSeek == RSeekEnd)
					found = true;			// [CW] no need to search any more
				else
					RSeek = Route(RSeek.refNext);
					
				if (RExclude != none)
				{
					if (RPass == RExclude)
					{
						rpass_excluded = true;
						RPass = Route(RPass.refNext);
					}
					route_list.DestroyObject(RExclude);
				}
					
				if (found)
					break;
			};
		}
		
		if (rpass_excluded)
			rpass_excluded = false;
		else
			RPass = Route(RPass.refNext);
	};
}

//==========================================================================
//
//	AddExtendedRoutes
//
//==========================================================================

void AddExtendedRoutes(LinkedList extended_route_list, LinkedList route_list)
{
	if (extended_route_list.refHead == none)
		return;

	float HeaviestExtendedMeasure;
	Route R;
	Route HeaviestRoute;
	LinkedList sort_extended_route_list = LinkedList(SpawnObject(LinkedList));
	
	//dprint("AddExtendedRoutes");

	// Find largest measure in extended routes
	HeaviestExtendedMeasure = -1.0;
	R = Route(extended_route_list.refHead);
	while (R != none)
	{
		//dprint("AddExtendedRoutes : passcheck");
	
		if (HeaviestExtendedMeasure < 0.0 || R.Measure > HeaviestExtendedMeasure)
		{
			HeaviestExtendedMeasure = R.Measure;
			HeaviestRoute = R;
		}
			
		R = Route(R.refNext);
	};

	//dprint("AddExtendedRoutes : HeaviestExtendedMeasure = %f", HeaviestExtendedMeasure);
	
	// Find all previously existed routes from the list that
	// have lighter measures and move them to extended routes list
	R = Route(route_list.refHead);
	while (R != none)
	{
		if (R.Measure < HeaviestExtendedMeasure)
		{
			extended_route_list.Add(R);
		}
		R = Route(R.refNext);
	};
	
	//
	// Sort extended routes list
	//
	sort_extended_route_list.Add(HeaviestRoute);
	
	while (extended_route_list.refHead != none)
	{
		HeaviestExtendedMeasure = -1.0;
		R = Route(extended_route_list.refHead);
		while (R != none)
		{
			//dprint("AddExtendedRoutes : compare for sort: HeaviestMeasure = %f, R.Measure = %f", HeaviestExtendedMeasure, R.Measure);
			if (HeaviestExtendedMeasure < 0.0 || R.Measure > HeaviestExtendedMeasure)
			{
				//dprint("AddExtendedRoutes : select R as heaviest for this place");
				HeaviestExtendedMeasure = R.Measure;
				HeaviestRoute = R;
			}			
			R = Route(R.refNext);
		};
		
		//dprint("AddExtendedRoutes : add R with measure = %f in front of sorted list", HeaviestRoute.Measure);
		sort_extended_route_list.AddFront(HeaviestRoute);
	};
	
	//
	// Add sorted routes list at the beginning of the remaining old routes list
	//
	route_list.MoveContentsFront(sort_extended_route_list);
	
	
	sort_extended_route_list.Destroy();

	
	/*/// DEBUG!!! FIXME!!!
	R = Route(route_list.refHead);
	while (R != none)
	{
		dprint("AddExtendedRoutes : final passcheck");
		R = Route(R.refNext);
	};
	/// DEBUG!!! FIXME!!!*/

	//dprint("AddExtendedRoutes : lightest (head) route measure = %f", Route(route_list.refHead).Measure);
}

//==========================================================================
//
//	P_Order_UseLine			-=  TODO  =-
//
//==========================================================================

void P_Order_UseLine()
{
}

//==========================================================================
//
//	P_Order_UseThing		-=  TODO  =-
//
//==========================================================================

void P_Order_UseThing()
{
}

defaultproperties
{	
	Behavior.ThreatReaction			= THREATREACTION__DETECT;
	Behavior.ThreatVicinity			= DEFAULT_THREAT_VICINITY;

	Behavior.bNoWanderDuringAttack	= false;
	Behavior.bEvadeMelee			= false;
	Behavior.bRunOnEvade			= false;

	Behavior.bCanGroup				= true;
	Behavior.bCanBeTaskLeader		= true;

	Behavior.bNeverUseRoutes		= false;
	Behavior.RouteRebuildRate		= 512;
	Behavior.RouteRebuildRateLow	= 1024;
	Behavior.LostFTargetTolerance	= 32;
	//Behavior.CheckFTargetPosRate	= 128;
	Behavior.FTargetPosChangeLimit	= 512.0;

	bNeverTarget = false;

	bNonScalable = false;
	bCombatant = true;
}
