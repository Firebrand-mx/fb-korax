//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ## ###  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**				   ######  #####   ######
//**	               ##   ## ##  ## ##    ##
//**	     		   ##   ## ##  ## ##   
//**	               #####   #####  ##  ####
//**	     		   ## ###  ##     ###   ##
//**	     		   ##  ### ##      ######
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2008 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class KRPGLevelInfo : HexenLevelInfo;


//
// [KoraxRPG] Node Graph
//
const float	MAXNODELINKLENGTH		= 1024.0;
bool bNodeGraphBuild;

//
// New Action Specials

// [CW] in order not to mix these with common line specials,
//	their ids should be greater than 255;
//  "Doom Builder" supports >255 linespecial IDs;
//  if mapper is using different editor, he may still run these using scripts
enum
{
	//
	// Advanced thing manipulation

	ACTSPEC_Thing_Thrust3d			= 256,	// calls combo of Thing_Thrust and Thing_ThrustZ
	ACTSPEC_Thing_SetPlayerMOTag,			// sets TID to current player MO (using player's Number)
	ACTSPEC_Thing_SetTeam,
	ACTSPEC_Thing_SetPersonId,

	LNSPEC_TravelMap				= 500,	// calls travel map

	//--------------------- NOT USED --------------------------------------------------------
//	//
//	// Miscellaneous, that could be useful
//
//	ACTSPEC_IsConditionTrue			= 755,	/* this id is taken equal to same actspec in Korax Arena*/
//	ACTSPEC_RunACSConditional,
//
	//--------------------- NOT USED --------------------------------------------------------

	//
	// Intelligent Actors
	//
	// Generic behavior
	ACTSPEC_IA_SetThreatReaction	= 800,

	// Orders
	ACTSPEC_IA_Order_CancelAll		= 900,
	ACTSPEC_IA_Order_CancelCurrent,
	ACTSPEC_IA_Order_StandStill,
	ACTSPEC_IA_Order_StandLook180,
	ACTSPEC_IA_Order_StandLook360,
	ACTSPEC_IA_Order_WalkTo,
	ACTSPEC_IA_Order_WalkPath,
	ACTSPEC_IA_Order_Patrol2pt,
	ACTSPEC_IA_Order_PatrolPath,
	ACTSPEC_IA_Order_PatrolLoop,
	ACTSPEC_IA_Order_Follow,		/* 910 */
	ACTSPEC_IA_Order_EvadePos,			
	ACTSPEC_IA_Order_EvadeThing,
	ACTSPEC_IA_Order_AttackAll,		
	ACTSPEC_IA_Order_AttackThing,
	ACTSPEC_IA_Order_Wander,

	// Advanced interaction (for Pawns)
	// [CW] CHECKME!
	ACTSPEC_PW_TryUse				= 1000,
	ACTSPEC_PW_Order_UseLine,
	ACTSPEC_PW_Order_UseThing,

	//
	// Enviroment
	//
	ACTSPEC_Env_WeatherSnow			= 1200,
	ACTSPEC_Env_WeatherRain,
	ACTSPEC_Env_WeatherTerminate,
	ACTSPEC_Env_WeatherTerminateAll,
	ACTSPEC_Env_WeatherSetParams,
	ACTSPEC_Env_WeatherSetPattern,
	ACTSPEC_Env_WeatherSetColour,


	ACTSPEC_Last
};

// [CW] Conditions for ACTSPEC_IsConditionTrue and ACTSPEC_RunACSConditional
/*enum
{
	CNDT_Unused		// just to be...
};*/


//
// Behavior packages stored for instant appliance to Intelligent Actor
//
array<LinkedList>	AIPackages;

enum
{
	pt_weather_snow = pt_spark + 1,
	// General difference between snow and rain types is that rain spawns some splash when dies
	pt_weather_rain
};

// KRPG
enum
{
	pt_pattern_none,
	// rain patterns: create a vertical chunk of particles instead of single one
	pt_pattern_rainlight,
	pt_pattern_rainmoderate,
	pt_pattern_rainheavy
};

array<Thinker>	WeatherThinkers;

int skyflatnum;	// copied from Game, needed for client-side calculations when Game is not accessible

replication
{
	reliable if (Role == ROLE_Authority)
		skyflatnum;
}


//==========================================================================
//
//	IsBeneathSky
//
//==========================================================================

bool IsBeneathSky(TVec v)
{
	sector_t * p_sector = XLevel.PointInSector(v);
	return p_sector && p_sector->ceiling.pic == skyflatnum;
}

//==========================================================================
//
//	FindHighestFloorZAtPoint
//
//	[CW] Find the highest floor Z for given (x,y) coordinates.
//	(Not completely sure, but it seems there's no common method for this)
//
//==========================================================================

float FindHighestFloorZAtPoint(TVec v, optional sector_t * in_sector)
{
	sector_t * pt_sector;
	sec_region_t * pt_region;
	float pt_floorz;

	if (in_sector)
		pt_sector = in_sector;
	else
		pt_sector = XLevel.PointInSector(v);

	if (pt_sector)
	{
		// [CW] Hope this will work
		if (pt_sector->bHasExtrafloors)
		{
			pt_region = PointInRegion(pt_sector, v);
			while(pt_region->next)
				pt_region = pt_region->next;
			pt_floorz = GetPlanePointZ(pt_region->floor, v);
		}
		else
		{
			pt_floorz = GetPlanePointZ(&pt_sector->floor, v);
		}

		return pt_floorz;
	}
	else
		return EntityEx::ONFLOORZ;	// Failed
}

//==========================================================================
//
//  SpawnSpecials
//
//	[KoraxRPG]
//
//==========================================================================

void SpawnSpecials()
{
	::SpawnSpecials();

	MainGameInfo(Game).InitLevel(self);
	BuildNodeGraph();
}

//==========================================================================
//
//  ExecuteActionSpecialForTID
//
//	[KoraxRPG]
//
//==========================================================================

bool ExecuteActionSpecialForTID(int Special, int TID, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side)
{
	Entity E;
	bool result = false;

	if (TID == KRPGDefs::TAG_EVERYBODY)
	{
		foreach AllThinkers(Entity, E)
		{
			if (ExecuteActionSpecial(Special, 0, Arg2, Arg3, Arg4, Arg5, Line, Side, E))
				result = true;
		}
	}
	else
	{
		for (E = Entity(FindMobjFromTID(TID, none)); E;
			E = Entity(FindMobjFromTID(TID, E)))
		{
			if (E && ExecuteActionSpecial(Special, 0, Arg2, Arg3, Arg4, Arg5, Line, Side, E))
				result = true;
		}
	}
	
	return result;
}

//==========================================================================
//
//  ExecuteActionSpecial
//
//	KRPG override for new action specials
//
//==========================================================================

int ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;

	buttonSuccess = false;

	if ( ( Special >= ACTSPEC_Thing_Thrust3d
		&& Special < ACTSPEC_Env_WeatherSnow
		&& Special != ACTSPEC_Thing_SetPlayerMOTag)

		&& (Arg1 > 0 || Arg1 == KRPGDefs::TAG_EVERYBODY))
	{
		buttonSuccess = ExecuteActionSpecialForTID(Special, Arg1, Arg2, Arg3, Arg4, Arg5, Line, Side);
		return buttonSuccess;
	}

	switch (Special)
	{
	//
	// Overriding common specials
	//case LNSPEC_ThingSetGoal: // <--- TODO!!

	//
	// Advanced thing manipulation
	case ACTSPEC_Thing_Thrust3d:
		if (E && E.IsA('Actor'))
		{
			A_Thing3dThrust(Actor(E), Arg2, Arg3, Arg4, Arg5);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_Thing_SetPlayerMOTag:
		if (Game.Players[Arg1] && Game.Players[Arg1].MO)
		{
			Game.Players[Arg1].MO.SetTID(Arg2);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_Thing_SetTeam:
		if (E && E.IsA('Actor'))
		{
			Actor(E).SetTeam(Arg2);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_Thing_SetPersonId:
		if (E && E.IsA('Actor'))
		{
			Actor(E).ConversationID = Arg2;
			buttonSuccess = true;
		}
		break;


	case LNSPEC_TravelMap:
		{
			buttonSuccess = true;
			Completed(-1,0,0);
		}
		break;


	//
	// Intelligent Actors
	//
	// Generic behavior
	case ACTSPEC_IA_SetThreatReaction:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).SetThreatReaction(Arg2, itof(Arg3));
			buttonSuccess = true;
		}
		break;

	// Orders
	case ACTSPEC_IA_Order_CancelAll:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).CancelAllOrders();
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_CancelCurrent:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).CancelCurrentOrder();
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_StandStill:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderStandStill(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_StandLook180:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderStandStill(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_StandLook360:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderStandStill(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_WalkTo:
		if (E && E.IsA('IntelligentActor'))
		{
			Entity target = FindMobjFromTID(Arg4, none);
			IntelligentActor(E).OrderWalkTo(false, Arg2, itof(Arg3) / 1000.0,
										target ? target.Origin : E.Origin);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_WalkPath:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderWalkPath(false, false, false, Arg2, itof(Arg3) / 1000.0,
				Arg4, Arg5 & KRPGDefs::PATH_NODE_TID_MASK,
				(Arg5 & KRPGDefs::PATH_DIRECTION_BACK) != 0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_Patrol2pt:
		if (E && E.IsA('IntelligentActor'))
		{
			Entity target1 = FindMobjFromTID(Arg4, none);
			Entity target2 = FindMobjFromTID(Arg5, none);
			IntelligentActor(E).OrderPatrol2Pt(false, Arg2, itof(Arg3) / 1000.0,
							target1 ? target1.Origin : E.Origin,
							target2 ? target2.Origin : E.Origin);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_PatrolPath:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderWalkPath(false, true, false, Arg2, itof(Arg3) / 1000.0,
									Arg4, Arg5 & KRPGDefs::PATH_NODE_TID_MASK,
									Arg5 & KRPGDefs::PATH_DIRECTION_BACK != 0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_PatrolLoop:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderWalkPath(false, true, true, Arg2, itof(Arg3) / 1000.0,
									Arg4, Arg5 & KRPGDefs::PATH_NODE_TID_MASK,
									Arg5 & KRPGDefs::PATH_DIRECTION_BACK != 0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_Follow:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderFollowThing(false, Arg2, itof(Arg3) / 1000.0,
										Actor(FindMobjFromTID(Arg4, none)));
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_EvadePos:
		if (E && E.IsA('IntelligentActor'))
		{
			Entity target = FindMobjFromTID(Arg4, none);
			IntelligentActor(E).OrderEvadePosition(false, Arg2, itof(Arg3) / 1000.0,
										target ? target.Origin : E.Origin);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_EvadeThing:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderEvadeThing(false, Arg2, itof(Arg3) / 1000.0,
										Actor(FindMobjFromTID(Arg4, none)));
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_AttackAll:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderAttackAll(false, Arg2, itof(Arg3) / 1000.0);
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_AttackThing:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).OrderAttackThing(false, Arg2, itof(Arg3) / 1000.0, Actor(FindMobjFromTID(Arg4, none)));
			buttonSuccess = true;
		}
		break;
	case ACTSPEC_IA_Order_Wander:
		if (E && E.IsA('IntelligentActor'))
		{
			Entity target = FindMobjFromTID(Arg4, none);
			IntelligentActor(E).OrderWander(false, Arg2, itof(Arg3) / 1000.0,
										target ? target.Origin : E.Origin, itof(Arg5));
			buttonSuccess = true;
		}
		break;

	case ACTSPEC_PW_TryUse:
		if (E && E.IsA('IntelligentActor'))
		{
			IntelligentActor(E).TryUse(Player::USERANGE, Player::USETHINGRANGE);
			buttonSuccess = true;
		}
		break;

	case ACTSPEC_PW_Order_UseLine:
		if (E && E.IsA('IntelligentActor'))
		{

		}
		break;

	case ACTSPEC_PW_Order_UseThing:
		if (E && E.IsA('IntelligentActor'))
		{

		}
		break;

	//
	// Enviroment
	//
	case ACTSPEC_Env_WeatherSnow:
		buttonSuccess = EV_WeatherSnow(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case ACTSPEC_Env_WeatherRain:
		buttonSuccess = EV_WeatherRain(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case ACTSPEC_Env_WeatherTerminate:
		buttonSuccess = EV_WeatherTerminate(Arg1);
		break;
	case ACTSPEC_Env_WeatherTerminateAll:
		buttonSuccess = EV_WeatherTerminate(-1);
		break;
	case ACTSPEC_Env_WeatherSetParams:
		buttonSuccess = EV_WeatherSetParams(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case ACTSPEC_Env_WeatherSetPattern:
		buttonSuccess = EV_WeatherSetPattern(Arg1, Arg2);
		break;
	case ACTSPEC_Env_WeatherSetColour:
		buttonSuccess = EV_WeatherSetColour(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;

	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  StartConversation
//
//	[CW] This actually overrides LineSpecialLevelInfo::StartConversation.
//
//==========================================================================

bool StartConversation(EntityEx Speaker, EntityEx SpeakingTo)
{
	Quest::personinfo_t * p_infoSpeaker, * p_infoSpeakingTo;

	if (!Actor(Speaker))
		Error("KRPGLevelInfo::StartConversation : Speaker reference not set to an instance of an Actor");
	if (!Actor(SpeakingTo))
		Error("KRPGLevelInfo::StartConversation : SpeakingTo reference not set to an instance of an Actor");

	if (Speaker.Health <= 0 || SpeakingTo.Health <= 0)
		return false;

	if (!Speaker.bIsPlayer)
	{
		if (Speaker.ConversationID > 0)
		{
			p_infoSpeaker = KRPGWorldInfo(World).GetPersonRegistry("", Speaker.ConversationID);
			if (!p_infoSpeaker)
				return false;
		}
		else
			return false;
	}
	if (!SpeakingTo.bIsPlayer)
	{
		if (SpeakingTo.ConversationID > 0)
		{
			p_infoSpeakingTo = KRPGWorldInfo(World).GetPersonRegistry("", SpeakingTo.ConversationID);
			if (!p_infoSpeakingTo)
				return false;
		}
		else
			return false;
	}

	// checkme
	if (!p_infoSpeakingTo)
		return false;

	// Make sure both characters are facing each other
	Actor(Speaker).FaceActorInstant(SpeakingTo);
	Actor(SpeakingTo).FaceActorInstant(Speaker);

	if (Speaker.bIsPlayer)
	{
		Player(Speaker.Player).ClientConversation("", p_infoSpeakingTo->scriptName);
	}
	else if (SpeakingTo.bIsPlayer)
	{
		Player(SpeakingTo.Player).ClientConversation(p_infoSpeakingTo->scriptName, "");
	}

	return true;
}

//**************************************************************************
//
//	[KoraxRPG] New Action Specials
//
//**************************************************************************

//==========================================================================
//
//  A_Thing3dThrust
//
//  [CW] A three-dimensional vector variant of ThingThrust action special
//
//==========================================================================

void A_Thing3dThrust(Actor A, int angle2d, int angle3, int move, int move2)
{
	if (A)
	{
	  float fang2d = itof(angle2d);
	  float fang3 = itof(angle3);
      if (angle3)
         A.Thrust3d(fang2d, fang3, itof(move));
      else
         A.Thrust3d2(fang2d, itof(move), itof(move2));
	}
}

//==========================================================================
//
//	A_LocalQuakeFree
//
//==========================================================================

final QuakeFocus A_LocalQuakeFree(int Intensity, int Tics, int DamageRadius,
								int TremorRadius, TVec Origin)
{
	QuakeFocus focus = Spawn(QuakeFocus, Origin);
	if (focus)
	{
		focus.Richters = Intensity;
		focus.QuakeDuration = Tics >> 1;	// decremented every 2 tics
		focus.DamageRadius = itof(DamageRadius) * 64.0;
		focus.TremorRadius = itof(TremorRadius) * 64.0;
	}
	return focus;
}

//==========================================================================
//
//  EV_WeatherSnow
//
//==========================================================================

bool EV_WeatherSnow(int Density, int Angle, int HorSpeed, int VertSpeed, int Pattern)
{
	WeatherSnow WS = WeatherSnow(Spawn(WeatherSnow));
	if (WS)
	{
		WS.Amount = Density ? Density : WS.default.Amount;
		WS.Spread.z = WS.default.Spread.z * itof(WS.Amount) / itof(WS.default.Amount);
		float fang = itof(Angle);
		WS.InitialVelocity = (HorSpeed || VertSpeed) ?
			vector(itof(HorSpeed) * 8.0 * cos(fang), itof(HorSpeed) * 8.0 * sin(fang), itof(VertSpeed) * 8.0) :
			WS.default.InitialVelocity;
		WS.Pattern = Pattern;

		WeatherThinkers.Num = WeatherThinkers.Num + 1;
		WeatherThinkers[WeatherThinkers.Num - 1] = WS;
		return true;
	}
	return false;
}

//==========================================================================
//
//  EV_WeatherRain
//
//==========================================================================

bool EV_WeatherRain(int Density, int Angle, int HorSpeed, int VertSpeed, int Pattern)
{
	WeatherRain WR = WeatherRain(Spawn(WeatherRain));
	if (WR)
	{
		WR.Amount = Density ? Density : WR.default.Amount;
		WR.Spread.z = WR.default.Spread.z * itof(WR.Amount) / itof(WR.default.Amount);
		float fang = itof(Angle);
		WR.InitialVelocity = vector(itof(HorSpeed) * 8.0 * cos(fang),
			itof(HorSpeed) * 8.0 * sin(fang), itof(VertSpeed) * 8.0);
		WR.Pattern = Pattern;

		WeatherThinkers.Num = WeatherThinkers.Num + 1;
		WeatherThinkers[WeatherThinkers.Num - 1] = WR;
		return true;
	}
	return false;
}

//==========================================================================
//
//  EV_WeatherTerminate
//
//==========================================================================

bool EV_WeatherTerminate(int Num)
{
	if (Num < 0)
	{
		int i;
		for (i = 0; i < WeatherThinkers.Num; i++)
		{
			WeatherThinkers[i].Destroy();
			WeatherThinkers[i] = none;
		}
		WeatherThinkers.Num = 0;
		return true;
	}
	else if (WeatherThinkers.Num > Num)
	{
		if (WeatherThinkers[Num])
		{
			WeatherThinkers[Num].Destroy();
			WeatherThinkers[Num] = none;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  EV_WeatherSetParams
//
//==========================================================================

bool EV_WeatherSetParams(int Num, int Density, int Angle, int HorSpeed, int VertSpeed)
{
	if (WeatherThinkers.Num > Num)
	{
		if (WeatherThinkers[Num])
		{
			// FIXME!!
			WeatherSnow WS = WeatherSnow(WeatherThinkers[Num]);
			WS.Amount = Density ? Density : WS.default.Amount;
			WS.Spread.z = WS.default.Spread.z * itof(WS.Amount) / itof(WS.default.Amount);
			float fang = itof(Angle);
			WS.InitialVelocity = vector(itof(HorSpeed) * 8.0 * cos(fang),
						itof(HorSpeed) * 8.0 * sin(fang), itof(VertSpeed) * 8.0);
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  EV_WeatherSetPattern
//
//==========================================================================

bool EV_WeatherSetPattern(int Num, int Pattern)
{
	if (WeatherThinkers.Num > Num)
	{
		if (WeatherThinkers[Num])
		{
			// FIXME!!
			WeatherSnow WS = WeatherSnow(WeatherThinkers[Num]);
			WS.Pattern = Pattern;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  EV_WeatherSetColour
//
//==========================================================================

bool EV_WeatherSetColour(int Num, int R, int G, int B, int A)
{
	if (WeatherThinkers.Num > Num)
	{
		if (WeatherThinkers[Num])
		{
			// FIXME!!
			WeatherSnow WS = WeatherSnow(WeatherThinkers[Num]);
			WS.Colour = RGBA(R,G,B,A);
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  ParticleEffectEx
//
//==========================================================================

void ParticleEffectEx(int count, int type1, int type2, TVec origin, TVec ornd,
	TVec velocity, TVec vrnd, TVec acceleration, float grav, int colour, float duration, float ramp,
	int Pattern)
{
	int i, j;
	particle_t *p, *p2;

	float max_dist;
	float real_duration;
	sector_t * pt_sector;
	float pt_floorz;
	float time;

	if (!XLevel)
		Error("HexenLevelInfo::ParticleEffectEx : XLevel reference not set to an instance of an object");

	for (i = 0; i < count; i++)
	{
		p = NewParticle();
		if (!p)
			return;

		max_dist = -1.0;
		real_duration = 0.0;
		pt_sector = NULL;

		// [CW] Type and origin are very important in our implementation,
		// so they should go first
		//
		if(type2)
		{
			// Choose between the two types
			if (i & 1)
			{
				p->type = type1;
			}
			else
			{
				p->type = type2;
			}
		}
		else
		{
			p->type = type1;
		}

		// No random origin
		if(ornd == vector(0.0,0.0,0.0))
		{
			p->org = origin;
		}
		else
		{
			p->org.x = origin.x + ((Random() * ornd.x) - 16.0);
			p->org.y = origin.y + ((Random() * ornd.y) - 16.0);
			p->org.z = origin.z + ((Random() * ornd.z) - 16.0);
		}

		if (p->type == pt_weather_snow || p->type == pt_weather_rain)
		{
			max_dist = 0.0;
			pt_sector = XLevel.PointInSector(p->org);
			if (pt_sector && pt_sector->ceiling.pic == skyflatnum)
			{
				p->org.z += GetPlanePointZ(&pt_sector->ceiling, p->org);
				pt_floorz = FindHighestFloorZAtPoint(p->org, pt_sector);
				if (pt_floorz != EntityEx::ONFLOORZ)
				{
					max_dist = p->org.z - pt_floorz;
					if (max_dist < 0.0)
						max_dist = 0.0;
				}
			}
		}

		p->colour = colour;
		p->Size = 1.0;
		if(ramp)
			p->ramp = Random() * ramp;

		// No random velocity
		if(vrnd == vector(0.0,0.0,0.0))
		{
			p->vel = velocity;
		}
		else
		{
			p->vel.x = velocity.x * (Random() - vrnd.x);
			p->vel.y = velocity.y * (Random() - vrnd.y);
			p->vel.z = velocity.z * (Random() - vrnd.z);
		}
		p->accel.x = acceleration.x;
		p->accel.y = acceleration.y;
		p->accel.z = acceleration.z;
		p->gravity = grav;

		if (duration && max_dist)
			real_duration = duration * Random();
		// [CW] TODO: fix lifetime for weather particles according to accel & velocity
		// currently does not care about accel since there's no sqrt func :(
		// so using simplest formula this time
		if (max_dist >= 0.0)
		{
			if (p->vel.z != 0.0)
				time = -(max_dist / p->vel.z);
			else
				time = 0.0;
			if (!real_duration || real_duration > time)
				real_duration = time;
		}
		p->die = XLevel.Time + real_duration;

		if (real_duration && Pattern)
		{
			switch (Pattern)
			{
			case pt_pattern_rainlight:
			case pt_pattern_rainmoderate:
			case pt_pattern_rainheavy:
				{
					int q;
					switch (Pattern)
					{
					case pt_pattern_rainlight: q = P_Random() % 3 + 3; break;
					case pt_pattern_rainmoderate: q = P_Random() % 7 + 4; break;
					case pt_pattern_rainheavy: q = P_Random() % 10 + 10; break;
					}
					for (j = 0; j < q; j++)
					{
						p2 = NewParticle();
						if (!p2)
							break;
						p2->org = vector(p->org.x, p->org.y, p->org.z + itof(j));
						p2->colour = p->colour;
						p2->Size = p->Size;
						p2->vel = p->vel;
						p2->accel = p->accel;
						p2->die = p->die;
						p2->type = p->type;
						p2->ramp = p->ramp;
						p2->gravity = p->gravity;
					}
				}
				break;
			}
		}
	}
}

//==========================================================================
//
//  UpdateParticle
//
//==========================================================================

void UpdateParticle(particle_t * p, float DeltaTime)
{
	float grav;
	float pt_floorz;

	grav = DeltaTime * p->gravity;
	p->accel.z -= grav;
	
	switch (p->type)
	{
	case pt_weather_snow:
	case pt_weather_rain:
		p->vel += p->accel * DeltaTime;
		{
			// spawn a splash just before particle death
			if (p->type == pt_weather_rain && (p->die <= XLevel.Time + DeltaTime))
			{
				// [CW] Hope this won't slow things down significantly
				//
				pt_floorz = FindHighestFloorZAtPoint(p->org);
				if (pt_floorz != EntityEx::ONFLOORZ && (p->org.z - pt_floorz < 8.0))
				{
					ParticleEffect(P_Random() % 6 + 2, pt_static, 0, p->org, 0.0, vector(16.0, 16.0, 16.0),
						0.5, 0.0, 40.0,
						RGB(((p->colour >> 16) & 0xff) >> 1, (((p->colour >> 8) & 0xff) >> 1), (p->colour & 0xff) >> 1),
						0.4, 0.0);
				}
			}
		}
		return;
	}
	::UpdateParticle(p, DeltaTime);
}

//**************************************************************************
//
//
//	[KoraxRPG] Node Graph
//
//
//**************************************************************************

//===========================================================================
//
//  BuildNodeGraph
//
//===========================================================================

void BuildNodeGraph()
{
	BuildNodeLinks();

	if (bNodeGraphBuild)
	{
		BuildPriorityPaths();
	}
}

//===========================================================================
//
//  BuildNodeLinks
//
//	Builds common links between all nodes.
//
//===========================================================================

void BuildNodeLinks()
{
	int i;
	Node		N_Base;
	Node		N_LinkCandidate;
	int			linked_count;
	bool		candidate_is_linked_to_base;
	float		dest;

	// #ifdef DEBUG_PATH_NODES
	//
	// Debug statistics
	//------------------------
	int			stats_TotalBaseNodes = 0;
	int			stats_TotalLinkedNodes = 0;
	int			stats_TotalUnlinkedNodes = 0;
	int			stats_AverageLinksPerNode = 0;
	int			stats_TotalLinks = 0;
	float		stats_MaximalLinkLength = 0.0;
	float		stats_MinimalLinkLength = -1.0;
	// etc etc etc.....
	//------------------------
	//
	// #endif

	foreach AllThinkers(Node, N_Base)
	{
		stats_TotalBaseNodes++;

		N_LinkCandidate = none;
		linked_count = 0;
		dest = -1.0;
		
		for (i = 0; i < N_Base.Links.Num; i++)
		{
			if (N_Base.Links[i].node)
				linked_count++;
		}
		
		foreach AllThinkers(Node, N_LinkCandidate)
		{
			candidate_is_linked_to_base = false;
			if (N_LinkCandidate == N_Base)
			{
				continue;
			}
			for (i = 0; i < N_LinkCandidate.Links.Num; i++)
			{
				if (N_LinkCandidate.Links[i].node)
				{
					if (N_LinkCandidate.Links[i].node == N_Base)
					{
						candidate_is_linked_to_base = true;
						break;
					}
				}
			}
			if (candidate_is_linked_to_base)
			{
				continue;
			}

			dest = Length(N_Base.Origin - N_LinkCandidate.Origin);
			if (dest <= MAXNODELINKLENGTH)
			{
				Node::nodelink_t _link;

				if (BuildNodeLink(N_Base, N_LinkCandidate, &_link))
				{
					N_Base.ApplyLink(&_link, -1, true);

					linked_count++;
					stats_TotalLinks++;
				}
			}
		}


		if (linked_count)
			stats_TotalLinkedNodes++;
		else
			stats_TotalUnlinkedNodes++;
		stats_AverageLinksPerNode += linked_count;
		for (i = 0; i < linked_count; i++)
		{
			Node::nodelink_t * p_link = &N_Base.Links[i];
			if (stats_MaximalLinkLength < p_link->length)
				stats_MaximalLinkLength = p_link->length;
			if (stats_MinimalLinkLength < 0.0 || stats_MinimalLinkLength > p_link->length)
				stats_MinimalLinkLength = p_link->length;
		}

	}

	if (stats_TotalBaseNodes)
		stats_AverageLinksPerNode /= stats_TotalBaseNodes;

	#ifdef DEBUG_PATH_NODES
	//
	// Debug info output
	//------------------------
	print("");
	print(" ============= Node Graph Info =============");
	print("   Total Nodes found:               %i      ", stats_TotalBaseNodes);
	print("   Total Bidirect Links built:      %i      ", stats_TotalLinks);
	print("   Total Linked Nodes:              %i      ", stats_TotalLinkedNodes);
	print("   Total Unlinked Nodes:            %i      ", stats_TotalUnlinkedNodes);
	print("   Average Links per Node:          %i      ", stats_AverageLinksPerNode);
	print("   Maximal Link Length:             %f      ", stats_MaximalLinkLength);
	print("   Minimal Link Length:             %f      ", stats_MinimalLinkLength);
	print(" ===========================================");
	print("");
	//------------------------
	//
	#endif

	bNodeGraphBuild = (stats_TotalBaseNodes > 0);
}

//===========================================================================
//
//  BuildNodeLink
//
//	Tries to build a link between two nodes and sets link parameters.
//
//===========================================================================

bool BuildNodeLink(Node N_From, Node N_To, Node::nodelink_t * _link)
{
	bool canreach;
	ReachTraverse::linkreach_traverse_data LRTRData;

	canreach = BuildNodeLinkTraverse(N_From, N_To, &LRTRData);

	if (!canreach)
	{
		return false;
	}
	if (!LRTRData.intercepted_once && N_From.Sector != N_To.Sector)
	{
		return false;
	}
	
	_link->node = N_To;
	_link->length = Length(N_From.Origin - N_To.Origin);
	_link->minyspace = LRTRData.minyspace;
	_link->maxstepheight = LRTRData.maxstepheight;
	_link->maxdropoff = LRTRData.maxdropoff;

#ifdef DEBUG_NODE_LINKS
		print("Link from %v to %v : l = %f, minspace = %f, maxstep = %f, maxdrop = %f",
			N_From.Origin.x,N_From.Origin.y,N_From.Origin.z,
			N_To.Origin.x,N_To.Origin.y,N_To.Origin.z,
			_link->length, _link->minyspace, _link->maxstepheight, _link->maxdropoff);
#endif

	return true;
}

//==========================================================================
//
//	BuildNodeLinkTraverse
//
//==========================================================================

bool BuildNodeLinkTraverse(Node N_From, Node N_To,
							ReachTraverse::linkreach_traverse_data * pLRTRData)
{
	intercept_t * in;
	pLRTRData->intercepted_once = false;
	pLRTRData->prev_sector = N_From.Sector;
	pLRTRData->minyspace = N_From.Sector->ceiling.TexZ - N_From.Sector->floor.TexZ;
	pLRTRData->maxstepheight = 0.0;
	pLRTRData->maxdropoff = 0.0;

#ifdef EXTRASILLYVERTEXTRAVERSECHECK
	if (!CheckSolidVertexTraverse(N_From.Sector, N_From.Origin, N_To.Origin))
	{
		return false;
	}
#endif

	foreach PathTraverse(in, N_From.Origin.x, N_From.Origin.y, N_To.Origin.x, N_To.Origin.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pLRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;
			float ceiling;
			float floor;
			float yspace;
			float fheightdelta;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
				(in->line->flags & ML_BLOCKEVERYTHING) ||
					!in->line->backsector)
			{
				return false;
			}


			// in case of two-sided lines we update link info
			if (in->line->frontsector == pLRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pLRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
			{
				// something was really messed up
				return false;
			}

#ifdef EXTRASILLYVERTEXTRAVERSECHECK
			if (!CheckSolidVertexTraverse(p_sector, N_From.Origin, N_To.Origin))
			{
				return false;
			}
#endif

			if (p_sector->ceiling.TexZ < pLRTRData->prev_sector->ceiling.TexZ)
				ceiling = p_sector->ceiling.TexZ;
			else
				ceiling = pLRTRData->prev_sector->ceiling.TexZ;
			if (p_sector->floor.TexZ > pLRTRData->prev_sector->floor.TexZ)
				floor = p_sector->floor.TexZ;
			else
				floor = pLRTRData->prev_sector->floor.TexZ;
			yspace = ceiling - floor;
			fheightdelta = p_sector->floor.TexZ - pLRTRData->prev_sector->floor.TexZ;

			if (yspace < pLRTRData->minyspace)
				pLRTRData->minyspace = yspace;
			if (fheightdelta > 0.0)
			{
				if (fheightdelta > pLRTRData->maxstepheight)
					pLRTRData->maxstepheight = fheightdelta;
			}
			else if (fheightdelta < 0.0)
			{
				if (fheightdelta < -pLRTRData->maxdropoff)
					pLRTRData->maxdropoff = -fheightdelta;
			}

			pLRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
		}
	}

#ifdef EXTRASILLYVERTEXTRAVERSECHECK
	if (N_To.Sector != pLRTRData->prev_sector &&
		!CheckSolidVertexTraverse(N_To.Sector, N_From.Origin, N_To.Origin))
	{
		return false;
	}
#endif

	return true;
}

#ifdef EXTRASILLYVERTEXTRAVERSECHECK

//===========================================================================
//
//  CheckSolidVertexTraverse
//
//	Checks all solid vertices (that is vertices in the joints of solid
//  lines) and returns false if a traverse direction passes through any
//  of them.
//
//===========================================================================

bool CheckSolidVertexTraverse(sector_t * sec, TVec from, TVec to)
{
	int i;
	line_t * line;
	TVec * lastv1;
	TVec * lastv2;

	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		// single-sided line
		if (!(line->flags & ML_TWOSIDED) || (line->flags & ML_BLOCKING) ||
			(line->flags & ML_BLOCKEVERYTHING) ||
				!line->backsector)
		{
			if (line->v1 != lastv1 && line->v1 != lastv2)
			{
				if (to.x == from.x)
				{
					if (to.x == line->v1->x && to.y - from.y >= to.y - line->v1->y)
					{
						return false;
					}
				}
				else if (to.y == from.y)
				{
					if (to.y == line->v1->y && to.x - from.x >= to.x - line->v1->x)
					{
						return false;
					}
				}
				else if ( (to.x - from.x)/(to.y - from.y) == (to.x - line->v1->x)/(to.y - line->v1->y) )
				{
					return false;
				}
			}
			if (line->v2 != lastv1 && line->v2 != lastv2)
			{
				if (to.x == from.x)
				{
					if (to.x == line->v2->x && to.y - from.y >= to.y - line->v2->y)
					{
						return false;
					}
				}
				else if (to.y == from.y)
				{
					if (to.x == line->v2->y && to.x - from.x >= to.x - line->v2->x)
					{
						return false;
					}
				}
				else if ( (to.x - from.x)/(to.y - from.y) == (to.x - line->v2->x)/(to.y - line->v2->y) )
				{
					return false;
				}
			}
			lastv1 = line->v1;
			lastv2 = line->v2;
		}
	}

	return true;
}

#endif

//===========================================================================
//
//  BuildPriorityPaths
//
//	Build paths between Priority Nodes.
//
//===========================================================================

void BuildPriorityPaths()
{
	int i, j, k;
	bool found;
	PriorityNode PNFrom;
	PriorityNode PNTo;
	Route _Route;

	// #ifdef DEBUG_PATH_NODES
	//
	// Debug statistics
	//------------------------
	int			stats_TotalPriorityNodes = 0;
	int			stats_TotalPaths = 0;
	int			stats_TotalLinkedPNodes = 0;
	int			stats_TotalUnlinkedPNodes = 0;
	int			stats_AveragePathsPerNode = 0;
	int			stats_MaximalPathNodeLength = 0;
	int			stats_MinimalPathNodeLength = -1;
	// etc etc etc.....
	//------------------------
	//
	// #endif

	foreach AllThinkers(PriorityNode, PNFrom)
	{
		stats_TotalPriorityNodes++;

		foreach AllThinkers(PriorityNode, PNTo)
		{
			if (PNTo == PNFrom)
			{
				continue;
			}

			found = false;
			for (i = 0; i < PNFrom.Paths.Num; i++)
			{
				if (PNFrom.Paths[i].Nodes[0] == PNTo ||
					PNFrom.Paths[i].Nodes[PNFrom.Paths[i].Nodes.Num - 1] == PNTo)
				{
					found = true;
					break;
				}
			}

			if (found)
				continue;

			if (BuildWaypoints(PNFrom, PNTo, _Route))
			{
				if (!PNFrom.Paths.Num)
					stats_TotalLinkedPNodes++;
				if (!PNTo.Paths.Num)
					stats_TotalLinkedPNodes++;

				stats_TotalPaths++;

				PNFrom.Paths.Num = PNFrom.Paths.Num + 1;
				PNFrom.Paths[PNFrom.Paths.Num - 1] = _Route;
				PNTo.Paths.Num = PNTo.Paths.Num + 1;
				PNTo.Paths[PNTo.Paths.Num - 1] = _Route;
			}
		}

		//-------------------------------------------------------------------------

		if (PNFrom.Paths.Num)
		{
			// Search all routes incoming from PNode and remove the ones that
			// include other PNodes between start and end points
			for (i = 0; i < PNFrom.Paths.Num; i++)
			{
				Route R = PNFrom.Paths[i];

				if (R.Nodes.Num == 2)
					continue;

				found = false;
				for (j = 1; j < R.Nodes.Num - 1; j++)
				{
					if (R.Nodes[j].Class == PriorityNode || ClassIsChildOf(R.Nodes[j].Class, PriorityNode))
					{
						found = true;
						break;
					}
				}

				if (found)
				{
					// Remove excessive route from both PNodes' lists
					for (j = i + 1; j < PNFrom.Paths.Num; j++)
					{
						PNFrom.Paths[j - 1] = PNFrom.Paths[j];
					}
					PNFrom.Paths.Num = PNFrom.Paths.Num - 1;
					i--;

					PNTo = PriorityNode(R.Nodes[R.Nodes.Num - 1]);
					for (j = 0; j < PNTo.Paths.Num; j++)
					{
						if (PNTo.Paths[j] == R)
						{
							for (k = j + 1; k < PNTo.Paths.Num; k++)
							{
								PNTo.Paths[k - 1] = PNTo.Paths[k];
							}
							PNTo.Paths.Num = PNTo.Paths.Num - 1;
							break;
						}
					}

					R.Destroy();

					stats_TotalPaths--;

					if (!PNFrom.Paths.Num)
					{
						stats_TotalLinkedPNodes--;
						stats_TotalUnlinkedPNodes++;
					}
					if (!PNTo.Paths.Num)
					{
						stats_TotalLinkedPNodes--;
						stats_TotalUnlinkedPNodes++;
					}
				}
#ifdef DEBUG_PRIORITY_PATHS
				else
				{
					PNTo = PriorityNode(R.Nodes[R.Nodes.Num - 1]);
					print("PPath: %v -> %v",
						PNFrom.Origin.x, PNFrom.Origin.y, PNFrom.Origin.z,
						PNTo.Origin.x, PNTo.Origin.y, PNTo.Origin.z);
				}
#endif
			}
		}
		else
		{
			stats_TotalUnlinkedPNodes++;
		}
	}

	if (stats_TotalPriorityNodes)
		stats_AveragePathsPerNode = stats_TotalPaths / (stats_TotalPriorityNodes / 2);

	#ifdef DEBUG_PATH_NODES
	//
	// Debug info output
	//------------------------
	print("");
	print(" ========== Priority Paths Info ===========");
	print("   Total Priority Nodes found:      %i      ", stats_TotalPriorityNodes);
	print("   Total Bidirect Paths built:     %i      ", stats_TotalPaths);
	print("   Total PNodes with Paths:        %i      ", stats_TotalLinkedPNodes);
	print("   Total PNodes without Paths      %i      ", stats_TotalUnlinkedPNodes);
	print("   Average Paths per PNode:        %i      ", stats_AveragePathsPerNode);
	print("   Maximal Path Length in Nodes:   %i      ", stats_MaximalPathNodeLength);
	print("   Minimal Path Length in Modes:   %i      ", stats_MinimalPathNodeLength);
	print(" ===========================================");
	print("");
	//------------------------
	//
	#endif
}

//
// Extra settings for BuildWaypoints procedure
//
struct routebuild_t
{
	bool bBuilding;
	int ContinuesCount;
	int ContinuesLimit;
	int IterationsCount;
	int IterationsLimit;
	LinkedList RouteList;

	IntelligentActor IA;
	float Height;
	float MaxStepHeight;
	float MaxJumpHeight;
	float MaxDropoffHeight;
};

//==========================================================================
//
//	BuildWaypoints
//
//	There are two Route types: common route and priority route.
//	Common route is defined by a sequence of basic Nodes connected by basic
//	node links. Priority route uses Priority Nodes connected by
//	precalculated Paths between them.
//
//	Since both route types are being built using same algorythm, actual
//	route type is determined by RouteClass parameter.
//
//==========================================================================

bool BuildWaypoints(Node N_From, Node N_To, out Route _Route, optional class<Node> RouteClass,
					optional routebuild_t * routebuild)
{	
	//
	// Algorythm for optimal route build, as written in AI Tutorial :)
	//
	//	 create a list P
	//	 add the start node S, to P giving it one element
	//	 Until first path of P ends with G, or P is empty
	//		extract the first path from P
    //		extend first path one step to all neighbors creating X new paths
    //		reject all paths with loops
    //			for all paths that end at the same node,
	//								keep only the shortest one.
	//		add each remaining new path to of P
    //		Sort all paths by total underestimate, shortest first.
	//	 If G found -> success. Else -> failure.
	//
	//	total underestimate is:
	//		distance of partial path travelled + straight-line distance
	//										from last node in path to goal
	//
	//

	bool						failed;
	LinkedList					RouteList;
	LinkedList					route_list;
	Route						R;
	routebuild_t				_routebuild;

	if (!specified_routebuild)
	{
		_routebuild.Height = 0.0;
		_routebuild.MaxStepHeight = EntityEx::FLOATRANDZ;
		_routebuild.MaxJumpHeight = EntityEx::FLOATRANDZ;
		_routebuild.MaxDropoffHeight = EntityEx::FLOATRANDZ;
		routebuild = &_routebuild;
	}

	if (!specified_RouteClass)
		RouteClass = Node;

	failed = false;

	if (routebuild->bBuilding)
	{
		routebuild->ContinuesCount++;
		routebuild->IterationsCount = 0;
		RouteList = routebuild->RouteList;
	}
	else
	{
		R = Route(SpawnObject(Route));
		R.RouteClass = RouteClass;
		R.Nodes.Num = 1;
		R.Nodes[0] = N_From;

		if (N_From == N_To)
		{
			_Route = R;
			return true;
		}

		routebuild->bBuilding = true;
		routebuild->ContinuesCount = 0;
		routebuild->IterationsCount = 0;

		RouteList = LinkedList(SpawnObject(LinkedList));
		routebuild->RouteList = RouteList;
		RouteList.Add(R);
	}

	route_list = LinkedList(SpawnObject(LinkedList));
	while (!IsNodeInRoute(Route(RouteList.refHead), N_To))
	{
		if (routebuild->IterationsLimit && routebuild->IterationsCount == routebuild->IterationsLimit)
		{
			if (routebuild->ContinuesLimit && routebuild->ContinuesCount == routebuild->ContinuesLimit)
			{
				failed = true;
				break;
			}

			route_list.Destroy();
			return false;
		}

		R = Route(RouteList.refHead);
		route_list.Add(R);

		ExtendRoute(route_list, N_To, routebuild);

		if (route_list.refHead != none)
			AddExtendedRoutes(route_list, RouteList);
		ExcludeExcessRoutes(RouteList);
		if (RouteList.refHead == none)
		{
			failed = true;
			break;
		}
		routebuild->IterationsCount++;
	};
	routebuild->bBuilding = false;

	if (!failed)
	{
		// Store successful route, destroy others
		_Route = Route(RouteList.refHead);
		RouteList.refHead.UnlinkFromList();
	}
	route_list.Destroy();
	RouteList.Destroy();
	RouteList = none;

	return !failed;
}

//==========================================================================
//
//	IsNodeInRoute
//
//==========================================================================

bool IsNodeInRoute(Route R, Node N)
{
	int i;
	
	for (i = 0; i < R.Nodes.Num; i++)
	{
		if (R.Nodes[i] == N)
			return true;
	}
	
	return false;
}

//==========================================================================
//
//	ExtendRoute
//
//	It is assumed that route list passed to this method contains
//	only one route that need to be extended.
//
//==========================================================================

void ExtendRoute(LinkedList route_list, Node NDest, routebuild_t * routebuild)
{
	if (route_list.refHead == none)
		return;

	int i, j;
	bool found;
	float PreviousMeasure;
	float LinkMeasureFactor;
	Route R;
	Route ExtendableRoute;
	Node NExtendable;
	Node N;
	
	ExtendableRoute = Route(route_list.refHead);
	
	PreviousMeasure = ExtendableRoute.Measure;
	NExtendable = ExtendableRoute.Nodes[ExtendableRoute.Nodes.Num - 1]; 
	
	// Do extension
	for (i = 0; i < NExtendable.Links.Num; i++)
	{
		if (ExtendableRoute.RouteClass == PriorityNode)
		{
			// We are interested only in either the first or the last node from the route
			// (since it should be PNode)
			if (NExtendable == PriorityNode(NExtendable).Paths[i].Nodes[0])
			{
				N = PriorityNode(NExtendable).Paths[i].Nodes[PriorityNode(NExtendable).Paths[i].Nodes.Num - 1];
			}
			else
			{
				N = PriorityNode(NExtendable).Paths[i].Nodes[0];
			}
		}
		else
			N = NExtendable.Links[i].node;
		
		found = false;
		// Check if this node isn't already in route
		for (j = 0; j < Route(route_list.refHead).Nodes.Num; j++)
		{
			if (Route(route_list.refHead).Nodes[j] == N)
			{
				found = true;
				break;
			}
		}
		if (found)
			continue;
	
		// Test current link for pawn's reachability
		if (ExtendableRoute.RouteClass == PriorityNode)
		{
			if (routebuild->IA)
			{
				// FIXME!!!!!
				// TODO!!
				//LinkMeasureFactor = routebuild->IA.GetNodeLinkMeasureFactor(NExtendable, i);
			}
			else
			{
				LinkMeasureFactor = PriorityNode(NExtendable).Paths[i].Measure;
			}
		}
		else
		{
			if (routebuild->IA)
			{
				LinkMeasureFactor = routebuild->IA.GetNodeLinkMeasureFactor(NExtendable, i);
			}
			else
			{
				LinkMeasureFactor = GetNodeLinkFormalMeasureFactor(NExtendable, i, routebuild);
			}
		}
		
		if (LinkMeasureFactor <= 0.0)
		{
			continue;
		}
		
		R = Route(SpawnObject(Route));
		R.RouteClass = ExtendableRoute.RouteClass;
		route_list.Add(R);
		ExtendableRoute = R;

		// Calculate underestimate
		if (PreviousMeasure > 0.0)
			ExtendableRoute.Measure = PreviousMeasure - Length(NDest.Origin - NExtendable.Origin);
		else
			ExtendableRoute.Measure = 0.0;

		if (ExtendableRoute.RouteClass == PriorityNode)
			ExtendableRoute.Measure += LinkMeasureFactor;
		else
			ExtendableRoute.Measure += NExtendable.Links[i].length * LinkMeasureFactor;

		ExtendableRoute.Measure += Length(NDest.Origin - N.Origin);
		
		// Copy head route original nodes to the new one
		for (j = 0; j < Route(route_list.refHead).Nodes.Num; j++)
			ExtendableRoute.Nodes[j] = Route(route_list.refHead).Nodes[j];
			
		// Add new node
		ExtendableRoute.Nodes.Num = ExtendableRoute.Nodes.Num + 1;
		ExtendableRoute.Nodes[ExtendableRoute.Nodes.Num - 1] = N;
	}
	
	// Remove original head route
	route_list.DestroyObject(route_list.refHead);
}

//==========================================================================
//
//	GetNodeLinkFormalMeasureFactor
//
//==========================================================================

float GetNodeLinkFormalMeasureFactor(Node NOrigin, int iLink, routebuild_t * routebuild)
{
	// Default test is made to know if player has physical chance
	// to pass by the link

	// Minimal vertical space
	if (NOrigin.Links[iLink].minyspace < routebuild->Height)
		return -1.0;

	// Maximal step
	if (NOrigin.Links[iLink].maxstepheight >
			(routebuild->MaxJumpHeight > routebuild->MaxStepHeight ? routebuild->MaxJumpHeight : routebuild->MaxStepHeight))
		return -1.0;

	// Maximal dropoff
	if (NOrigin.Links[iLink].maxdropoff > routebuild->MaxDropoffHeight)
		return -1.0;

	return 1.0;
}

//==========================================================================
//
//	ExcludeExcessRoutes
//
//==========================================================================

void ExcludeExcessRoutes(LinkedList route_list)
{
	if (route_list.refHead == none)
		return;
	
	int i;
	bool found, lightest_saved, rpass_excluded;
	Route RPass;
	Route RSeek;
	Route RSeekEnd;
	Route RExclude;
	Node NEnding;
	float LighterMeasure;
	
	RPass = Route(route_list.refHead);
	while (RPass != none)
	{
		// Remember RPass'es last Node and route Measure
		NEnding = RPass.Nodes[RPass.Nodes.Num - 1];
		LighterMeasure = RPass.Measure;
		
		// Pass through the left of the route list, seeking for routes with same ending
		found = false;
		RSeek = Route(RPass.refNext);
		while (RSeek != none)
		{
			if (RSeek.Nodes[RSeek.Nodes.Num - 1] == NEnding)
			{
				found = true;
				if (RSeek.Measure < LighterMeasure)
					LighterMeasure = RSeek.Measure;
			}
			
			RSeekEnd = RSeek;
			RSeek = Route(RSeek.refNext);
		};
		
		// If any route with same ending was found, remove each of them, that have
		// heavier measure than stored in LighterMeasure
		if (found)
		{
			found = false;				// [CW] used here for detecting last check candidate
			rpass_excluded = false;
			lightest_saved = false;
			
			RSeek = RPass;
			while (RSeek != none)
			{
				RExclude = none;
				if (RSeek.Nodes[RSeek.Nodes.Num - 1] == NEnding)
				{
					if (RSeek.Measure > LighterMeasure)
						RExclude = RSeek;
					else if (RSeek.Measure == LighterMeasure)
					{
						if (lightest_saved)
							RExclude = RSeek;
						else
							lightest_saved = true;
					}
				}
			
				if (RSeek == RSeekEnd)
					found = true;			// [CW] no need to search any more
				else
					RSeek = Route(RSeek.refNext);
					
				if (RExclude != none)
				{
					if (RPass == RExclude)
					{
						rpass_excluded = true;
						RPass = Route(RPass.refNext);
					}
					route_list.DestroyObject(RExclude);
				}
					
				if (found)
					break;
			};
		}
		
		if (rpass_excluded)
			rpass_excluded = false;
		else
			RPass = Route(RPass.refNext);
	};
}

//==========================================================================
//
//	AddExtendedRoutes
//
//==========================================================================

void AddExtendedRoutes(LinkedList extended_route_list, LinkedList route_list)
{
	if (extended_route_list.refHead == none)
		return;

	float HeaviestExtendedMeasure;
	Route R;
	Route HeaviestRoute;
	LinkedList sort_extended_route_list = LinkedList(SpawnObject(LinkedList));
	
	// Find largest measure in extended routes
	HeaviestExtendedMeasure = -1.0;
	R = Route(extended_route_list.refHead);
	while (R != none)
	{
		if (HeaviestExtendedMeasure < 0.0 || R.Measure > HeaviestExtendedMeasure)
		{
			HeaviestExtendedMeasure = R.Measure;
			HeaviestRoute = R;
		}
			
		R = Route(R.refNext);
	};

	// Find all previously existed routes from the list that
	// have lighter measures and move them to extended routes list
	R = Route(route_list.refHead);
	while (R != none)
	{
		if (R.Measure < HeaviestExtendedMeasure)
		{
			extended_route_list.Add(R);
		}
		R = Route(R.refNext);
	};
	
	//
	// Sort extended routes list
	//
	sort_extended_route_list.Add(HeaviestRoute);
	
	while (extended_route_list.refHead != none)
	{
		HeaviestExtendedMeasure = -1.0;
		R = Route(extended_route_list.refHead);
		while (R != none)
		{
			if (HeaviestExtendedMeasure < 0.0 || R.Measure > HeaviestExtendedMeasure)
			{
				HeaviestExtendedMeasure = R.Measure;
				HeaviestRoute = R;
			}			
			R = Route(R.refNext);
		};
		
		sort_extended_route_list.AddFront(HeaviestRoute);
	};
	
	//
	// Add sorted routes list at the beginning of the remaining old routes list
	//
	route_list.MoveContentsFront(sort_extended_route_list);
	
	
	sort_extended_route_list.Destroy();
}



#ifdef OBSOLETE

//===========================================================================
//
//  BuildPaths
//
//	Make special connections between path nodes (if any of them exist)
//
//===========================================================================

void BuildPaths()
{
	PathNode	PN_Base;
	PathNode	PN_Candidate;
	int			PathIndex;
	int			PNIndex;
	bool		bPNLinked;

	//
	// Debug statistics
	//------------------------
	int			stats_TotalPathNodes = 0;
	int			stats_TotalLinkedPathNodes = 0;
	int			stats_TotalUnlinkedPathNodes = 0;
	int			stats_TotalPaths = 0;
	int			stats_AverageNodesPerPath = 0;
	float		stats_MaximalLinkLength = 0.0;
	float		stats_MinimalLinkLength = -1.0;
	float		stats_MaximalPathLength = 0.0;
	float		stats_MinimalPathLength = -1.0;
	// etc etc etc.....
	//------------------------
	//


	foreach AllThinkers(PathNode, PN_Base)
	{
		bPNLinked = false;
		stats_TotalPathNodes++;

		PathIndex = PN_Base.Args[PathNode::ARG__PATHINDEX];
		PNIndex = PN_Base.Args[PathNode::ARG__NODEINDEX];

		// Find next path node
		PN_Candidate = none;
		foreach AllThinkers(PathNode, PN_Candidate)
		{
			if (PN_Candidate == PN_Base)
				continue;

			if (PN_Candidate.Args[PathNode::ARG__PATHINDEX] == PathIndex &&
					PN_Candidate.Args[PathNode::ARG__NODEINDEX] == PNIndex + 1)
			{
				PN_Base.FW = PN_Candidate;
				bPNLinked = true;
				break;
			}
		}

		// Find prev path node
		PN_Candidate = none;
		foreach AllThinkers(PathNode, PN_Candidate)
		{
			if (PN_Candidate == PN_Base)
				continue;

			if (PN_Candidate.Args[PathNode::ARG__PATHINDEX] == PathIndex &&
					PN_Candidate.Args[PathNode::ARG__NODEINDEX] == PNIndex - 1)
			{
				PN_Base.BW = PN_Candidate;
				bPNLinked = true;
				break;
			}
		}

		if (bPNLinked)
			stats_TotalLinkedPathNodes++;
		else
			stats_TotalUnlinkedPathNodes++;
	}

	//
	// Debug info output
	//------------------------
	print("");
	print(" ================ Paths Info ===============");
	print("   Total Path Nodes found:          %i      ", stats_TotalPathNodes);
	print("   Total Linked Path Nodes:         %i      ", stats_TotalLinkedPathNodes);
	print("   Total Unlinked Path Nodes:       %i      ", stats_TotalUnlinkedPathNodes);
	print(" ===========================================");
	print("");
	//------------------------
	//
}

#endif

defaultproperties
{
}
