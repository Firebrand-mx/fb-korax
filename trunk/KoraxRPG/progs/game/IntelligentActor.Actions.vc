//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ## ###  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**				   ######  #####   ######
//**	               ##   ## ##  ## ##    ##
//**	     		   ##   ## ##  ## ##   
//**	               #####   #####  ##  ####
//**	     		   ## ###  ##     ###   ##
//**	     		   ##  ### ##      ######
//**
//**    $Id: IntelligentActor.vc 1963 2009-03-06 23:26:20Z crimsonwizard $
//**
//**    Copyright (C) 2004-2008 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//==========================================================================
//
//  A_KRPGPain
//
// [FB] This one will become handy for things that change when monsters are
//	     damaged (i.e. Set Damage skins)
//
//==========================================================================

void A_KRPGPain()
{
	::A_KRPGPain();

	// [FB] Take the chance to get berserk
	if (bCanBerserk && Health < (default.Health >> 1) &&
		(1 + (P_Random() & 7)) > 5 && !GetCondition(ACSpellBerserk))
	{
		// [CW] TODO: this should be done by monster using spell item instead
		CastCondition(
			ACSpellBerserk,				// condition class
			false,						// not accumulative
			self,						// instigator (caster)
			1,							// spell level (should be calculated somehow?)
										// duration
			(1.0 + itof(P_Random() & 7) * 80.0) / 35.0 // FIXME: Should we determine it somehow else??
			);
	}
}

//==========================================================================
//
//	FireDemonSpecialMove
//
//==========================================================================

final bool FireDemonSpecialMove()
{
	float dist;
	float ang;

	// Float up and down
	Origin.z += Level.Game.FloatBobOffsets[Special1];
	Special1 = (Special1 + 2) & 63;


	// Insure it stays above certain height
	if (Origin.z < FloorZ + 64.0)
	{
		Origin.z += 2.0;
	}

	if (true/*!Evade*/) // FIXME
	{
		if (Origin.z - pDestination->z > Height * 8.0)
		{
			Velocity.z -= 2.5;
		}
	}

	// Strafe
	if (Special2 > 0)
	{
		Special2--;
	}
	else if (Target)
	{
		Special2 = 0;
		Velocity.x = 0.0;
		Velocity.y = 0.0;
		dist = DistTo(Target);
		if (dist < FIREDEMON_ATTACK_RANGE)
		{
			if (P_Random() < 30)
			{
				ang = atan2(Target.Origin.y - Origin.y,
					Target.Origin.x - Origin.x);
				if (P_Random() < 128)
					ang = AngleMod360(ang + 90.0);
				else
					ang = AngleMod360(ang - 90.0);
				Velocity.x = 8.0 * cos(ang) * 35.0;
				Velocity.y = 8.0 * sin(ang) * 35.0;
				Special2 = 3;	// strafe time
			}
		}

		return true;
	}

	return false;
}

//==========================================================================
//
//  A_KRPGIceGuyLook
//
//==========================================================================

final void A_KRPGIceGuyLook()
{
	float dist;
	float an;
	class<Actor> tp;

	A_LookAI();
	if (Random() < 0.25)
	{
		dist = Radius * (Random() * 2.0 - 1.0);
		an = AngleMod360(Angles.yaw + 90.0);

		if (Random() < 0.5)
			tp = IceGuyWisp2;
		else
			tp = IceGuyWisp1;
		Spawn(tp, Origin + vector(dist * cos(an), dist * sin(an), 60.0));
	}
}

//==========================================================================
//
//  A_KRPGIceGuyChase
//
//==========================================================================

final void A_KRPGIceGuyChase()
{
	float dist;
	float an;
	Actor A;
	class<Actor> tp;

	A_ChaseAI();
	if (Random() < 0.5)
	{
		dist = Radius * (Random() * 2.0 - 1.0);
		an = AngleMod360(Angles.yaw + 90.0);

		if (Random() < 0.5)
			tp = IceGuyWisp2;
		else
			tp = IceGuyWisp1;
		A = Spawn(tp, Origin + vector(dist * cos(an), dist * sin(an), 60.0));
		if (A)
		{
			A.Velocity = Velocity;
			A.Target = self;
		}
	}
}

//==========================================================================
//
//	A_SerpentChase
//
//==========================================================================

bool A_SerpentChase(bool FastChase, state AIdleState, state AMeleeState, state AMissileState,
				bool NightmareFast, bool PlayActive, bool DontMove)
{
	//DoChase(false, MeleeState, none, true, true);
	return DoMove(false/*FastChase*/, AIdleState, AMeleeState, none,
		true/*NightmareFast*/, PlayActive, DontMove);
}

//==========================================================================
//
//	A_SerpentChaseAI
//
//==========================================================================

final void A_SerpentChaseAI()
{
	DoMoveR = A_SerpentChase;
	A_ChaseAI();
}

//==========================================================================
//
//  A_SerpentWalk
//
//  Similar to A_Chase, only has a hardcoded entering of meleestate.
//
//==========================================================================

bool A_SerpentWalk(bool FastChase, state AIdleState, state AMeleeState, state AMissileState,
				bool NightmareFast, bool PlayActive, bool DontMove)
{
	//DoChase(false, FindState('Attack'), none, true, false);
	return DoMove(false/*FastChase*/, AIdleState, FindState('Attack'), none,
		true/*NightmareFast*/, false/*PlayActive*/, DontMove);
}

//==========================================================================
//
//	A_SerpentWalkAI
//
//==========================================================================

final void A_SerpentWalkAI()
{
	DoMoveR = A_SerpentWalk;
	A_ChaseAI();
}

//==========================================================================
//
//  A_WraithChaseAI
//
//==========================================================================

final void A_WraithChaseAI()
{
	Origin.z += Level.Game.FloatBobOffsets[Special1];
	Special1 = (Special1 + 2) & 63;
//  if (actor->FloorClip > 0)
//  {
//      SetState(S_WRAITH_RAISE2);
//      return;
//  }
	A_ChaseAI();
	A_WraithFX4();
}

//==========================================================================
//
//	A_DragonFlightAI
//
//==========================================================================

final void A_DragonFlightAI()
{
	float angle;

	DragonSeek(4.0, 8.0);
	if (Target)
	{
		if (!Target.bShootable)
		{
			// enemy died
			Target = none;
			return;
		}
		angle = atan2(Target.Origin.y - Origin.y, Target.Origin.x - Origin.x);
		if (fabs(AngleMod180(Angles.yaw - angle)) < 45.0 / 2.0
			&& CheckMeleeRange())
		{
			Target.Damage(self, self, HITDICE(8));
			PlaySound('DragonAttack', CHAN_WEAPON);
		}
		else if (fabs(AngleMod180(Angles.yaw - angle)) <= 20.0)
		{
			SetState(MissileState);
			PlaySound('DragonAttack', CHAN_WEAPON);
		}
	}
	else
	{
		LookForEnemy(true);	// KoraxRPG
	}
}

//==========================================================================
//
//	A_DragonFlapAI
//
//==========================================================================

final void A_DragonFlapAI()
{
	A_DragonFlightAI();
	if (P_Random() < 240)
	{
		PlaySound('DragonWingflap', CHAN_BODY);
	}
	else
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_MartyrFlight
//
//==========================================================================

final void A_MartyrFlight()
{
	A_SpawnItem(FireDemonMartyrFX2);
	A_JumpIfCloser(128.0, FindState('Explode'));
}


defaultproperties
{
	Behavior.ThreatReaction			= THREATREACTION__DETECT;
	Behavior.ThreatVicinity			= DEFAULT_THREAT_VICINITY;

	bNoWanderDuringAttack = false;
	bEvadeMelee			= false;
	bRunOnEvade			= false;

	bCanJoinTaskGroup				= true;
	bCanBeTaskLeader		= true;

	bNeverUseRoutes		= false;

	Behavior.RouteRebuildRate		= 512;
	Behavior.RouteRebuildRateLow	= 1024;
	Behavior.LostFTargetTolerance	= 32;
	Behavior.FTargetPosChangeLimit	= 512.0;

	bNeverTarget = false;

	bNonScalable = false;
	bCombatant = true;
}
