//------------------------------------------------------------
//
// KRPGActor extends basic Hexen Actor class and is made
// as a separate type only for convenience
//
//------------------------------------------------------------

class KRPGActor : Actor
	abstract;

//
// [KoraxRPG] Advanced behavior
//
bool			bReflectMissileDamage;	// invulnerable to missile weapons except for
										// blaster and ripping ones
bool			bNonScalable;	// Deny scalin variations
bool			bXYAnchored;	// Stuck in floor/ceiling (won't move freely along X & Y axes)
bool			bZAnchored;		// Stuck in floor/ceiling (won't move freely along Z axis)

bool			bCombatant;		// fighting actor

bool			bSenseAlways;	// detects target without seeing it

bool			bMirrorImage;	// actor is a magic clone that dies from a single hit
KRPGActor		MirrorMaster;
bool			bLiving;		// has a chance to spawn "dying spirit" on death
								// [CW] currently just for fun, though it may get some sense later

bool			bSaddleHorse;	// actor can be ridden by pawns
bool			bIsMountedOn;
bool			bRideControl;
KRPGActor		RidePartner;	// either 'rider' or 'horse', depending on flags


//
// [KoraxRPG] Advanced AI
//
const float	DEFAULT_THREAT_VICINITY		= MISSILERANGE;

TVec *			pTargetVec;

const float HIGH_ALERTNESS				= 10.0;

float			Alertness;		// while alert, creature will look for enemies all around
bool			bIgnoreTeams;
int				Team;

//
// [KoraxRPG] Actor Conditions
//
//LinkedList Conditions;
array<ActorCondition> Conditions;



//==========================================================================
//
//	BeginPlay
//
//==========================================================================

void BeginPlay()
{
	::BeginPlay();
	if (!bNonScalable)
	{
		float rand = (Random() - 0.5) * 0.15;
		//float rand = -0.5;
		ScaleX += ScaleX * rand;
		ScaleY += ScaleY * rand;
		Height += Height * rand;
		Radius += Radius * rand;
	}
}

//==========================================================================
//
//  Thrust3d
//
//	[CW] A three-dimensional vector variant of Thrust, that
//		 uses vector angles and single vector length.
//
//==========================================================================

void Thrust3d(float angle2d, float angle3, float move)
{
	Thrust(angle2d, move * cos(angle3));
	Velocity.z += move * sin(angle3) * 35.0;
}

//==========================================================================
//
//  Thrust3d2
//
//	[CW] Variant of Thrust3d, that allows explicit definition
//	     of horizontal and vertical velocities.
//
//==========================================================================

void Thrust3d2(float angle2d, float move2d, float move3)
{
	Thrust(angle2d, move2d);
	Velocity.z += move3 * 35.0;
}

//==========================================================================
//
//	Kill
//
//==========================================================================

void Kill(optional EntityEx inflictor, optional EntityEx source, optional bool bXDeath, optional name DamageType)
{
	Damage(inflictor, source, bXDeath ? Health - GibsHealth + 1 : Health + 1,
		specified_DamageType ? DamageType : 'InstantKill');
}

//==========================================================================
//
//	Physics
//
//==========================================================================

bool Physics(float DeltaTime)
{
	if (bXYAnchored)
	{
		Velocity.x = 0.0;
		Velocity.y = 0.0;
	}

	if (bZAnchored)
		Velocity.z = 0.0;

	if (RidePartner)
	{
		if (bIsMountedOn)
		{
			TVec saddle = RidePartner.Origin;
			saddle.z += RidePartner.Height;

			Velocity = RidePartner.Velocity + ((saddle - Origin) * 5.0);

			float lx = Origin.x - saddle.x;
			float ly = Origin.y - saddle.y;
			float limit = (RidePartner.Radius + Radius) * 2.0;

			if (fabs(lx) > limit|| fabs(ly) > limit)
				Dismount();
		}
	}

	return ::Physics(DeltaTime);
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	if (bMirrorImage && (!MirrorMaster || MirrorMaster.Health <= 0))
		Kill();
	if (Alertness > 0.0)
		Alertness -= deltaTime;
	::Tick(deltaTime);
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
	if (RidePartner)
	{
		if (bIsMountedOn) Dismount();
		else RidePartner.Dismount();
	}

	Target = none;

	::Died(source, inflictor);

	NotifyConditions(ActorCondition::notify_RecepientDead, source, 0);

	if (!bMirrorImage && bLiving && P_Random() < 33)
	{
		Spawn(DyingSpirit, Origin);
	}
}

//==========================================================================
//
//	A_Resurrect
//
//==========================================================================

final void A_Resurrect()
{
	A_DeQueueCorpse();

	bSolid = default.bSolid;
	bShootable = default.bShootable;
	bFloat = default.bFloat;
	bSkullFly = default.bSkullFly;
	bNoGravity = default.bNoGravity;
	bDropOff = default.bDropOff;
	bCorpse = false;
	bNoPassMobj = default.bNoPassMobj;

	bDynamicLight = default.bDynamicLight;
	bMuzzleFlash = default.bMuzzleFlash;
	bLeaveTrail = default.bLeaveTrail;

	Health = default.Health;
	Height = default.Height;

	Alpha = default.Alpha;
}

//==========================================================================
//
//  TakeSpecialDamage
//
//	[CW] Handles some special flags
//
//==========================================================================

int TakeSpecialDamage(EntityEx inflictor, EntityEx source, int damage,
	name DmgType)
{
	if (bReflectMissileDamage &&
			inflictor.bMissile && !inflictor.bBlaster && !inflictor.bRip)
		return -1;
	if (bMirrorImage)
	{
		Health = 0;
		if (SetState(FindState('MirrorDeath')))
			return -1;
		else
			return 0;	// [CW] process death normally
	}
	return damage;
}

//==========================================================================
//
//  OkayToSwitchTarget
//
//==========================================================================

bool OkayToSwitchTarget(EntityEx source)
{
	Alertness = HIGH_ALERTNESS;

	// [CW] TODO: add extra conditions here?
	if (!bIgnoreTeams && source.IsA('KRPGActor') && Team == KRPGActor(source).Team)
	{
		return false;
	}

	return ::OkayToSwitchTarget(source);
}

//==========================================================================
//
//	IsBeingUsed
//
//	[CW] Override for actors that could be 'used'
//
//==========================================================================

bool IsBeingUsed(Pawn User)
{
	return false;
}

//==========================================================================
//
//	MountOn
//
//==========================================================================

void MountOn(KRPGActor Horse, bool bGainControl)
{
	RidePartner = Horse;
	bIsMountedOn = true;
	bRideControl = bGainControl;
	bXYAnchored = true;
	bZAnchored = true;
	Horse.IsBeingMountedOn(self, !bGainControl);
}

//==========================================================================
//
//	IsBeingMountedOn
//
//	[CW] Override for extra effects
//
//==========================================================================

void IsBeingMountedOn(KRPGActor Rider, bool bGainControl)
{
	RidePartner = Rider;
	bIsMountedOn = false;
	bRideControl = bGainControl;
}

//==========================================================================
//
//	Dismount
//
//==========================================================================

void Dismount()
{
	bIsMountedOn = false;
	bRideControl = false;
	bXYAnchored = default.bXYAnchored;
	bZAnchored = default.bZAnchored;
	RidePartner.IsBeingDismountedFrom();
	RidePartner = none;
}

//==========================================================================
//
//	IsBeingDismountedFrom
//
//	[CW] Override for extra effects
//
//==========================================================================

void IsBeingDismountedFrom()
{
	RidePartner = none;
	bRideControl = false;
}

//==========================================================================
//
//	RideCommand
//
//	[CW] override for different behavior
//
//==========================================================================

void RideCommand(float forward, float side, optional float vertical)
{
	if (forward)
	{
		Velocity.x += forward * cos(Angles.yaw);
		Velocity.y += forward * sin(Angles.yaw);
	}
	if (side)
	{
		float angle = AngleMod360(Angles.yaw - 90.0);
		Velocity.x += side * cos(angle);
		Velocity.y += side * sin(angle);
	}
}

//**************************************************************************
//
//
//	[KoraxRPG] Advanced AI
//
//
//**************************************************************************

//==========================================================================
//
//	SetTeam
//
//==========================================================================

void SetTeam(int team)
{
	Team = team;

	//
	// TODO: special code needed for Intelligent Actors
	//

	if (bCombatant && Target && Target.IsA('KRPGActor') && KRPGActor(Target).Team == Team)
	{
		Target = none;
		SetState(IdleState);
	}

	KRPGActor A;
	foreach AllThinkers(KRPGActor, A)
	{
		if (A.bCombatant && A.Target == self && A.Team == Team)
		{
			A.Target = none;
			A.SetState(IdleState);
		}
	}
}

//==========================================================================
//
//	LookForEnemy
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool LookForEnemy(bool allaround, optional bool nearest,
					optional TVec At, optional float maxdist, optional Actor ExcludeActor)
{
	Actor		mo;
	float		an;
	float		dist;
	float		min_dist;

	if (!specified_nearest)
		nearest = true;

	if (!specified_At)
		At = Origin;

	if (!specified_maxdist)
		maxdist = DEFAULT_THREAT_VICINITY;

	if (!specified_ExcludeActor)
		ExcludeActor = none;

	Actor NewTarget;
	min_dist = -1.0;

	foreach AllThinkers(Actor, mo)
	{
		if (mo == self)
			continue;	// self

		if (mo == ExcludeActor)
			continue;

		if (!mo.bShootable || mo.bNonShootable || mo.bDormant || mo.bInvulnerable || mo.bNeverTarget)
			continue;

		if (mo.Health <= 0)
			continue;	// dead

		if (!bIgnoreTeams && mo.IsA('KRPGActor') && (Team == KRPGActor(mo).Team))
			continue;	// friendly

		// TODO: extra parameter to ignore this
		if (!CanSee(mo))
			continue;	// out of sight

		if (Length(mo.GetCentre() - At) > maxdist)
			continue;

		if (P_Random() > 200)
			continue;	// sometimes skip

		if (!allaround && At == Origin)
		{
			dist = DistTo(mo);
			an = AngleMod360(atan2(mo.Origin.y - Origin.y,
				mo.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				//dist = DistTo(mo);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		dist = Length(mo.GetCentre() - At);

		if (nearest)
		{
			if (min_dist < 0.0 || min_dist > dist)
			{
				min_dist = dist;
				NewTarget = mo;
			}

			continue;
		}
		else
			NewTarget = mo;

		break;
	}

	if (NewTarget)
		Target = NewTarget;
	return NewTarget != none;
}

//==========================================================================
//
//	A_LookEx
//
//	[KoraxRPG] Advanced AI
//
//==========================================================================

bool A_LookEx(bool autoSetChase)
{
	EntityEx	targ;
	Entity		Ent;

	//	Set goal now if appropriate.
	if (Special == LNSPEC_ThingSetGoal && Args[0] == 0)
	{
		int Searcher = -1;
		Goal = none;
		for (Ent = Level.FindMobjFromTID(Args[1], &Searcher); Ent;
			Ent = Level.FindMobjFromTID(Args[1], &Searcher))
		{
			if (!PatrolPoint(Ent))
			{
				continue;
			}
			Goal = PatrolPoint(Ent);
			break;
		}
		Special = 0;
		ReactionTime = itof(Args[2]) + XLevel.Time;
		bChaseGoal = !!Args[3];
	}

	Threshold = 0;	// any shot will wake up
	pTargetVec = NULL;

	if (TIDToHate)
	{
		targ = Target;
	}
	else
	{
		targ = EntityEx(Sector->SoundTarget);
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (targ && targ.bShootable &&
		(!targ.IsA('KRPGActor') || bIgnoreTeams || Team != KRPGActor(targ).Team))
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForEnemy(false || (Alertness > 0.0)))
					return false;
			}
		}
	}
	else
	{
		if (!LookForEnemy(bLookAllAround || (Alertness > 0.0)))
			return false;
	}

	Alertness = HIGH_ALERTNESS;

	// go into chase state
	// Don't start chasing after a goal if it isn't time yet.
	if (Target == Goal)
	{
		if (ReactionTime > XLevel.Time)
		{
			Target = none;
		}
	}
	else if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (Target && autoSetChase)
		SetState(SeeState);
	return true;
}

//==========================================================================
//
//	A_LookExAuto
//
//	[KoraxRPG]
//
//==========================================================================

final void A_LookExAuto()
{
	A_LookEx(true);
}

//==========================================================================
//
//	DoSpecialMove
//
//	[KoraxRPG]
//
//	Returns TRUE if actor should skip normal movement
//
//==========================================================================

bool DoSpecialMove(bool Evade)
{
	return false;
}

//==========================================================================
//
//	A_DoMove
//
//	[KoraxRPG] Advanced AI
//
//	[CW] Currently an extended variant of ScriptedEntity::DoChase
//
//==========================================================================

bool A_DoMove(bool Evade, bool FastChase, state AIdleState, state AMeleeState, state AMissileState,
				bool NightmareFast, bool PlayActive)
{
	float		delta;
	float		dist;
	float		ang;
	float		oldX;
	float		oldY;
	int			oldFloor;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (ReactionCount)
	{
		ReactionCount--;
	}

	//	Remove muzzle flash.
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	if (!pTargetVec)
	{
		Error("KRPGActor::A_DoMove: called with pTargetVec = NULL");
		return false;
	}

	//bInCombat = true;	// CHECKME!
	//	Modify target threshold.
	if (Threshold)
	{
		if (!Target || Target.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (NightmareFast && Level.Game.fastparm)
	{
		//	Monsters move faster in nightmare mode.
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	//	Turn towards movement direction if not there yet.
	// killough 9/7/98: keep facing towards target if strafing or backing out
	if (Target && strafecount)
	{
		A_FaceTarget();
	}

	//	If the target is dead and not a goal, stop chasing it.
	if (Target && Target != Goal && Target.Health <= 0)
	{
		Target = none;
	}

	if (!Evade && (Target && !Target.bShootable))
	{
		Target = none;
		if (AIdleState)
		{
			SetState(AIdleState);
			//bInCombat = false;// CHECKME!!
		}
		return false;
	}

	//	Do not attack twice in a row.
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm && !DoSpecialMove(Evade))
		{
			NewChaseDirEx(Evade);
		}
		return true;
	}

	if (FastChase)
	{
		//	Strafe
		if (FastChaseStrafeCount > 0)
		{
			FastChaseStrafeCount--;
		}
		else
		{
			FastChaseStrafeCount = 0;
			Velocity.x = 0.0;
			Velocity.y = 0.0;
			dist = DistTo(Target);
			if (dist < 640.0)
			{
				if (P_Random() < 100)
				{
					ang = atan2(Target.Origin.y - Origin.y,
						Target.Origin.x - Origin.x);
					if (P_Random() < 128)
						ang = AngleMod360(ang + 90.0);
					else
						ang = AngleMod360(ang - 90.0);
					Velocity.x = 13.0 * cos(ang) * 35.0;
					Velocity.y = 13.0 * sin(ang) * 35.0;
					FastChaseStrafeCount = 3;	// strafe time
				}
			}
		}
	}

	//	Check for melee attack.
	if (!Evade && Target && AMeleeState && CheckMeleeRange())
	{
		if (AttackSound)
		{
			PlaySound(AttackSound, CHAN_WEAPON);
		}
		SetState(AMeleeState);
		return true;
	}

	//	Check for missile attack.
	if (AMissileState && Target)
	{
		if (Level.Game.fastparm || !MoveCount)
		{
			if (CheckMissileRange())
			{
				SetState(AMissileState);
				bJustAttacked = true;
				return true;
			}
		}
	}

	if (strafecount)
	{
		strafecount--;
	}

	//	Chase towards enemy.
	if (!DoSpecialMove(Evade) && (!FastChase || !FastChaseStrafeCount))
	{
		oldX = Origin.x;
		oldY = Origin.y;
		oldFloor = Sector->floor.pic;
		if (--MoveCount < 0 || !StepMoveEx())
		{
			NewChaseDirEx(Evade);
		}
		if (bCantLeaveFloorpic && Sector->floor.pic != oldFloor)
		{
			TryMove(vector(oldX, oldY, Origin.z));
			NewChaseDirEx(Evade);
		}
	}

	//	Make active sound.
	if (PlayActive && P_Random() < 3)
	{
		PlayActiveSound();
	}

	return true;
}

//==========================================================================
//
//	A_DoMoveAuto
//
//	[KoraxRPG]
//
//==========================================================================

final void A_DoMoveAuto()
{
	//A_MoveEx(true, true, false);
	A_DoMove(false, false, IdleState, MeleeState, MissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase, true);
}

//==========================================================================
//
//	A_EvadeAuto
//
//	[KoraxRPG]
//
//==========================================================================

final void A_EvadeAuto()
{
	//A_MoveEx(true, true, true);
	A_DoMove(true, false, IdleState, MeleeState, MissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase, true);
}

//==========================================================================
//
//  StepMoveEx
//
//  Move in the current direction, returns false if the move is blocked.
//
//	[CW] Contents use mostly from original StepMove;
//	     Difference is in making MoveDir unused, use free movement angle instead
//
//==========================================================================

final bool StepMoveEx()
{
	float tryx, deltax, origx;
	float tryy, deltay, origy;
	float maxmove;
	int steps;
	float xspeed;
	float yspeed;
	int i;
	bool try_ok;

	line_t *ld;
	int good;

	if (bBlasted)
		return true;

	// Instead of yanking non-floating monsters to the ground,
	// let gravity drop them down, unless they're moving down a step.
	if (!bNoGravity && Origin.z > FloorZ && !bOnMobj)
	{
		if (Origin.z > FloorZ + MaxStepHeight)
		{
			return false;
		}
		else
		{
			Origin.z = FloorZ;
		}
	}

	origx = Origin.x;
	origy = Origin.y;
	deltax = StepSpeed * cos(Angles.yaw);
	deltay = StepSpeed * sin(Angles.yaw);
	tryx = origx + deltax;
	tryy = origy + deltay;

	// Like P_XYMovement this should do multiple moves if the step size is too large
	maxmove = Radius;
	steps = 1;

	if (maxmove > 0.0)
	{ 
		xspeed = fabs(deltax);
		yspeed = fabs(deltay);

		if (xspeed > yspeed)
		{
			if (xspeed > maxmove)
			{
				steps = 1 + ftoi(xspeed / maxmove);
			}
		}
		else
		{
			if (yspeed > maxmove)
			{
				steps = 1 + ftoi(yspeed / maxmove);
			}
		}
	}

	try_ok = true;
	tmtrace_t tmtrace;
	for (i = 1; i < steps; i++)
	{
		try_ok = TryMoveEx(&tmtrace, vector(origx + (deltax / itof(steps * i)), origy +
					(deltay / itof(steps * i)), Origin.z));
		if (!try_ok)
			break;
	}

	// killough 3/15/98: don't jump over dropoffs:
	if (try_ok)
		try_ok = TryMoveEx(&tmtrace, vector(tryx, tryy, Origin.z));

	if (!try_ok)
	{
		// open any specials
		if (bFloat && tmtrace.bFloatOk)
		{
			// must adjust height
			if (Origin.z < tmtrace.FloorZ)
				Origin.z += FloatSpeed * Level.Game.frametime;
			else
				Origin.z -= FloatSpeed * Level.Game.frametime;

			// Check to make sure there's nothing in the way of the float
			if (TestMobjZ())
			{
				bInFloat = true;
				return true;
			}
		}

		if (!tmtrace.SpecHit.Num)
			return false;

		//MoveDir = DI_NODIR;

		// if the special is not a door that can be opened, return false
		//
		// killough 8/9/98: this is what caused monsters to get stuck in
		// doortracks, because it thought that the monster freed itself
		// by opening a door, even if it was moving towards the doortrack,
		// and not the door itself.
		//
		// killough 9/9/98: If a line blocking the monster is activated,
		// return true 90% of the time. If a line blocking the monster is
		// not activated, but some other line is, return false 90% of the
		// time. A bit of randomness is needed to ensure it's free from
		// lockups, but for most cases, it returns the correct result.
		//
		// Do NOT simply return false 1/4th of the time (causes monsters to
		// back out when they shouldn't, and creates secondary stickiness).

		good = 0;
		while (tmtrace.SpecHit.Num)
		{
			ld = tmtrace.SpecHit[tmtrace.SpecHit.Num - 1];
			tmtrace.SpecHit.Num = tmtrace.SpecHit.Num - 1;
			// if the special is not a door
			// that can be opened,
			// return false
			if (LineSpecialLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_USE) ||
			    (bActivatePushWall && LineSpecialLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_PUSH)))
			{
				good |= ld == tmtrace.BlockingLine ? 1 : 2;//true;
			}
		}
		return good && ((Random() >= 203.0) ^ (good & 1));
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat && !bNoGravity)
	{
		if (Origin.z > FloorZ)
		{
			HitFloorType();
		}
		Origin.z = FloorZ;
	}
	return true;
}

//=============================================================================
//
// NewChaseDirEx
//
//	[KoraxRPG] Advanced AI
//
//=============================================================================

final void NewChaseDirEx(optional bool bEvade)
{
	float deltax;
	float deltay;

	if (!pTargetVec)
	{
		Error("KRPGActor::NewChaseDirEx: called with pTargetVec = NULL");
		return;
	}

	if (!specified_bEvade)
		bEvade = false;

	if (bEvade)
	{
		deltax = Origin.x - pTargetVec->x;
		deltay = Origin.y - pTargetVec->y;
	}
	else
	{
		deltax = pTargetVec->x - Origin.x;
		deltay = pTargetVec->y - Origin.y;
	}

	// killough 8/8/98: sometimes move away from target, keeping distance
	// Take advantage over an enemy without missiles, by keeping distance
	strafecount = 0;

	tmtrace_t tmtrace;
	//CheckRelPosition(&tmtrace, Origin);	//???CHECKME

	// Try to move away from a dropoff
	if (FloorZ - tmtrace.DropOffZ > MaxDropoffHeight &&
		Origin.z <= FloorZ && !bDropOff && !bOnMobj && !bFloat)
	{
		avoiddropoff_t a;
		// We call CheckDropoff here to determine if the
		// bounding box actually needs to be used below
		CheckDropOff(&a);

		if (a.deltax || a.deltay)
		{
			// [Graf Zahl] I have changed TryMove to only apply this logic when
			// being called from here. bAavoidingDropoff activates the code that
			// allows monsters to move away from a dropoff. This is different from
			// MBF which requires unconditional use of the altered logic and therefore
			// forcing a massive change in the monster behavior to use this.

			// use different dropoff movement logic in TryMove
			bAvoidingDropoff = true;
			DO_NewChaseDirEx(a.deltax, a.deltay);
			bAvoidingDropoff = false;
		
			// If moving away from dropoff, set movecount to 1 so that
			// small steps are taken to get monster away from dropoff.
			MoveCount = 1;
			return;
		}
	}
	else
	{
		/*
		---------------------------- TODO -----------------------------
		float dist;
		
		dist = DistTo(Target);

		if (Target.Health > 0)
	    {   // Live enemy target
			if (GetCvar('monster_backing') && MissileState &&
				/*actor->type != MT_SKULL &&*//*
				((!Target.MissileState && dist < MELEERANGE * 2.0) ||
				(Target.Player && PlayerEx(Target.Player).ReadyWeapon.bBotMelee &&
				dist < MELEERANGE * 3.0)))
			{       // Back away from melee attacker
					strafecount = P_Random() & 15;
					deltax = -deltax;
					deltay = -deltay;
			}
		}
		---------------------------- TODO -----------------------------
		*/
	}
	DO_NewChaseDirEx(deltax, deltay);

	// If strafing, set movecount to strafecount so that old Doom
	// logic still works the same, except in the strafing part
	if (strafecount)
		MoveCount = strafecount;
}

//==========================================================================
//
//  DO_NewChaseDirEx
//
//	[CW] an attempt to make movement free of MoveDir presets (any angle)
//
//==========================================================================

final void DO_NewChaseDirEx(float deltax, float deltay)
{
	float oldang = Angles.yaw;
	Angles.yaw = atan2(deltay, deltax);
	if (!TryWalkEx())
	{
		if (P_Random() & 1)
		{
			Angles.yaw += 45.0 + Random() * 90.0;
		}
		else
		{
			Angles.yaw -= 45.0 + Random() * 90.0;
		}

		if (!TryWalkEx())
		{
			Angles.yaw = -oldang;
			TryWalkEx();
		}
	}
}

//==========================================================================
//
//  TryWalkEx
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

final bool TryWalkEx()
{
	if (!StepMoveEx())
	{
		return false;
	}
	MoveCount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//	CanReach
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional EntityEx TargetEntity,
			  // [CW] use these three to override default passability calculations
			  optional float MaxPassableStep,
			  optional float MaxPassableDropOff,
			  optional float MinPassableOpening,
			  optional bool bCanUseLines)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!specified_TargetEntity)
		TargetEntity = none;

	if (!specified_MaxPassableStep)
		MaxPassableStep = MaxStepHeight;
	if (!specified_MaxPassableDropOff)
		MaxPassableDropOff = MaxDropoffHeight;
	if (!specified_MinPassableOpening)
		MinPassableOpening = Height;
	
	canreach = DoCanReachPathTraverse(TargetPos, &CRTRData,
		MaxPassableStep, MaxPassableDropOff, MinPassableOpening, bCanUseLines);
	
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;
	
	if (canreach && TargetEntity)
	{
	//
	// [CW] CHECKME ---
	//
	//	if (CRTRData.linetarget != TargetEntity)
	//		return false;

		//
		// [CW] TODO!! --- no 3d floors support here
		//
		// [CW] prev_sector is now the last sector met

		if (TargetEntity.Origin.z > CRTRData.prev_sector->floorheight + MaxPassableStep)
			return false;		// [CW] target thing is too high to reach
		if (TargetEntity.Origin.z < CRTRData.prev_sector->floorheight)
			return false;		// [CW] target thing is under the floor
	}

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
// [CW] TODO!! --- do hr openings check (see BotPlayer)
//
// [CW] TODO!! --- no 3d floors support here
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							ReachTraverse::reach_traverse_data_t * pCRTRData,
							float MaxPassableStep,
							float MaxPassableDropOff,
							float MinPassableOpening,
							bool bCanUseLines)
{
	intercept_t * in;
	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pCRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
				return false;

			// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			if (p_sector->floorheight > pCRTRData->prev_sector->floorheight + MaxPassableStep)
				// will stuck in high floor
				return false;
			if (p_sector->floorheight < pCRTRData->prev_sector->floorheight - MaxPassableDropOff)
				// must avoid dropoffs
				return false;
			if (p_sector->ceilingheight < pCRTRData->prev_sector->floorheight + MinPassableOpening ||
				p_sector->floorheight + MinPassableOpening > pCRTRData->prev_sector->ceilingheight)
				// will stuck in low ceiling...
				return false;

			pCRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
			pCRTRData->linetarget = Actor(in->Thing);
		}
	}

	return true;
}

//**************************************************************************
//
//	[KoraxRPG] Extra effects
//
//**************************************************************************

//==========================================================================
//
//	SpawnSphericalEffect
//
//	CHECKME --- rename? not only effects could be spawned
//	CHECKME --- not actually bound to Actor, move to levelinfo?
//	TODO -- add radial velocity
//
//==========================================================================

void SpawnSphericalEffect(class<EntityEx> EffectType, TVec origin, int amount, TVec spread,
							optional float RadialVelocity, optional TVec DirectVelocity)
{
	int i,c;
	TVec v;
	EntityEx ee;

	c = P_Random() % amount;
	for (i = 0; i < c; i++)
	{
		v = origin + vector((Random() - 0.5) * spread.x,
									(Random() - 0.5) * spread.y,
									(Random() - 0.5) * spread.z);
		ee = EntityEx(Spawn(EffectType, v));
		if (specified_RadialVelocity)
		{
		}
		if (specified_DirectVelocity)
		{
			ee.Velocity += DirectVelocity;
		}
	}
}

//**************************************************************************
//
//
//	[KoraxRPG] Actor Conditions
//
//
//**************************************************************************

//==========================================================================
//
//	PurgeConditions
//
//	[CW] Condenses Conditions array by removing null-references
//
//==========================================================================

final void PurgeConditions()
{
	int i;
	for (i = 0; i < Conditions.Num;)
	{
		if (!Conditions[i])
		{
			Conditions.Remove(i);
		}
		else
			i++;
	}
}

//==========================================================================
//
//	CastCondition
//
//==========================================================================

ActorCondition CastCondition(class<ActorCondition> ConditionClass, bool accumulative,
											Actor Instigator, int level, float life_duration)
{
	/*if (!Conditions)
	{
		Conditions = LinkedList(SpawnObject(LinkedList));
		if (!Conditions) return none;
	}*/
	ActorCondition AC;

	PurgeConditions();

	if (accumulative)
		AC = GetCondition(ConditionClass, Instigator, level);

	if (AC)
	{
		float limit;

		if (AC.MaxAccumulatedLifePerLevel < 0.0)
			AC.LifeTime += life_duration;
		else
		{
			limit = AC.MaxAccumulatedLifePerLevel * itof(AC.Level);
			if (AC.LifeTime >= limit)
				AC = none;	// [CW] to mark that no condition is added
			else
			{
				AC.LifeTime += life_duration;
				if (AC.LifeTime > limit)
					AC.LifeTime = limit;
			}
		}
	}
	else
	{
		AC = ActorCondition(Spawn(ConditionClass));

		if (!AC.CanBeCastUpon(self))
		{
			AC.Destroy();
			AC = none;
		}

		if (AC)
		{
			//LinkedReferer ref = LinkedReferer(SpawnObject(LinkedReferer));
			//ref.refObject = AC;
			//AC.Referer = ref;
			//Conditions.Add(ref);
			Conditions.Num = Conditions.Num + 1;
			Conditions[Conditions.Num - 1] = AC;
			AC.ARecepient = self;
			AC.EInstigator = Instigator;
			AC.Level = level;
			AC.LifeDuration = life_duration;
			AC.Activate();
		}
	}

	if (AC)
	{
		if (Player && AC.CastMessage)
			Player.cprint(AC.CastMessage);
		if (AC.CastSound)
			PlaySound(AC.CastSound, CHAN_VOICE);
	}

	return AC;
}

//==========================================================================
//
//	GetCondition
//
//	TODO: optional instigator and level
//
//==========================================================================

ActorCondition GetCondition(class<ActorCondition> ConditionClass, Actor Instigator, int level)
{
	if (/*Conditions && Conditions.refHead*/Conditions.Num)
	{
		//LinkedReferer acref = LinkedReferer(Conditions.refHead);
		//while (acref)
		//{
		int i;
		for (i = 0; i < Conditions.Num; i++)
		{
			ActorCondition ac = Conditions[i];/*ActorCondition(acref.refObject);*/
			if (ac && ac.Class == ConditionClass &&
					ac.EInstigator == Instigator &&
					ac.Level == level)
			{
				return ac;
			}
			//acref = LinkedReferer(acref.refNext);
		};
	}

	return none;
}

//==========================================================================
//
//	NotifyConditions
//
//==========================================================================

void NotifyConditions(int notification, EntityEx E, int param)
{
	if (/*Conditions && Conditions.refHead*/Conditions.Num)
	{
		//LinkedReferer acref = LinkedReferer(Conditions.refHead);
		//while (acref)
		int i;
		for (i = 0; i < Conditions.Num; i++)
		{
			if (Conditions[i])
			/*ActorCondition(acref.refObject)*/Conditions[i].Notify(notification, E, param);
			//acref = LinkedReferer(acref.refNext);
		};
	}
}


defaultproperties
{
	bNeverTarget = true;

	ConversationID = -1;

	bNonScalable = true;
}
