
class TravelMapScreen : Widget;

ClientGame		ClGame;


enum
{
	TM_None,
	TM_MoveOnPath,
	TM_ConfirmAccessAsk,
	TM_ConfirmAccessWaitResponse,
	TM_Done,
	TM_Skip
};

int TMState;

//name TextFlat;
//int TextPic;
int TM_PicMain;


struct tm_object_t
{
	int		x;
	int		y;
	bool	visible;
	bool	accessible;
};

/*struct tm_pathpoint_t : tm_object_t
{
	int colour;
	int curve;
	tm_pathpoint_t *	p_p1;
	tm_pathpoint_t *	p_p2;
	tm_pathpoint_t *	p_point_jointed;
};*/

enum
{
	ROADDIR_NONE,
	ROADDIR_JUST_LEFT = 0x01,
	ROADDIR_JUST_RIGHT = 0x02,
	ROADDIR_JUST_UP = 0x04,
	ROADDIR_JUST_DOWN = 0x08,
	ROADDIR_LEFT_UP = ROADDIR_JUST_LEFT | ROADDIR_JUST_UP,
	ROADDIR_RIGHT_UP = ROADDIR_JUST_RIGHT | ROADDIR_JUST_UP,
	ROADDIR_LEFT_DOWN = ROADDIR_JUST_LEFT | ROADDIR_JUST_DOWN,
	ROADDIR_RIGHT_DOWN = ROADDIR_JUST_RIGHT | ROADDIR_JUST_DOWN
};

struct tm_road_t : tm_object_t
{
	int			ex;
	int			ey;
	int			colour;
	array<int>	route;
};

struct tm_graphic_object_t : tm_object_t
{
	int colour;
	name picname;
	int	picId;
};

struct tm_mapentry_t : tm_graphic_object_t
{
	int					mapid;
	int					spawnpos;
	name				mapname;
	string				title;
	string				entrymessage;
	name				entryname;
	int					entrypicId;
	//tm_pathpoint_t *	p_point;
	bool				temp;			// fixme
	int					temp2;
};

struct tm_traveller_t : tm_graphic_object_t
{
	//tm_pathpoint_t *	p_pathpt;
	tm_mapentry_t *		p_mapentry;
};

enum
{
	TM_PLCMD_UP		= 0x0001,
	TM_PLCMD_LEFT	= 0x0002,
	TM_PLCMD_RIGHT	= 0x0004,
	TM_PLCMD_DOWN	= 0x0008
};

int					playerCmds;
tm_traveller_t		traveller;

array<tm_road_t>		tmRoads;
array<tm_mapentry_t>	tmMapEntries;


name			NextMap;
int				NextPosition;


//==========================================================================
//
//  TM_Init
//
//==========================================================================

void TM_Init()
{
	TMState = TM_None;

	playerCmds = 0;

	TM_InitData();

	if (TMState != TM_Skip)
	{
		TM_LoadPics();
		if (P_Random() < 128)
			CmdBuf_AddText(va("music loop %n\n", 'PlacesToGo'));
		else
			CmdBuf_AddText(va("music loop %n\n", 'ToTheEast'));
	}
}

//==========================================================================
//
//  TM_Release
//
//==========================================================================

void TM_Release()
{
	TM_UnloadPics();

	// kill objects array here?
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float DeltaTime)
{
	if (TMState == TM_Done)
	{
		ClGame.skipintermission = false;
		CmdBuf_AddText(va("TeleportNewMap %n %i\n", NextMap, NextPosition));
	}
	else if (TMState == TM_Skip)
	{
		ClGame.skipintermission = false;
		CmdBuf_AddText("TeleportNewMap\n");
	}
	else if (TMState == TM_ConfirmAccessAsk)
	{
		ClGame.messageResult = ClientGame::MBR_Unset;	// FIXME!!
		ClGame.MessageBoxStartMessage(va("Enter %s (y/n)?", traveller.p_mapentry->title), ClientGame::MB_YesNo, true);
		TMState = TM_ConfirmAccessWaitResponse;
		return;
	}
	else if (TMState == TM_ConfirmAccessWaitResponse)
	{
		if (ClGame.messageResult == ClientGame::MBR_Yes)
			TMState = TM_Done;
		else if (ClGame.messageResult == ClientGame::MBR_No)
			TMState = TM_None;
		return;
	}

	if (traveller.visible)
	{
		int i;

		if (playerCmds & TM_PLCMD_UP)
			traveller.y--;
		if (playerCmds & TM_PLCMD_LEFT)
			traveller.x--;
		if (playerCmds & TM_PLCMD_RIGHT)
			traveller.x++;
		if (playerCmds & TM_PLCMD_DOWN)
			traveller.y++;

		traveller.p_mapentry = NULL;
		for (i = 0; i < tmMapEntries.Num; i++)
		{
			if (tmMapEntries[i].visible)
			{
				if (tmMapEntries[i].x - 16 <= traveller.x &&
					tmMapEntries[i].x + 16 >= traveller.x &&
					tmMapEntries[i].y - 16 <= traveller.y &&
					tmMapEntries[i].y + 16 >= traveller.y)
				{
					if (!tmMapEntries[i].temp)
						tmMapEntries[i].temp2 = 20;
					tmMapEntries[i].temp = true;
					traveller.p_mapentry = &tmMapEntries[i];
				}
				else
					tmMapEntries[i].temp = false;
			}
		}
	}
}

//==========================================================================
//
//	HandleUserCommand
//
//==========================================================================

void HandleUserCommand(event_t * event)
{
	if (!bTickEnabled)
		return;

	switch (event->type)
	{
	case ev_keydown:
		{
			switch (event->data1)
			{
			case K_UPARROW:
				playerCmds |= TM_PLCMD_UP;
				break;
			case K_LEFTARROW:
				playerCmds |= TM_PLCMD_LEFT;
				break;
			case K_RIGHTARROW:
				playerCmds |= TM_PLCMD_RIGHT;
				break;
			case K_DOWNARROW:
				playerCmds |= TM_PLCMD_DOWN;
				break;
			}
		}
		break;
	case ev_keyup:
		{
			switch (event->data1)
			{
			case K_ENTER:
			case K_SPACE:
				if (TM_AccessObject())
					TMState = TM_ConfirmAccessAsk;
				break;
			case K_UPARROW:
				playerCmds &= ~TM_PLCMD_UP;
				break;
			case K_LEFTARROW:
				playerCmds &= ~TM_PLCMD_LEFT;
				break;
			case K_RIGHTARROW:
				playerCmds &= ~TM_PLCMD_RIGHT;
				break;
			case K_DOWNARROW:
				playerCmds &= ~TM_PLCMD_DOWN;
				break;
			}
		}
		break;
	};
}

//==========================================================================
//
//  TM_AccessObject
//
//==========================================================================

bool TM_AccessObject()
{
	if (traveller.p_mapentry)
	{
		NextMap = traveller.p_mapentry->mapname;
		NextPosition = traveller.p_mapentry->spawnpos;
		return true;
	}
	
	return false;
}

//==========================================================================
//
//  OnDraw
//
//==========================================================================

void OnDraw()
{
	int i;
	picinfo_t info;

	if (TMState > TM_Done)
		return;

	if (/*TextPic*/TM_PicMain)
	{
		DrawFullScreenPic(/*TextPic*/TM_PicMain);
	}
	/*else if (TextFlat)
	{
		FillRectWithFlat(0, 0, 640, 480, TextFlat);
	}*/
	else
	{
		R_FillRect(0, 0, 640, 480, 0);
	}


	// Draw roads
	int x, y, PtIndex, data, dir;

	for (i = 0; i < tmRoads.Num; i++)
	{
		tm_road_t * pRoad = &tmRoads[i];

		if (!pRoad->visible)
			continue;

		x = 0xFFFF & (pRoad->route[0] >> 16);
		y = 0xFFFF & pRoad->route[0];

		// first road pixel
		R_FillRect(x - 1, y - 1, 3, 3, pRoad->colour);

		for (PtIndex = 0; PtIndex < (pRoad->route.Num - 1) * 4; PtIndex++)
		{
			data = pRoad->route[1 + (PtIndex / 4)];
			dir = (data >> ((PtIndex % 4) << 2)) & 0xF;

			if (!dir)
			{
				break;	// Road end
			}

			if (dir & ROADDIR_JUST_LEFT)
				x--;
			if (dir & ROADDIR_JUST_RIGHT)
				x++;
			if (dir & ROADDIR_JUST_UP)
				y--;
			if (dir & ROADDIR_JUST_DOWN)
				y++;

			R_FillRect(x - 1, y - 1, 3, 3, pRoad->colour);
		}
	}

	// Draw map entries
	for (i = 0; i < tmMapEntries.Num; i++)
	{
		if (!tmMapEntries[i].visible)
			continue;

		if (tmMapEntries[i].temp)
		{
			if (tmMapEntries[i].temp2 > 0)
			{
				tmMapEntries[i].temp2--;
				if (!tmMapEntries[i].temp2)
					tmMapEntries[i].temp2 = -20;
			}
			else if (tmMapEntries[i].temp2 < 0)
			{
				tmMapEntries[i].temp2++;
				if (!tmMapEntries[i].temp2)
					tmMapEntries[i].temp2 = 20;
			}

			if (tmMapEntries[i].temp2 < 0)
				continue;
		}

		if (tmMapEntries[i].picId)
		{
			R_GetPicInfo(tmMapEntries[i].picId, &info);
			DrawPic(tmMapEntries[i].x + info.xoffset - (info.width >> 1),
				tmMapEntries[i].y + info.yoffset - (info.height >> 1),
				tmMapEntries[i].picId);
		}
		else
		{
			R_FillRect(tmMapEntries[i].x - 2, tmMapEntries[i].y - 2, 5, 5,
				tmMapEntries[i].colour);
		}
	}

	// Draw traveller
	if (traveller.visible)
	{
		if (traveller.picId)
		{
			R_GetPicInfo(traveller.picId, &info);
			DrawPic(traveller.x + info.xoffset - (info.width >> 1),
				traveller.y + info.yoffset - (info.height >> 1), traveller.picId);
		}
		else
		{
			R_FillRect(traveller.x - 2, traveller.y - 2, 5, 5, traveller.colour);
		}
	}
}

//========================================================================
//
//  TM_LoadPics
//
//========================================================================

void TM_LoadPics()
{
	int i;

	/*if (ClGame.im->TextPic)
	{
		TextPic = R_RegisterPic(ClGame.im->TextPic);
	}
	else if (ClGame.im->TextFlat)
	{
		TextFlat = ClGame.im->TextFlat;
	}*/

	TM_PicMain = R_RegisterPic('trvlmap');

	for (i = 0; i < tmMapEntries.Num; i++)
	{
		tmMapEntries[i].picId = tmMapEntries[i].picname == '' ? 0 : R_RegisterPic(tmMapEntries[i].picname);
	}
	traveller.picId = R_RegisterPic(traveller.picname);

	//print("TM_LoadPics : Pic = %i", TextPic);
	//print("TM_LoadPics : Flat = %i", TextFlat);
	print("TM_LoadPics : Pic = %i", TM_PicMain);	
}

//========================================================================
//
//  TM_UnloadPics
//
//========================================================================

void TM_UnloadPics()
{
}

//========================================================================
//
//  TM_InitData
//
//========================================================================

void TM_InitData()
{
	print("TravelMapScreen::TM_InitData : ");
	print("TravelMapScreen::TM_InitData : im data:");
	print("----------------------------------------");
	print("name LeaveMap = %n", ClGame.im->LeaveMap);
	print("int LeaveCluster = %i", ClGame.im->LeaveCluster);
	print("string LeaveName = %s", ClGame.im->LeaveName);
	print("name LeaveTitlePatch = %n", ClGame.im->LeaveTitlePatch);
	print("  ===  ");
	print("name EnterMap = %n", ClGame.im->EnterMap);
	print("int EnterCluster = %i", ClGame.im->EnterCluster);
	print("string EnterName = %s", ClGame.im->EnterName);
	print("name EnterTitlePatch = %n", ClGame.im->EnterTitlePatch);
	print("  ===  ");
	print("string Text = %s", ClGame.im->Text);
	print("name TextFlat = %n", ClGame.im->TextFlat);
	print("name TextPic = %n", ClGame.im->TextPic);
	print("name TextMusic = %n", ClGame.im->TextMusic);
	print("int TextCDTrack = %i", ClGame.im->TextCDTrack);
	print("int TextCDId = %i", ClGame.im->TextCDId);
	print("  ===  ");
	print("bool bTextIsLump = %i", ClGame.im->bTextIsLump);
	print("----------------------------------------");

	ClGame.skipintermission = false;

	if (ClGame.im->EnterMap != 'map-1')
	{
		TMState = TM_Skip;
		return;
	}

	//
	// Load and init map data here
	//
	//

	TM_LoadAndParseDataLump();

	/*tmRoads.Num = 10;
	tmRoads[0].x = 100;
	tmRoads[0].y = 100;
	tmRoads[0].active = true;
	tmRoads[1].x = 130;
	tmRoads[1].y = 100;
	tmRoads[1].active = true;
	tmRoads[2].x = 140;
	tmRoads[2].y = 110;
	tmRoads[2].active = true;
	tmRoads[3].x = 180;
	tmRoads[3].y = 130;
	tmRoads[3].active = true;
	tmRoads[4].x = 200;
	tmRoads[4].y = 150;
	tmRoads[4].active = true;*/

#ifdef FIXME
	tmMapEntries.Num = 2;
	tmMapEntries[0].x = 95;
	tmMapEntries[0].y = 95;
	tmMapEntries[0].picname = 'fhfxh8h2';
	tmMapEntries[0].mapid = 1;
	tmMapEntries[0].mapname = P_TranslateMap(tmMapEntries[0].mapid);
	tmMapEntries[0].title = P_GetMapName(tmMapEntries[0].mapid - 1);
	tmMapEntries[0].spawnpos = 0;
	tmMapEntries[0].active = true;

	tmMapEntries[1].x = 205;
	tmMapEntries[1].y = 155;
	tmMapEntries[1].picname = 'w_303';
	tmMapEntries[1].mapid = 13;
	tmMapEntries[1].mapname = P_TranslateMap(tmMapEntries[1].mapid);
	tmMapEntries[1].title = P_GetMapName(tmMapEntries[1].mapid - 1);
	tmMapEntries[1].spawnpos = 1;
	tmMapEntries[1].active = true;
#endif

	traveller.x = 0;
	traveller.y = 0;
	traveller.picname = 'playa1';
	traveller.visible = true;

	int i;

	for (i = 0; i < tmMapEntries.Num; i++)
	{
		if (tmMapEntries[i].mapid != -1)
		{
			tmMapEntries[i].mapname = P_TranslateMap(tmMapEntries[i].mapid);
			tmMapEntries[i].title = P_GetMapName(tmMapEntries[i].mapid - 1);
		}
		tmMapEntries[i].spawnpos = 0;// CHECKME
		tmMapEntries[i].picname = '';
		tmMapEntries[i].colour = RGBA(0xFF,0,0,0xFF);//CHECKME

		print("map %i, id = %i, name = %n, title = %s", i, tmMapEntries[i].mapid,
			tmMapEntries[i].mapname ? tmMapEntries[i].mapname : '',
			tmMapEntries[i].title ? tmMapEntries[i].title : "");
	}

	for (i = 0; i < tmMapEntries.Num; i++)
	{
		if (tmMapEntries[i].mapname == ClGame.im->LeaveMap
			/*&& tmMapEntries[i].spawnpos == 0*/)
		{
			traveller.x = tmMapEntries[i].x;
			traveller.y = tmMapEntries[i].y;
			break;
		}
	}
}

#ifdef FIXME
enum
{
	TM_Parse_Block_None,
	TM_Parse_Block_Read_R,
	TM_Parse_Block_Read_R_Pt,
	TM_Parse_Block_Read_M
};

enum
{
	TM_Parse_State_Newline,
	TM_Parse_State_Skip,
	TM_Parse_State_Read
};
#endif

//==========================================================================
//
//	TM_LoadAndParseDataLump
//
//==========================================================================

void TM_LoadAndParseDataLump()
{
	if (!WadLumpPresent('trvlmap'))
	{
		Error("Cannot find trvlmap lump, Travel Map data unavailable");
		return;
	}

	int i, j;
	int buf;
	int index;
	array<byte> Data;

	LoadBinaryLump('trvlmap', Data);
	dprint("TM_LoadAndParseDataLump : Data.Num = %i", Data.Num);

	print("TravelMapScreen::TM_LoadAndParseDataLump : IN");

	index = 0;
	buf = Data[index++];
	buf += Data[index++] << 8;
	buf += Data[index++] << 16;
	buf += Data[index++] << 24;
	tmMapEntries.Num = buf;

	for (i = 0; i < tmMapEntries.Num; i++)
	{
		tmMapEntries[i].visible = Data[index++];
		tmMapEntries[i].accessible = Data[index++];
		tmMapEntries[i].x = Data[index++];
		tmMapEntries[i].x += Data[index++] << 8;
		tmMapEntries[i].x += Data[index++] << 16;
		tmMapEntries[i].x += Data[index++] << 24;
		tmMapEntries[i].y = Data[index++];
		tmMapEntries[i].y += Data[index++] << 8;
		tmMapEntries[i].y += Data[index++] << 16;
		tmMapEntries[i].y += Data[index++] << 24;
		buf = Data[index++];
		buf += Data[index++] << 8;
		buf += Data[index++] << 16;
		buf += Data[index++] << 24;
		index += buf << 1; // wchar string
		//tmMapEntries[i].title;
		//for (j = 0; j < buf; j++)
		//	Data[index++];
		/*buf = Data[index++];
		buf += Data[index++] << 8;
		buf += Data[index++] << 16;
		buf += Data[index++] << 24;
		buf <<= 1; // wchar string
		tmMapEntries[i].mapname;
		for (j = 0; j < buf; j++)
			Data[index++];*/
		tmMapEntries[i].mapid = Data[index++];
		tmMapEntries[i].mapid += Data[index++] << 8;
		tmMapEntries[i].mapid += Data[index++] << 16;
		tmMapEntries[i].mapid += Data[index++] << 24;
	}

	buf = Data[index++];
	buf += Data[index++] << 8;
	buf += Data[index++] << 16;
	buf += Data[index++] << 24;
	tmRoads.Num = buf;
	for (i = 0; i < tmRoads.Num; i++)
	{
		tmRoads[i].visible = Data[index++];
		tmRoads[i].accessible = Data[index++];
		buf = Data[index++];
		buf += Data[index++] << 8;
		buf += Data[index++] << 16;
		buf += Data[index++] << 24;
		buf >>= 2; // DWORDs
		tmRoads[i].route.Num = buf;
		for (j = 0; j < buf; j++)
		{
			tmRoads[i].route[j] = Data[index++];
			tmRoads[i].route[j] += Data[index++] << 8;
			tmRoads[i].route[j] += Data[index++] << 16;
			tmRoads[i].route[j] += Data[index++] << 24;
		}

		// CHECKME
		tmRoads[i].colour = RGBA(0,0,0,0xFF);
	}

	print("TravelMapScreen::TM_LoadAndParseDataLump : OUT");

#ifdef FIXME
	string Data = LoadTextLump('tm_henfo'); // [CW] Travel Map Hub Entries iNFO

	int i = -1;
	int DataLen = strlen(Data);

	if (!DataLen)
		return;

	int ParseBlock = TM_Parse_Block_None;
	int ParseState = TM_Parse_State_Newline;

	int substr_from = 0;
	string word;

	while (++i < DataLen)
	{
		if (ParseState == TM_Parse_State_Skip)
		{
			if (strcmp(substr(Data, i, 1), "\n") == 0)
			{
				ParseState = TM_Parse_State_Newline;
			}
			continue;
		}

		if (strcmp(substr(Data, i, 1), "!") >= 0 && strcmp(substr(Data, i, 1), "~") <= 0)
		{
			if (ParseState != TM_Parse_State_Read)
			{
				ParseState = TM_Parse_State_Read;
				substr_from = i;
			}
		}
		else
		{
			if (ParseState == TM_Parse_State_Newline && strcmp(substr(Data, i, 1), "!") < 0)
				continue;

			if (ParseState == TM_Parse_State_Read)
			{
				word = substr(Data, substr_from, i - substr_from);
				
				//
				// parse word here
				//
			}

			ParseState = TM_Parse_State_Skip;
		}
	};
#endif
}

//==========================================================================
//
//	VisibilityChanged
//
//==========================================================================

void OnVisibilityChanged(bool bNewVisibility)
{
	::OnVisibilityChanged(bNewVisibility);

	bTickEnabled = bNewVisibility;

	print("TravelMap::OnVisibilityChanged : %i", bNewVisibility);

	if (bNewVisibility)
	{
		TM_Init();
	}
	else
	{
		TM_Release();
	}
}

defaultproperties
{
	bTickEnabled = true;
	Width = 640;
	Height = 480;
}
