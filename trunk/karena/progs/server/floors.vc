//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	FLOOREV_LowerToHighest,
	FLOOREV_RaiseToHighest,
	FLOOREV_LowerToLowest,
	FLOOREV_LowerToNearest,
	FLOOREV_RaiseToNearest,
	FLOOREV_RaiseToLowestCeiling,
	FLOOREV_LowerByValue,
	FLOOREV_RaiseByValue,
	FLOOREV_LowerByValueTimes8,
	FLOOREV_RaiseByValueTimes8,
	FLOOREV_LowerTimes8Instant,
	FLOOREV_RaiseTimes8Instant,
	FLOOREV_MoveToValueTimes8,
	FLOOREV_RaiseByTexture,
	FLOOREV_LowerToLowestChange,
	FLOOREV_RaiseToNearestChange,
	FLOOREV_RaiseByValueChange,
	FLOOREV_RaiseByValueChange2,
	FLOOREV_RaiseAndCrush,
	FLOOREV_RaiseBuildStep,
	FLOOREV_Generic,
	FLOOREV_GenericChange0,
	FLOOREV_GenericChangeT,
	FLOOREV_GenericChange,
	FLOOREV_Donut
};

enum
{
	ELEVEV_Down,
	ELEVEV_Up,
	ELEVEV_Current,
	ELEVEV_Raise,
	ELEVEV_Lower
};

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	int			SecNum;
	int			Rtn;
	sector_t*	Sec;
	FloorMover	Floor;

	Rtn = false;
	if (!Arg1)
	{
		if (!Line || !Line->backsector)
			return false;

		if (!Line->backsector->FloorData)
		{
			// new floor thinker
			Rtn = true;
			Floor = NewSpecialThinker(FloorMover);
			Floor.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Type,
				Line);
		}
	}
	else
	{
		for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
			SecNum = FindSectorFromTag(Arg1, SecNum))
		{
			Sec = &GLevel.Sectors[SecNum];

			// ALREADY MOVING?  IF SO, KEEP GOING...
			if (Sec->FloorData)
				continue;

			// new floor thinker
			Rtn = true;
			Floor = NewSpecialThinker(FloorMover);
			Floor.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
		}
	}
	return Rtn;
}

//==========================================================================
//
// EV_FloorCrushStop
//
//==========================================================================

int EV_FloorCrushStop(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	FloorMover	Floor;
	bool		Rtn;

	Rtn = false;
	FOREACH(FloorMover, Floor)
	{
		if (Floor.CrushStop(Arg1))
		{
			Rtn = true;
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_BuildStairsOld
//
//  BUILD A STAIRCASE!
//
//==========================================================================

int EV_BuildStairsOld(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	bool Generic, line_t* Line)
{
	int			SecNum;
	float		Height;
	int			i;
	int			j;
	int			Ok;
	int			Texture;
	int			Rtn;
	sector_t*	Sec;
	sector_t*	TSec;
	FloorMover	Floor;
	line_t*		SecLine;
	int			Direction;
	float		StairSize;
	bool		IgnTxt;
	int			OldSecNum;

	if (!Arg1 && (!Line || !Line->backsector))
		return false;

	if (Generic)
	{
		Direction = Arg4 & 1 ? 1 : -1;
		IgnTxt = !!(Arg4 & 2);
	}
	else
	{
		Direction = 1;
		IgnTxt = false;
	}
	StairSize = itof(Arg3 * Direction);
	Rtn = 0;
	for (SecNum = Arg1 ? FindSectorFromTag(Arg1, -1) : 1; SecNum >= 0;
		SecNum = Arg1 ? FindSectorFromTag(Arg1, SecNum) : -1)
	{
		Sec = Arg1 ? &GLevel.Sectors[SecNum] : Line->backsector;

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (Sec->FloorData)
			continue;

		// new floor thinker
		Rtn = 1;
		Height = GetPlanePointZ(&Sec->floor, vector(0.0, 0.0, 0.0)) +
			StairSize;
		Floor = NewSpecialThinker(FloorMover);
		Floor.InitStair(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Generic, Height);

		Texture = Sec->floor.pic;
		OldSecNum = SecNum;	//jff 3/4/98 preserve loop index

		// Find next sector to raise
		// 1. Find 2-sided line with same sector side[0]
		// 2. Other side is the next sector to raise
		// 3. Unless already moving, or different texture, then stop building
		do
		{
			Ok = false;
			for (i = 0; i < Sec->linecount; i++)
			{
				SecLine = Sec->lines[i];

				if (!(SecLine->flags & ML_TWOSIDED))
					continue;

				TSec = SecLine->frontsector;
				if (Sec != TSec)
					continue;
				TSec = SecLine->backsector;
				if (!TSec)
					continue;	//jff 5/7/98 if no backside, continue
				if (!IgnTxt && TSec->floor.pic != Texture)
					continue;

				Height += StairSize;
				if (TSec->FloorData)
					continue;

				Sec = TSec;
				//	SecNum = TSec - GLevel.Sectors;
				for (j = 0; j < GLevel.NumSectors; j++)
				{
					if (TSec == &GLevel.Sectors[j])
					{
						SecNum = j;
						break;
					}
				}
				Floor = NewSpecialThinker(FloorMover);
				Floor.InitStair(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Generic,
					Height);
				Ok = true;
				break;
			}
		}
		while (Ok);
		SecNum = OldSecNum;	//jff 3/4/98 restore loop index
	}
	return Rtn;
}

//==========================================================================
//
//  EV_DoDonut
//
//  Handle donut function: lower pillar, raise surrounding pool, both to
// height, texture and type of the sector surrounding the pool.
//  Passed the linedef that triggered the donut
//  Returns whether a thinker was created
//
//==========================================================================

int EV_DoDonut(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t *s1;
	sector_t *s2;
	sector_t *s3;
	int secnum;
	int rtn;
	int i;
	FloorMover Floor;

	secnum = -1;
	rtn = 0;
	// do function on all sectors with same tag as linedef
	while ((secnum = FindSectorFromTag(Arg1, secnum)) >= 0)
	{
		s1 = &GLevel.Sectors[secnum];	// s1 is pillar's sector

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->FloorData)
			continue;

		s2 = getNextSector(s1->lines[0], s1);	// s2 is pool's sector
		rtn = 1;

		// find a two sided line around the pool whose other side isn't the pillar
		for (i = 0; i < s2->linecount; i++)
		{
			if ((!s2->lines[i]->flags & ML_TWOSIDED) ||
				(s2->lines[i]->backsector == s1))
				continue;
			s3 = s2->lines[i]->backsector;

			//  Spawn rising slime
			Floor = NewSpecialThinker(FloorMover);
			Floor.InitDonut(s2, s3, Arg2);

			//  Spawn lowering donut-hole
			Floor = NewSpecialThinker(FloorMover);
			Floor.InitDonut2(s1, s3, Arg3);
			break;
		}
	}
	return rtn;
}

//**************************************************************************
//
//  STAIRS
//
//**************************************************************************

enum
{
	STAIRSEV_DownNormal,
	STAIRSEV_UpNormal,
	STAIRSEV_DownSync,
	STAIRSEV_UpSync
};

//==========================================================================
//
//	EV_BuildStairs
//
//	BUILD A STAIRCASE!
//
//	StairDirection is either positive or negative, denoting build stairs
// up or down.
//
//==========================================================================

int EV_BuildStairs(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	int StairsType)
{
	int				SecNum;
	sector_t*		Sec;
	StairStepMover	StairStep;
	StairStepMover	StairQueueHead;

	StairQueueHead = none;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (Sec->FloorData)
			continue;

		StairStep = NewSpecialThinker(StairStepMover);
		StairStep.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5,
			StairsType);
		if (StairQueueHead)
		{
			StairQueueHead.AppendToQueue(StairStep);
		}
		else
		{
			StairQueueHead = StairStep;
		}
		Sec->special &= ~SECSPEC_BASE_MASK;
	}
	for (StairStep = StairQueueHead; StairStep;
		StairStep = StairStep.QueueNext)
	{
		StairStep.ProcessStairSector();
	}
	return 1;
}

//**************************************************************************
//
//  PILLAR
//
//**************************************************************************

//==========================================================================
//
//	EV_BuildPillar
//
//==========================================================================

int EV_BuildPillar(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	bool Crush)
{
	int			SecNum;
	sector_t*	Sec;
	Pillar		pillar;
	int			Rtn;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		if (Sec->FloorData || Sec->CeilingData)
			continue;	// already moving
		Rtn = true;
		pillar = NewSpecialThinker(Pillar);
		pillar.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Crush);
	}
	return Rtn;
}

//==========================================================================
//
//	EV_OpenPillar
//
//==========================================================================

int EV_OpenPillar(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int			SecNum;
	sector_t*	Sec;
	Pillar		pillar;
	int			Rtn;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		if (Sec->FloorData || Sec->CeilingData)
			continue;	// already moving
		Rtn = true;
		pillar = NewSpecialThinker(Pillar);
		pillar.InitOpen(Sec, Arg1, Arg2, Arg3, Arg4, Arg5);
	}
	return Rtn;
}

//**************************************************************************
//
//  FLOOR WAGGLE
//
//**************************************************************************

enum
{
	WGLSTATE_EXPAND,
	WGLSTATE_STABLE,
	WGLSTATE_REDUCE
};

//==========================================================================
//
//	EV_StartFloorWaggle
//
//==========================================================================

bool EV_StartFloorWaggle(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int				SectorIndex;
	sector_t*		Sector;
	FloorWaggle		Waggle;
	bool			RetCode;

	RetCode = false;
	for (SectorIndex = FindSectorFromTag(Arg1, -1); SectorIndex >= 0;
		SectorIndex = FindSectorFromTag(Arg1, SectorIndex))
	{
		Sector = &GLevel.Sectors[SectorIndex];
		if (Sector->FloorData)
		{
			// Already busy with another thinker
			continue;
		}
		RetCode = true;
		Waggle = NewSpecialThinker(FloorWaggle);
		Waggle.Init(Sector, Arg1, Arg2, Arg3, Arg4, Arg5);
	}
	return RetCode;
}

//==========================================================================
//
//	EV_FloorTransferTrigger
//
//==========================================================================

bool EV_FloorTransferTrigger(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, line_t* Line)
{
	int			SecNum;
	bool		Rtn;
	sector_t*	Sec;

	if (!Line)
	{
		return false;
	}

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Rtn = true;

		Sec->floor.pic = Line->frontsector->floor.pic;
		Sec->special = (Sec->special & SECSPEC_SECRET_MASK) |
			(Line->frontsector->special & ~SECSPEC_SECRET_MASK);
	}
	return Rtn;
}

//==========================================================================
//
//	EV_FloorTransferNumeric
//
//==========================================================================

bool EV_FloorTransferNumeric(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5)
{
	int			SecNum;
	bool		Rtn;
	sector_t*	Sec;
	sector_t*	MdlSec;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];
		Rtn = true;

		MdlSec = FindModelFloorSector(Sec, GetPlanePointZ(&Sec->floor,
			Sec->soundorg));
		if (MdlSec)
		{
			Sec->floor.pic = MdlSec->floor.pic;
			Sec->special = MdlSec->special;
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_DoElevator
//
//==========================================================================

int EV_DoElevator(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	int			SecNum;
	int			Rtn;
	sector_t*	Sec;
	Elevator	Elev;

	if (!Line && (Type == ELEVEV_Current))
	{
		return false;
	}

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];

		//	Skip if already busy.
		if (Sec->FloorData || Sec->CeilingData)
			continue;

		//	New elevator thinker
		Rtn = true;
		Elev = NewSpecialThinker(Elevator);
		Elev.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
	}
	return Rtn;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.5  2005/03/28 07:58:57  dj_jl
//  Latest Vavoom updates.
//
//  Revision 1.4  2005/03/01 15:33:57  dj_jl
//  Big update of line specials.
//
//  Revision 1.2  2004/11/23 12:50:28  dj_jl
//  Added support for many sector specials.
//
//  Revision 1.17  2004/11/22 07:36:28  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.16  2002/11/02 08:24:10  dj_jl
//  New style classes.
//
//  Revision 1.15  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.14  2002/04/11 16:48:10  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.13  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.12  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.11  2002/01/29 18:16:19  dj_jl
//  Adjusted speed to fix timing
//
//  Revision 1.10  2002/01/15 08:12:26  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.9  2002/01/12 18:02:48  dj_jl
//  Replaced some C style casts with dynamic casts
//
//  Revision 1.8  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/18 18:31:01  dj_jl
//  Added class SectorThinker
//
//  Revision 1.6  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.5  2001/09/25 17:13:50  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/24 17:17:17  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
