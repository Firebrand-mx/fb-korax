//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class KArenaPlayerPawn : PlayerPawn
	abstract;

class<KArenaWeapon>			WeaponClasses[HexenDefs::NUMWEAPONSLOTS];

int InitialStrength;
int InitialWisdom;
int InitialDexterity;
int InitialConstitution;
int InitialIntelligence;

bool bOverrideCoop;	// [CW] Override IsTeammate method by always returning false
					// currently is used as a temporary fix for targetinfo not showing for allies

int experience;

//==========================================================================
//
//  IsDeathInflictor
//
//	[CW]
//
//==========================================================================

void IsDeathInflictor(EntityEx victim)
{
	//[CW] DEBUGGING *****************
	if (!victim)
		Error("KArenaPlayerPawn::IsDeathInflictor : victim reference not set to an instance of an object");

	//
	// This may happen if poisoner died before poisoned one and his corpse existed until poisoned died...
	// rare but possible
	if (!Player)
	{
		// Since only Instant Ranged weapons have meaning below, and there's no poisonous weapon
		// of that type, we can simply ignore this situation.
		return;
	}

	if (!Player(Player).ReadyWeapon)
		Error("KArenaPlayerPawn::IsDeathInflictor : Player.ReadyWeapon reference not set to an instance of an object");
	//[CW] DEBUGGING *****************

	// Currently only Actor's death has a meaning here
	if (ClassIsChildOf(victim.Class, Actor))
	{
		if (KArenaWeapon(Player(Player).ReadyWeapon).bInstantRanged &&
			Length(KArenaWeapon(Player(Player).ReadyWeapon).ShotPosition - victim.GetCentre()) >= HexenDefs::ACCURATE_SHOT_DISTANCE)
				Player(Player).ConfirmTrophy(HexenDefs::trophycl_accuracy);
	}
}

//==========================================================================
//
//	MoveToFreePosition
//
//	[CW]
//
//==========================================================================

bool MoveToFreePosition()
{
	TVec bak_org;
	float test_ang;
	TVec test_dir;
	float test_dist;

	bak_org = Origin;
	test_dir = vector(1.0, 0.0, 0.0);

	for (test_dist = 0.0; test_dist <= 512.0; test_dist += 64.0)
	{
		for (test_ang = 0.0; test_ang < 360.0; test_ang += 45.0)
		{
			VectorRotateAroundZ(&test_dir, test_ang);
			UnlinkFromWorld();
			Origin = bak_org + test_dir * test_dist;
			LinkToWorld();
			// [FB] We must check if the move is being done inside the map
			if (!CheckSides(Origin +
				vector((4.0 + 3.0 * (Radius) / 2.0) * cos(test_ang),
				(4.0 + 3.0 * (Radius) / 2.0) * sin(test_ang), ONFLOORZ)))
			{
				// [FB] OK, we are inside the map
				if (TestLocation()/* TeleportMove(bak_org + test_dir * test_dist)*/)
				{
					return true;
				}
			}

			if (test_dist == 0.0)
				break;
		}
	};

	UnlinkFromWorld();
	Origin = bak_org;
	LinkToWorld();
	return false;
}

//==========================================================================
//
//	Kill
//
//==========================================================================

void Kill(optional EntityEx inflictor, optional EntityEx source, optional bool bXDeath, optional name DamageType)
{
	Damage(inflictor, source, bXDeath ? Health - GibsHealth + 1 : Health + 1,
		specified_DamageType ? DamageType : 'InstantKill');
}

//==========================================================================
//
//	IsTeammate
//
//==========================================================================

bool IsTeammate(EntityEx Other)
{
	if (bOverrideCoop)
		return false;

	if (bIsPlayer && Other.bIsPlayer)
	{
		if (MainGameInfo(Level.Game).GameModel &&
			MainGameInfo(Level.Game).GameModel.TeamFactor(self, Other) ==
			GameModel::teamfactor_coop)
		{
			return true;
		}
		if ((MainGameInfo(Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM ||
			MainGameInfo(Level.Game).bIsCoopGame[MainGameInfo(Level.Game).GameType]) &&
			Player(Player).Team == Player(Other.Player).Team)
		{
			return true;
		}
	}
	if (::IsTeammate(Other))
	{
		return true;
	}
	return false;
}

//==========================================================================
//
//  HeresiarchMorphPlayer
//
//  [CW] Morph player into... err... something
//
//==========================================================================

bool HeresiarchMorphPlayer(int pclass, class<Actor> moclass)
{
	Actor beastMo;
	int i;
	int bak_level;

	if (bInvulnerable)
	{
		// Immune when invulnerable
		return false;
	}
	if (Player(Player).MorphTime || Class == PlayerHeresiarch)
	{
		// Player is already a beast
		return false;
	}

	Spawn(TeleportFog, Origin + vector(0.0, 0.0,
		MainGameInfo::TELEFOGHEIGHT));

	beastMo = Spawn(moclass, Origin);
	beastMo.Tracer = PlayerEx(Player).ReadyWeapon;
	beastMo.Angles = Angles;
	beastMo.Player = Player;
	beastMo.bIsPlayer = true;
	Player.Health = beastMo.Health;
	Player.MO = beastMo;
	Player.Camera = beastMo;
	BasicArmor BArmor = BasicArmor(FindInventory(BasicArmor));
	BArmor.Amount = 0;
	Player.PClass = pclass;
	beastMo.bFly = bFly;
	Player(Player).ActivateHeresiarchWeapon();

	// [CW] If morphed player cannot move from current position try to find more appropriate position or him
	if (!Actor(Player.MO).TryMove(Origin, true))
	{
		KArenaPlayerPawn(Player.MO).MoveToFreePosition();
	}
	else
	{
		Spawn(TeleportFog, Origin + vector(0.0, 0.0,
			MainGameInfo::TELEFOGHEIGHT));
	}

	// [CW] Recalc attributes based on the new player's body
	bak_level = Player(Player).exp_level;
	Player(Player).InitiateLevel();
	Player(Player).ActivateLevel(bak_level, false);

	SetState(FindState('FreeTargMobj'));

	return true;
}

//==========================================================================
//
//  BlindPlayer
//
//  [FB] Similar to Actor::Damage
//
//==========================================================================

void BlindPlayer(Actor blinder, int blind)
{
	if ((Player(Player).Cheats & Player::CF_GODMODE) || bInvulnerable)
	{
		return;
	}
	Player(Player).BlindCount += blind;
	if (blinder)
		Player(Player).PlayerBlinder = Player(blinder.Player);
	if (Player(Player).BlindCount > 220)
	{
		Player(Player).BlindCount = 220;
	}
	Player(Player).LastBlindTime = XLevel.Time;
}

//==========================================================================
//
//  BlindDamage
//
//==========================================================================

void BlindDamage(Actor source, int damage, bool playPainSound)
{
	Actor inflictor;

	inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer)
	{
		// Take half damage in trainer mode
		damage = ftoi(itof(damage) * Level.World.SkillDamageFactor);
	}
	if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
		bInvulnerable))
	{
		return;
	}
	Player.Health -= damage;	// mirror mobj health here for Dave
	if (Player.Health < 0)
	{
		Player.Health = 0;
	}
	Player(Player).Attacker = source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (bIsPlayer && inflictor && Player(Player).PClass != HexenDefs::PCLASS_PIG)
		{
			// Check for flame death
			if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
			{
				DamageType = 'Fire';
			}
			else
			{
				DamageType = inflictor.DamageType;
			}
		}
		DamageType = 'Blind';
		Died(source, inflictor);
		return;
	}
	if (playPainSound)
	{
		SetState(FindState('Pain'));
	}
}

//==========================================================================
//
//  Spawn_2
//
//==========================================================================

Actor Spawn_2(Thinker shooter, class<Thinker> Type, optional TVec AOrigin,
	optional TAVec AAngles, optional mthing_t* mthing)
{
	Actor A;
	if (specified_mthing)
		A = Actor(Spawn(Type, AOrigin, AAngles, mthing));
	else if (specified_AAngles)
		A = Actor(Spawn(Type, AOrigin, AAngles));
	else if (specified_AOrigin)
		A = Actor(Spawn(Type, AOrigin));
	else
		A = Actor(Spawn(Type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissile_2
//
//==========================================================================

Actor SpawnPlayerMissile_2(Thinker shooter, class<EntityEx> type)
{
	Actor A = Actor(SpawnPlayerMissile(type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileAngle_2
//
//==========================================================================

Actor SpawnPlayerMissileAngle_2(Thinker shooter, class<EntityEx> type, float angle)
{
	Actor A = Actor(SpawnPlayerMissileAngle(type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//===========================================================================
//
//  SpawnPlayerMissileAngleXYZ_2
//
//===========================================================================

Actor SpawnPlayerMissileAngleXYZ_2(Thinker shooter, TVec org, class<EntityEx> type,
	float angle)
{
	Actor A = Actor(SpawnPlayerMissileAngleXYZ(org, type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileEx_2
//
//==========================================================================

Actor SpawnPlayerMissileEx_2(Thinker shooter, class<EntityEx> type, bool RetExploded,
	out EntityEx AimTarget, optional float angle, optional TVec SpawnOrg)
{
	Actor A;
	if (specified_SpawnOrg)
		A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle, SpawnOrg));
	else if (specified_angle)
		A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle));
	else
		A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//	CanReach
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional EntityEx TargetEntity,
			  // [CW] use these three to override default passability calculations
			  optional float MaxPassableStep,
			  optional float MaxPassableDropOff,
			  optional float MinPassableOpening,
			  optional bool bCanUseLines)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!specified_TargetEntity)
		TargetEntity = none;

	if (!specified_MaxPassableStep)
		MaxPassableStep = MaxStepHeight;
	if (!specified_MaxPassableDropOff)
		MaxPassableDropOff = MaxDropoffHeight;
	if (!specified_MinPassableOpening)
		MinPassableOpening = Height;
	
	canreach = DoCanReachPathTraverse(TargetPos, TargetEntity, &CRTRData,
		MaxPassableStep, MaxPassableDropOff, MinPassableOpening, bCanUseLines);
	
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;
	
	if (canreach && TargetEntity)
	{
		//
		// [CW] CHECKME ---
		//
		//if (CRTRData.linetarget != TargetEntity)
		//	return false;

		
		// [FB]  3d Floor checks...
		float dist;
		if (TargetEntity.Origin.z > CRTRData.finalPos.z)
		{
			dist = CRTRData.finalPos.z + Height/2.0 + MaxPassableStep;

			if (TargetEntity.Origin.z > dist)
				return false;
		}
		if (TargetEntity.Origin.z <= CRTRData.finalPos.z)
		{
			dist = CRTRData.finalPos.z - (TargetEntity.Origin.z + TargetEntity.Height);
			// [FB] Always evaluate a positive distance
			dist = dist < 0.0 ? -dist : dist;

			if (dist > MaxPassableDropOff)
				return false;
		}
	}

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
// [FB] Added partial 3d floor support, needs to be checked and corrected...
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							EntityEx TargetThing,
							ReachTraverse::reach_traverse_data_t * pCRTRData,
							float MaxPassableStep,
							float MaxPassableDropOff,
							float MinPassableOpening,
							bool bCanUseLines)
{
	intercept_t *	in;
	//sector_t *		p_sector;
	opening_t *		opening;					// [FB] For 3d floors
	TVec			tracedir;
	TVec			hit_point;


	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	float traceZ = Origin.z; // Z coordinate of the trace

	// [CW] A unit vector determines the direction of tracing
	//		Needed to get the hit_point for each 2-sided line found
	tracedir = Normalise(TargetPos - Origin);
	tracedir.z = 0.0;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pCRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					(in->line->flags & ML_BLOCKEVERYTHING) ||
					!in->line->backsector)
				return false;

			// [CW] This is not used anymore
			/*// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			pCRTRData->prev_sector = p_sector;*/

			//
			// [FB] partial 3d floor support...
			//

			hit_point = Origin + (Length(Origin - TargetPos) * in->frac) * tracedir;
			hit_point.z = traceZ;
			// (c) JL: LineOpenings: sets opentop and openbottom to the window through a two sided line.
			opening = LineOpenings(in->line, hit_point);
			// (c) JL: FindOpening: Find the best gap that the thing could fit in, given a certain Z
			// position (z1 is foot, z2 is head)
			opening = FindOpening(opening, hit_point.z, hit_point.z + MinPassableOpening);

			// only valid openings
			if (!opening)
			{
				//	No openings.
				return false;
			}

#ifdef DEBUG_BOT_AI_CANREACH
			print("z = %f, opening = f %f/%f", traceZ, opening->bottom, opening->lowfloor);
			print("able: step = %f, drop = %f, fit = %f", MaxPassableStep, MaxPassableDropOff,
							MinPassableOpening);
#endif

			// [CW] Now, when we have the best opening available, we must check
			//		if the best is actually the passable
			//
			//		From what I saw in engine code, -
			//		opening->top is the lowest ceiling between previous and next sector;
			//		opening->bottom is the highest floor between previous and next sector;
			//		opening->range is distance between opening->top and opening->bottom;
			//		opening->lowfloor is the lowest floor between previous and next sector;
			//
			//
			if ((opening->range <= MinPassableOpening) // cannot fit through, do not bother
				||
				// If can fit through...
				// use traceZ to know which height is player's "ghost" previous position
				(traceZ == opening->bottom &&
					((opening->bottom - opening->lowfloor) > MaxPassableDropOff))
					// drop from highest floor to lowest one is too much to accept it
				||
				(traceZ == opening->lowfloor &&
					((opening->bottom - opening->lowfloor) > MaxPassableStep))
					// raise from lowest floor to highest one is too much to step/jump there
				)
			{
#ifdef DEBUG_BOT_AI_CANREACH
				print("failed");
#endif
				return false;
			}
#ifdef DEBUG_BOT_AI_CANREACH
				print("succeed");
#endif
			// [FB] This should partially cover it...

			// [CW] Update height position;
			// TODO WARNING FIXME -- what about slopes?? :(
			if (traceZ == opening->bottom)
				traceZ = opening->lowfloor;
			else
				traceZ = opening->bottom;
		}
		else
		{
			// [CW] Frankly speaking, this is no use in most situations... :(
			// TODO: check this precisely...
			pCRTRData->linetarget = EntityEx(in->Thing);

			if (!pCRTRData->linetarget)
				continue; // something out there

			if (pCRTRData->linetarget == TargetThing)
				break; // it is the target

			if (pCRTRData->linetarget.bSolid)
			{
				if (pCRTRData->linetarget.Height > MaxPassableStep &&
						!pCRTRData->linetarget.bShootable)
					return false;
			}
		}
	}

	pCRTRData->finalPos = TargetPos;
	pCRTRData->finalPos.z = traceZ;

	return true;
}

//==========================================================================
//
//	A_GetNearestEntity
//
//==========================================================================

final EntityEx A_GetNearestEntity(class<EntityEx> EClass, optional bool bReachable)
{
	EntityEx EE;
	EntityEx ee;
	float dist = -1.0;

	foreach AllThinkers(EClass, ee)
	{
		if (dist < 0.0 || Length(ee.Origin - Origin) < dist)
		{
			if (bReachable && !CanReach(ee.Origin))
				continue;
			EE = ee;
			dist = Length(ee.Origin - Origin);
		}
	}

	return EE;
}

defaultproperties
{
}
