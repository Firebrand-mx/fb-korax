//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		    ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The
//  main bot AI loop, B_Think, is called every tic.
//  Also included are various bot decision-making
//  procedures, such as B_CheckStuff and B_SetEnemy.
//
//**************************************************************************

// Main bot class
class BotPlayer : Object;

const float
	FORWARDWALK				= 200.0,
	FORWARDRUN				= 400.0,
	SIDEWALK				= 192.0,
	SIDERUN					= 320.0,

	MAX_TRAVERSE_DIST		= 1024.0,		// 10 meters, used within b_func.c
	AVOID_DIST				= 512.0,		// Try avoid incoming missiles once they reached this close
	SAFE_SELF_MISDIST		= 128.0,		// Distance from self to target where it's safe to pull a rocket.
	FRIEND_DIST				= 1024.0,		// To friend.
	DARK_DIST				= 256.0,		// Distance that bot can see enemies in the dark from.
	MAX_MONSTER_TARGET_DIST	= 1024.0,		// Too high can slow down the performance, see P_mobj.c
	ENEMY_SCAN_FOV			= 120.0,
	MAXMOVEHEIGHT			= 32.0,			// MAXSTEPMOVE but with jumping counted in.
	GETINCOMBAT				= 512.0,		// Max distance to item if it's due to be picked up in a combat situation.
	SHOOTFOV				= 60.0,
	MAXROAM					= (5.0 * 35.0);		// When this time is elapsed the bot will roam after something else.
const int WHATS_DARK		= 64;			// light value thats classed as dark.

/*

  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.

*/

// [FB] Bot Difficulty/skill settings/filters.
enum
{
	bsk_verypoor,
	bsk_poor,
	bsk_low,
	bsk_medium,
	bsk_high,
	bsk_excellent,
	bsk_supreme
};

struct botinfo_t
{
	string Name;		// Bot's name
	int accuracy;		// Accuracy with "instant" weapons (this includes "leading")
	int intelect;		// Accuracy with "missile" weapons (rocket launcher, etc.)
	int evade;			// Ability to dodge incoming missiles
	int anticip;		// Ability to anticipate "instant" shots
	int reaction;		// Overall reaction time (lower is "better")
	int pisschance;		// Chance the bot will get pissed when his threshold is reached
	int threshold;		// How much it takes to frustrate/piss off the bot
	int dangerlevel;	// When health is below this, we need some health
//	int wpfav;			// Favorite weapon
	int chatinfo;		// Bot's chat strings
	int chattime;		// How long it takes us to type a line
	int chatty;			// How talkative the bot is
//	char *colour;		// Colour (in form of a string)
//	char *gender;		// Male/female/it :)
//	char *skin;			// Skin
	int railcolour;		// Railgun trail colour
//	bool revealed;		// Hidden bots must be revealed
	string userinfo;
};

struct chatline_t
{
//	string		*string;
//	chattype_t  bot;
	chatline_t	*line;
};

struct chatinfo_t
{
	chatline_t		intro[5];
	chatline_t		inter[5];
	chatline_t		rare[5];
	chatline_t		frag[15];
	chatline_t		died[10];
	chatline_t		roam[10];
	chatline_t		pissed[5];
	chatline_t		frustrated[5];
	chatline_t		special[20];
};

enum { NUMTOTALBOTS = 336 };
enum { NUMBOTTYPES = 336 };

//
// The things the bot knows about their enemy
//
struct enemyinfo_t
{
	int		health;
	int		weap;
};

//
// Bot states
//
struct botstate_t
{
	// [FB] OK, this is how this is supposed to work:
	// 	if botstate == 0 -> Bot is deciding what to do
	// 	if botstate == 1 -> Bot is "fetching" something (offense)
	// 	if botstate == 2 -> Bot is defending something
	// 	if botstate == 3 -> Bot is heading to scoring place
	int BState;
};

Player player;		// Points to reference player
Actor botmo;

// Destinations
Actor item;			// Item (roam towards weapon, etc)
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal;			// Teamgame goal spot
Actor node;			// Node we're heading towards
Actor prev;			// Previous node we were at
TVec posdest;			// Position of our destination (doesn't have to be an actor)
bool posdest_valid;
Actor enemy;			// The dead meat.
TVec lastpos;			// Last place we saw our enemy
bool lastpos_valid;
Actor missile;			// A threathing missile that got to be avoided.

Actor ally;			// Ally to tag along with
Actor last_mate;		// If bots mate dissapeared (not if died) that mate is
				// pointed to by this. Allows bot to roam to it if
				// necessary.
Actor ball;			// Active Soccer Ball ingame

enemyinfo_t enemyinfo;		// Things we know about our enemy
botstate_t botstate;		// What we're doing in teamgame mode

float	lastx;			// Last known x location of bot's enemy (go there if enemy goes out of sight)
float	lasty;			// Last known y location of bot's enemy

// Tickers

float t_respawn;
float t_strafe;
float t_react;
float t_fight;
float t_rocket;
float t_turn;
float t_pissed;
float t_frust;
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;
float t_chat;			// Tics left until bots completes "typing" in what he's saying.
				// Bot also doesn't do anything during this time.

float forwardmove;	// For building ucmd
float sidemove;

// Misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

chatline_t	*chatline;	// For when t_chat expires

//bottype_t	bottype;	// Bot type
botinfo_t info;			// Aiming, name, perfection, yadda yadda

int angerlevel;

float angle;			// The wanted angle that the bot tries to get every tic.

float count;			// [FB] Roam Count

// [FB] Copy of certain affected stats for Darkness
int old_intelect;
int old_anticip;
int old_evade;
int old_accuracy;

// [FB] Used to determine if stats have been reduced
bool accuracy_r;
bool intelect_r;
bool evade_r;
bool anticip_r;

//==========================================================================
//
//	AngleTo
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	CheckItem
// 
//	Determines if we should bother picking up an item or not
//
//==========================================================================

bool CheckItem(Actor item)
{
	Inventory TmpItem;
	int piece;

	bNewItemIsWeapon = false;
	bNewItemIsPowerup = false;

	if (!item)
		return false;
	if (!item.bSpecial)
		return false;

	if (WeaponPickup(item))
	{
		bNewItemIsWeapon = true;
		WeaponPickup Wpn = WeaponPickup(item);

		/*if ((weapon > WP_FOURTH && player.exp_level < 2) ||
		      (weapon == WP_EIGHTH && player.exp_level < 3))
		{
			return false;
		}*/

		// If we don't have the weapon, pick it up
		bool HaveWeapon = false;
		for (TmpItem = botmo.Inventory; TmpItem; TmpItem = TmpItem.Inventory)
		{
			if (Weapon(TmpItem) && Weapon(TmpItem).Slot == Wpn.Slot)
			{
				HaveWeapon = true;
				break;
			}
		}
		if (!HaveWeapon)
		{
			return true;
		}

		//	Check if we can pick it up for mana
		if (Wpn.AmmoType1)
		{
			Inventory ManaItem = botmo.FindInventory(Wpn.AmmoType1);
			if (!ManaItem || ManaItem.Amount < ManaItem.MaxAmount)
			{
				return true;
			}
		}
		if (Wpn.AmmoType2)
		{
			Inventory ManaItem = botmo.FindInventory(Wpn.AmmoType2);
			if (!ManaItem || ManaItem.Amount < ManaItem.MaxAmount)
			{
				return true;
			}
		}
		if (Wpn.AmmoType3)
		{
			Inventory ManaItem = botmo.FindInventory(Wpn.AmmoType3);
			if (!ManaItem || ManaItem.Amount < ManaItem.MaxAmount)
			{
				return true;
			}
		}
		return false;
	}

/*	piece = WeapPieceFromItem(item);
	if (piece != -1)
	{
		bNewItemIsWeapon = true;

		// If we don't have the weapon, pick it up
//[Korax]
/*		if (!(player.Pieces & piece))
			return true;

		// If we have no more room for the mana it gives
		if (player.Mana[MANA_1] == MAX_MANA &&
			player.Mana[MANA_2] == MAX_MANA)
			return false;
*/

	if (Ammo(item))
	{
		// If we have no more room for the mana it gives
		Inventory ManaItem = botmo.FindInventory(Ammo(item).GetParentAmmo());
		if (ManaItem && ManaItem.Amount == ManaItem.MaxAmount)
			return false;
	}

	if (item.Class == ItemHealingBottle || item.Class == ArtifactHealthFlask ||
	     item.Class == ArtifactSuperHeal)
	{
		if(player.MO.Health >= player.max_health)
		{
			return false;
		}
		else if(player.PClass == HexenDefs::PCLASS_PIG && player.MO.Health >= 30)
		{
			// [FB] For morphed bots health
			// [CW] ...suppose this fits only pig-morphed ones
			return false;
		}
	}

	/*if (!ArtifactBoostArmor(item) && !ArtifactInvulnerability(item) &&
		!ArtifactSpeedBoots(item) && !ArtifactBoostMana(item) &&
		!ArtifactInvisibility(item) && !ArtifactPIDamage(item) &&
		!ArtifactTorch(item))
		return false;*/

	if (HexenKey(item) && player.Level.Game.deathmatch)
		return false;

	// [FB] Guess we're okay
	return true;
}

//==========================================================================
//
//	CheckPNodes
// 
//	[FB] Determines if the bot should get to a Path Node
//
//==========================================================================

bool CheckPNodes(Actor node)
{
	if (/*player.MO.CanSee(node) &&*/ (node != prev /*&& botmo.DistTo(node) <= 32.0*/))
	{
		if (MainGameInfo(player.Level.Game).GameType < HexenDefs::NUMGAMESNOTEAM ||
		    MainGameInfo(player.Level.Game).GameType == HexenDefs::game_dmteam && (node.Class == PathNode 
		    /*|| node.Class == SniperSpot*/))
			return true;

		// [FB] Node checking routine for team game
		//	This is mainly used in CTF for now so...
		if(MainGameInfo(player.Level.Game).GameModel && MainGameInfo(player.Level.Game).GameType == HexenDefs::game_ctf)
		{
			if (player.Team)
			{
				// [FB] Blue Team ... err, Team 1 :)
				if (MainGameInfo(player.Level.Game).Teams[0])
				{
					switch (botstate.BState)
					{
						// [FB] Offense
						case 1:
							if (node.Class == BlueNode)
								return true;
								break;
						// [FB] Defense
						case 2:
							if (node.Class == BlueGuardSpot)
								return true;
								break;
						// [FB] Return
						case 3:
							if (node.Class == BlueGoalSpot)
								return true;
								break;
						default:
								return false;
					}
				}
				// [FB] Team 2
				else if (MainGameInfo(player.Level.Game).Teams[1])
				{
					switch (botstate.BState)
					{
						// [FB] Offense
						case 1:
							if (node.Class == RedNode)
								return true;
								break;
						// [FB] Defense
						case 2:
							if (node.Class == RedGuardSpot)
								return true;
								break;
						// [FB] Return
						case 3:
							if (node.Class == RedGoalSpot)
								return true;
								break;
						default:
								return false;
					}
				}
			}
		}
	}

	return false;
}

//==========================================================================
//
//	SetEnemy
//
//==========================================================================

void SetEnemy()
{
	if (enemy && enemy.Health > 0 && player.MO &&
	    player.MO.CanSee(enemy))
	{
		return;
	}

	bAllRound = !!enemy;
	enemy = FindEnemy();

	if (!enemy)
		return;
	
	// Double check the validity of the enemy
	if (!enemy.bShootable || enemy.bDormant)
		enemy = none;
}

//==========================================================================
//
//	CheckActiveBall
//
//	[FB] As the name suggests, it checks for the active ball in game
//
//==========================================================================

bool CheckActiveBall(Actor check)
{
	// [FB] Are we in football gameplay mode?
	if(MainGameInfo(player.Level.Game).GameModel && MainGameInfo(player.Level.Game).GameType == HexenDefs::game_football)
 	{
		// [FB] Check for an active ball
		if (GameFootball(MainGameInfo(player.Level.Game).GameModel).Ball &&
		    check == GameFootball(MainGameInfo(player.Level.Game).GameModel).Ball)
		{
			if (player.MO.CanSee(check) && botmo.DistTo(check) <= 32.0)
 			{
				return true;
			}
		}
	}

	return false;		
}

//==========================================================================
//
//	SetAction
//
//	Decide what to do in teamgame (defend, whatever)
//
//==========================================================================

void SetAction()
{
	int i;
	int defenders = 0;
	int attackers = 0;

	if (!player.Team)
		return;

	// [FB] We are deciding what to do
	if (botstate.BState == 0)
	{
		// Let's see what the other bots on our
		// team are doing, and decide our action based
		// off on that
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO && 
			    Player(player.Level.Game.Players[i]).bIsBot && 
			    Player(player.Level.Game.Players[i]).Team == player.Team)
			{
				// [FB] Is this bot in Offense?
				if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == 1)
					attackers++;
				// [FB] Is this bot in Defense?
				if (Player(player.Level.Game.Players[i]).Bot.botstate.BState == 2)
					defenders++;
			}
		}

		// Defense wins championships...
		if (defenders <= attackers)
			// [FB] Then get on defense
			botstate.BState = 2;
		else
			// [FB] Then get on offense
			botstate.BState = 1;
	}
}

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	switch (sec->special & ~SECSPEC_SECRET_MASK)
	{
		case 4:		// Scroll_EastLavaDamage
		case 5:		// Damage_LavaWimpy
		case 7:		// Damage_Sludge
		case 16:	// Damage_LavaHefty
			return true;
	}

	return false;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;
	intercept_t* in;
	float bottracerange;
	TVec bottracedir;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	bottracedir.z = 0.0;	
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + botmo.Radius + dist * bottracedir.x;
 	y2 = y1 + botmo.Radius + dist * bottracedir.y;

	// [FB] Use lines
	player.P_UseLines();

	//	[BC] For the bots
	//	[FB] Additions for 3d floor checks
	foreach botmo.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS)
	{
		EntityEx th;
		line_t *ld;
		TVec hit_point;
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight, dheight;

		if (in->bIsALine)
		{
			ld = in->line;	// This linedef
			hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

			// Line is impassible
			if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING))
			{
				return false;
			}

			// Line isn't two sided
			if (!ld->backsector)
			{
				return false;
			}

			if (!PointOnPlaneSide(botmo.Origin, ld))
			{
				back = ld->backsector;
				front = ld->frontsector;
			}
			else
			{
				back = ld->frontsector;
				front = ld->backsector;
			}

			// Sector is dangerous
			if (IsDangerous(back))
			{
				return false;
			}

			// crosses a two sided line
			open = LineOpenings(ld, hit_point);
			open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);

			// No valid openings
			if (!open || open->range <= botmo.Height)
			{
				return false;
			}
			else
			{
				// [FB] No cliff jumping unless we're going after something
				if ((open->lowfloor - open->bottom) > 32.0 && (open->lowfloor - open->bottom) < 384.0 && !enemy)
				{
					return false;
				}

				// [FB] Determine if it's wise to jump up to a floor
				diffheight = open->bottom - open->lowfloor;

				if (diffheight > 0.0)
				{
					if (diffheight >= 24.0 && diffheight <= 56.0)
					{
						botmo.Player.Buttons |= BT_JUMP;
						continue;
					}
					else if (diffheight > 56.0)
					{
					/*	if (front->SSpecial == ThrustThingZ || front->springpadzone)
						{
							return true;
						}
						else*/
							return false;
					}
				}
			}
		}
		else
		{
			th = EntityEx(in->Thing);

			if (Actor(th) == botmo)
			{
				continue;
			}

			if (th.bSolid)
			{
				// [FB] Jump to avoid something
				dheight = th.Origin.z + th.Height - botmo.Origin.z;

				if (dheight >= 24.0 && dheight <= 56.0)
				{
					botmo.Player.Buttons |= BT_JUMP;
					continue;
				}

				return false;
			}

			// [FB] Jump to reach something
			dheight = th.Origin.z + th.Height - botmo.Origin.z;

			if (dheight >= 24.0 && dheight <= 56.0)
			{
				botmo.Player.Buttons |= BT_JUMP;
				continue;
			}
		}
	}

	return true;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if a location is reachable
//
//==========================================================================

bool CheckTo(TVec pos)
{
	float dist;
	float an;

	dist = Length(botmo.Origin - pos);
	an = GetAngle();

	if (!CheckPath(an, dist) || (pos.z - botmo.Origin.z) >= 56.0/*48.0*/)
		return false;

	return true;
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff()
{
/*	if (goal)
	{
		if (!CheckTo(goal.Origin) || (botmo.DistTo(goal) < botmo.Radius))
		{
			goal = none;
		}
	}*/

	if (item)
	{
		if (!CheckTo(item.Origin) || !item.bSpecial ||
		     item.IsDestroyed()) // somebody picked
			item = none;
	}

	if (node)
	{
		if (!CheckTo(node.Origin)/* || (botmo.DistTo(node) < botmo.Radius)*/)
		{
			prev = node;
			node = none;
		}
	}

	if (ball)
	{
		if (!CheckTo(ball.Origin))
		{
			ball = none;
		}
	}

	if (posdest_valid)
	{
		TVec dir;
		dir = posdest - botmo.Origin;
		dir.z = 0.0;
		if (!CheckTo(posdest) || (Length(dir) < botmo.Radius))
		{
			posdest_valid = false;
		}
	}

	if (lastpos_valid)
	{
		TVec dir;
		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if (!CheckTo(lastpos) || (Length(dir) < botmo.Radius))
		{
			lastpos_valid = false;
		}
	}

	if (enemy)
	{
		if (!CheckTo(enemy.Origin) || enemy.Health <= 0 || !enemy.bShootable || enemy.bDormant)
			enemy = none;
	}

	if (missile)
	{
		if (!missile.bMissile || missile.IsDestroyed())
			missile = none;
	}
}

//==========================================================================
//
//	Check_LOS
//
//	Doesn't check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(Actor to, float vangle)
{
	if (!botmo.CanSee(to))
		return false; // out of sight
	if (vangle == 360.0)
		return true;
	if (vangle == 0.0)
		return false; // Looker seems to be blind.

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	Scan
//
//	Scan all mobj's visible to the bot for incoming missiles, enemies, and
// various items to pick up.
//
//==========================================================================

void Scan()
{
	Actor actor;

	foreach botmo.AllThinkers(Actor, actor)
	{
		if (!actor.bSpecial && !actor.bMissile)
		{
			// Not interested in this one
			continue;
		}
		if (Check_LOS(actor, 90.0))
		{
			// Look for special items
			if (!item && actor.bSpecial)
			{
				if (CheckItem(actor))
				{
					item = actor;
					bItemIsWeapon = bNewItemIsWeapon;
					bItemIsPowerup = bNewItemIsPowerup;
				}
			}
			else if (!node)
			{
				if (CheckPNodes(actor))
				{
					node = actor;
				}
			}
			else if (!ball)
			{
				if (CheckActiveBall(actor))
				{
					ball = actor;
				}
			}
			else if (!missile && actor.bMissile && (botmo.DistTo(actor) <= AVOID_DIST))
			{
				missile = actor;
			}
		}
	}
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
		return skill;

	skill -= num;
	if (skill < 0)
		skill = 0;

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
	angle = AngleMod360(an);
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle()
{
	return angle;
}

//==========================================================================
//
//	AimProjectile
//
// 	[FB] Projectile weapons
//
//==========================================================================

void AimProjectile(float dist, bool right, float an)
{
	switch (info.intelect)
	{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			// Aim right at the enemy
			SetAngle(an);
			break;
		case bsk_medium:
		case bsk_high:
		case bsk_excellent:
		case bsk_supreme:
			if (right)
				SetAngle(an + Random() * 20.0);
			else
				SetAngle(an - Random() * 20.0);
			break;

		default:
			Error("Unknown bot skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	AimInstant
//
// 	[FB] Instant weapons
//
//==========================================================================

void AimInstant(float dist, bool right, float an)
{
	switch (info.accuracy)
	{
		case bsk_verypoor:
			if (right)
				SetAngle(an + Random() * 60.0);
			else
				SetAngle(an - Random() * 60.0);
			break;
		case bsk_poor:
			if (right)
				SetAngle(an + Random() * 45.0);
			else
				SetAngle(an - Random() * 45.0);
			break;
		case bsk_low:
			if (right)
				SetAngle(an + Random() * 30.0);
			else
				SetAngle(an - Random() * 30.0);
			break;
		case bsk_medium:
			if (right)
				SetAngle(an + Random() * 15.0);
			else
				SetAngle(an - Random() * 15.0);
			break;
		case bsk_high:
			SetAngle(an);
			break;
		case bsk_excellent:
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		case bsk_supreme://FIXME
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		default:
			Error("Unknown bot skill level: %d", info.accuracy);
			return;
	}
}

//==========================================================================
//
//	BotAim
//
//==========================================================================

void BotAim()
{
	float dist;
	bool right;
	float an;

	if (!enemy)
		return;

	if (t_react)
		return;

	// Distance to enemy.
	dist = botmo.DistTo2(enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [FB] Decide our weapon if we have an enemy
	//NOTE the old code didn't change weapon correctly meaning this would
	// never work. I'll enable fixed version but with very low chance.
	if (Random() < 0.001)
	{
		Weapon Best = B_ChooseWeapon(dist);
		if (Best && Best != player.ReadyWeapon)
		{
			player.PendingWeapon = Best;
		}
	}

	// [BC] Cajun prediction... maybe use this somewhere
	/*
			{
			//Here goes the prediction.
			dist = P_AproxDistance(MO->x - enemy->x, MO->y - enemy->y);
			fixed_t m = (dist/FRACUNIT) / mobjinfo[MT_PLASMA].speed;
			bot->SetAngle(R_PointToAngle2(MO->x,
						      MO->y,
						      enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
						      enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));
			}
	*/

	// Fix me: Implement botskill, accuracy, and intelligence
	// [FB] Decide which kind of aiming the bot will use...
	if (player.ReadyWeapon.bBotProjectile)
	{
		AimProjectile(dist, right, an);
	}
	else
	{
		AimInstant(dist, right, an);
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy()
{
	float closest_dist, dist;
	Actor target;
	float vangle;
	int i, light;
	Actor actor;

	// Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
		vangle = 360.0;
	else
		vangle = ENEMY_SCAN_FOV;
	bAllRound = false;

	// [FB] Search for monster enemies
	foreach botmo.AllThinkers(Actor, actor)
	{
		dist = botmo.DistTo(actor);

		if (!(actor.bMonster))
			continue;
		if (!Check_LOS(actor, vangle))
			continue;
		if (!botmo.CanSee(actor))
			continue;
		if (actor.Health <= 0)
			continue;
		// [FB] We spawned the minotaur? we shouldn't attack him then!
		if (actor.Class == Minotaur)
		{
			if (actor.Tracer == botmo)
				continue;
			// [FB] Don't attack a friendly minotaur in all these cases
			if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep)
				continue;
			else if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				// [FB] Check if the minotaur's instigator is in the same team we are on
				for(i = 0; i < MAXPLAYERS; i++)
				{
					if (actor.Tracer == player.Level.Game.Players[i] && 
						Player(player.Level.Game.Players[i]).Team == player.Team)
						continue;
				}
				// [FB] Check if an advanced game mode is active
				if (MainGameInfo(player.Level.Game).GameModel)
				{
					int teamfactor;

					teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(actor.Tracer,
								Actor(botmo));
					// [FB] We've got a team factor, just check if it's an ally or not
					if (teamfactor != GameModel::teamfactor_any &&
						teamfactor != GameModel::teamfactor_enemy)
						continue;
				}
			}
		}
		if (dist > MAX_MONSTER_TARGET_DIST)
			continue;

		target = none;
		closest_dist = 99999.0;

		 // Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always
		 // returns false. tought it should be the same checksight as below but.. (below works) something
		 // must be fuckin wierd screded up.
		if (Check_LOS(actor, vangle))
		{
			if (botmo.CanSee(actor))
			{
				dist = botmo.DistTo(actor);
				light = actor.Sector->params.lightlevel; // [FB] Detect the light level
				// [FB] Too dark?
				if (light < WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
					continue;
				if (dist < closest_dist)
				{
					closest_dist = dist;
					target = actor;
				}
			}
		}
		return target;
	}

	target = none;
	closest_dist = 99999.0;

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (player.Level.Game.Players[i] && player.Level.Game.Players[i].MO &&
		    player.Level.Game.Players[i].MO.Health > 0 && !Player(player.Level.Game.Players[i]).bUnControllable && 
			botmo != player.Level.Game.Players[i].MO)
		{
			if (MainGameInfo(player.Level.Game).GameModel) // [CW] Check if an advanced game mode is active
			{
				int teamfactor;
				if (player.Level.Game.Players[i])
				{
					teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(Actor(botmo),
						     Actor(player.Level.Game.Players[i].MO));
					// [CW] We've got a team factor, check if it can be an enemy
					if (teamfactor != GameModel::teamfactor_any &&
					    teamfactor != GameModel::teamfactor_enemy)
						continue;
				}
			}

			// [FB] Are we on a Team gameplay mode?
			if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
			{
				// [FB] Don't attack same team players
				if (Player(player.Level.Game.Players[i]).Team == player.Team)
					continue;
			}
			if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep)
			{
				// [FB] Don't attack fellow players in some gameplay modes
				if (player.Level.Game.Players[i])
					continue;
			}
			// Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost
			// always returns false. tought it should be the same checksight as below but.. (below
			// works) something must be fuckin wierd screded up.
			if (Check_LOS(Actor(player.Level.Game.Players[i].MO), vangle))
			{
				if (botmo.CanSee(player.Level.Game.Players[i].MO))
				{
					dist = botmo.DistTo(player.Level.Game.Players[i].MO);
					// [FB] Detect the light level
					light = player.Level.Game.Players[i].MO.Sector->params.lightlevel;
					// [FB] Too dark?
					if (light < WHATS_DARK && dist > DARK_DIST && !botmo.FindInventory(PowerTorch))
						continue;
					if (dist < closest_dist)
					{
						closest_dist = dist;
						target = Actor(player.Level.Game.Players[i].MO);
					}
				}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	B_ChooseWeapon
//
//	[FB] Decide which weapon would be best to use in our situation
//
//==========================================================================

Weapon B_ChooseWeapon(float dist)
{
	Inventory		Item;
	KArenaWeapon	Wpn;
	Weapon			Best = none;

	if (enemy)
	{
		for (Item = botmo.Inventory; Item; Item = Item.Inventory)
		{
			Wpn = KArenaWeapon(Item);
			if (!Wpn)
			{
				//	Not a weapon.
				continue;
			}
			if (dist <= Actor::MELEERANGE)
			{
				if (!Wpn.bBotChooseMelee)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else if (dist <= 512.0)
			{
				if (!Wpn.bBotChooseMedium)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			else
			{
				if (!Wpn.bBotChooseRanged)
				{
					//	Not suitable for this range.
					continue;
				}
			}
			if (!Wpn.CheckAmmo(false))
			{
				//	Not enough ammo.
				continue;
			}
			Best = Wpn;
		}
		if (Best)
		{
			return Best;
		}
	}
	// Didn't find anything good
	return player.ReadyWeapon;
}

//==========================================================================
//
//	B_SetAlly
//
//	[FB] This function is called every tick (for each bot) to set the
//	     mate (teammate coop mate).
//
//==========================================================================

Actor B_SetAlly()
{
	float closest_dist, test;
	Actor target;
	int i, j;

	//is mate alive?
	if (ally)
	{
		if (ally.Health <= 0)
		{
			ally = none;
			return ally;
		}
		else
		{
			last_mate = ally;
			return ally;
		}
	}

	//Check old_mates status.
	if (!ally && last_mate)
	{
		if (last_mate.Health <= 0)
		{
			last_mate = none;
			ally = last_mate;
			return ally;
		}
		else
		{
			ally = last_mate;
			return ally;
		}
	}

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (MainGameInfo(player.Level.Game).GameModel) // [FB] Check if an advanced game mode is active
		{
			int teamfactor;
			if (player.Level.Game.Players[i])
			{
				teamfactor = MainGameInfo(player.Level.Game).GameModel.TeamFactor(Actor(botmo),
						Actor(player.Level.Game.Players[i].MO));
				// [FB] We've got a team factor, just check if it's an ally or not
				if (teamfactor != GameModel::teamfactor_any &&
					teamfactor != GameModel::teamfactor_enemy)
				{
					ally = Actor(player.Level.Game.Players[i].MO);
					return ally;
				}
			}
		}

		// [FB] Set an ally for team game modes
		if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
		{
			if (player.Level.Game.Players[i] && Player(player.Level.Game.Players[i]).Team == player.Team)
			{
				ally = Actor(player.Level.Game.Players[i].MO);
				return ally;
			}
		}
		else if (MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) // [FB] Set an ally if we're in a mode that has one
		{
			if (player.Level.Game.Players[i])
			{
				ally = Actor(player.Level.Game.Players[i].MO);
				return ally;
			}
		}
	}

	closest_dist = 99999.0;

	//Check for player friends
	for (j = 0; j < MAXPLAYERS; j++)
	{
		// [FB] Team game modes
		if (MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM)
		{
			if ((player.Level.Game.Players[j])
			    && (botmo != player.Level.Game.Players[j].MO)
			    && (Player(player.Level.Game.Players[j]).Team == player.Team)
			    && (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2))
			{
				if (botmo.CanSee(player.Level.Game.Players[j].MO))
				{
					test = botmo.DistTo(player.Level.Game.Players[j].MO);

					if (test < closest_dist)
					{
						closest_dist = test;
						target = Actor(player.Level.Game.Players[j].MO);
						ally = target;
						return ally;
					}
				}
			}
		}
		else if(MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) // [FB] Other ally gameplay modes (no player colour checking)
		{
			if ((player.Level.Game.Players[j])
			    && (botmo != player.Level.Game.Players[j].MO)
			    && (player.Level.Game.Players[j].MO.Health <= botmo.Health / 2))
			{
				if (botmo.CanSee(player.Level.Game.Players[j].MO))
				{
					test = botmo.DistTo(player.Level.Game.Players[j].MO);

					if (test < closest_dist)
					{
						closest_dist = test;
						target = Actor(player.Level.Game.Players[j].MO);
						ally = target;
						return ally;
					}
				}
			}
		}
	}

	return none;
}

//==========================================================================
//
//	Roam
//
//	Handle non-attack/dodging movement
//
//==========================================================================

void Roam()
{
	TVec dest;


	// Order of item response precedence:
	if (goal)
	{
		dest = goal.Origin;
	}
	else if (item)
	{
		dest = item.Origin;
	}
	else if (node)
	{
		dest = node.Origin;
	}
	else if (ball)
	{
		dest = ball.Origin;
	}
	else if (lastpos_valid)
	{
		TVec dir;
		
		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if (Length(dir) <= 32.0)
		{
			lastpos_valid = false;
			return;
		}
		else
		{
			dest = lastpos;
		}
	}
	else if (posdest_valid)
	{
		dest = posdest;
	}
	else
	{
		// No target, so just run around until we find something
		float an = GetAngle();
		float dist;
		float ang_inc;

		// [FB] Create a circle of possible destinations around the bot's current Origin
		//	  with the given distances
		for (dist = 256.0; dist >= 64.0; dist -= 64.0)
		{
			for (ang_inc = 0.0; ang_inc <= 360.0; ang_inc += 45.0 / 3.0) /*45.0*/
			{
				if (CheckPath(an, dist))
				{
					posdest_valid = true;
					posdest.x = botmo.Origin.x + dist * cos(an);
					posdest.y = botmo.Origin.y + dist * sin(an);
//				posdest.z = botmo.Origin.z;
					posdest.z = botmo.FloorZ;
					SetAngle(an);
					break;
				}

				if (CheckPath(an + ang_inc, dist))
				{
					posdest_valid = true;
					posdest.x = botmo.Origin.x + dist * cos(an + ang_inc);
					posdest.y = botmo.Origin.y + dist * sin(an + ang_inc);
//				posdest.z = botmo.Origin.z;
					posdest.z = botmo.FloorZ;
					SetAngle(an + ang_inc);
					break;
				}

				// Left is no good, try right
				if (CheckPath(an - ang_inc, dist))
				{
					posdest_valid = true;
					posdest.x = botmo.Origin.x + dist * cos(an - ang_inc);
					posdest.y = botmo.Origin.y + dist * sin(an - ang_inc);
//				posdest.z = botmo.Origin.z;
					posdest.z = botmo.FloorZ;
					SetAngle(an - ang_inc);
					break;
				}
			}
		}

		if (posdest_valid)
		{
			dest = posdest;
		}
		else
		{
			SetAngle(GetAngle() + 45.0 / 3.0);
			forwardmove = -FORWARDWALK;
			return;
		}
	}

	// [FB] The problem of stuck bots seems to be here,
	//	   it seems bots sometimes like to see things behind solid
	//	   walls and tend to "walk" to them, but they just get stuck
	//	  stupidly, we add a check to avoid this
	if (CheckTo(dest))
	{
		forwardmove = FORWARDRUN;
		SetAngle(AngleTo(dest));
	}
	else
	{
		SetAngle(GetAngle() + 45.0 / 3.0);
		forwardmove = -FORWARDWALK;
		return;
	}
}

//==========================================================================
//
//	Move
//
//	Main bot movement function.
//	Dodging/attacking movement is also handled here
//
//==========================================================================

void Move(float deltaTime)
{
	float dist;

	// Worry about missiles above all else
	if (missile)
	{
		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (!t_strafe)
			{
				// Don't change direction while dodging missiles (that could be bad)
				//bot->sidemove = -bot->sidemove;
				t_strafe = 2.0;
			}
		}

		// Look at the missile and sidestep it
		SetAngle(AngleTo(missile.Origin));
		forwardmove = -FORWARDRUN;
		return;
	}

	// Anticipate a shot: time to dodge!
	if (enemy && t_anticip <= 0.25)
	{
		if (!sidemove)
			sidemove = SIDERUN;

		switch (info.anticip)
		{
		case bsk_verypoor:
			// Deer caught in the headlights
			sidemove = 0.0;
			return;

		case bsk_poor:
			// Always walk right
			sidemove = SIDEWALK;
			break;

		case bsk_low:
			// Always run right
			sidemove = SIDERUN;
			break;

		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe)
			{
				t_strafe -= deltaTime;
				if (t_strafe <= 0.0)
				{
					sidemove = -sidemove;
					t_strafe = 2.0;
				}
			}
			break;

		case bsk_high:
			// Switch directions when we think our opponent will fire
			if (!t_anticip)
				sidemove = -sidemove;
			break;

		case bsk_excellent:
			// Move in a somewhat random direction when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;

				if (Random() < 0.5)
				{
					forwardmove = -FORWARDWALK;
				}
			}
			break;

		case bsk_supreme:
			// What a squirmy little fucker!
			if (!t_anticip)
			{
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}
			break;

		default:
			Error("Unknown bot skill level: %d", info.anticip);
			return;
		}
	}

	// Now handle attack movement
	if (enemy)
	{
		bool noforward;
		bool noside;
		float an;

		noforward = false;
		noside = false;
		if (!sidemove)
			sidemove = SIDERUN;

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		dist = botmo.DistTo(enemy);

		// Remember where we saw him last in case he gets away
		lastpos = enemy.Origin;
		lastpos_valid = true;

		// Check if we'd rather pick up something than fight
		if (item)
		{
			float itemdist;

			itemdist = botmo.DistTo(item);

			if (bItemIsPowerup ||
			     (bItemIsWeapon && (player.ReadyWeapon.bWimpyWeapon)) ||
			     (enemy.bIsPlayer && bItemIsWeapon && 
			     player.ReadyWeapon.Slot < Player(enemy.Player).ReadyWeapon.Slot) || 
			     ((item.Class == ItemHealingBottle || item.Class == ArtifactHealthFlask ||
			       item.Class == ArtifactSuperHeal) && (botmo.Health <= (player.max_health / 2))) &&
			     itemdist <= GETINCOMBAT)
			{
				Roam();
				return;
			}
		}

		an = botmo.Angles.yaw;
		if (sidemove < 0.0)
			an -= 90.0;
		else
			an += 90.0;

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
		{
			an += (an > 180.0 ? -180.0 : 180.0);
			if (CheckPath(an, 48.0))
				sidemove = -sidemove;
			else
				sidemove = 0.0;
		}

		float combatdist = player.ReadyWeapon.BotCombatDist;
		if ((MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
			MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweepteam) &&
			combatdist > Actor::MELEERANGE)
		{
			combatdist /= 2.0;
		}
		if (CheckTo(enemy.Origin) && dist > combatdist)
		{
			//if (combatdist[player.PClass * NUMWEAPONS + player.ReadyWeapon] == 48.0)
				//dprint("Going forward %d %d", forwardmove, sidemove);
			forwardmove = FORWARDRUN;
		}
		else
			forwardmove = -FORWARDRUN;

		return;
	}

	// [FB] Follow our buddy if we're tagging along
	if (ally || (ally && !enemy))
	{
		Ally_Tag(deltaTime);
		return;
	}

	// [FB] We cover movement to ball here too
	if (ball)
	{
		float balldist;

		balldist = botmo.DistTo(ball);

		// [FB] We are close enough to kick the ball
		if (CheckTo(ball.Origin) && balldist <= Actor::MELEERANGE * 6.0)
		{
			botmo.Player.Buttons |= BT_USE;
			return;
		}
	}
	
	if (t_strafe)
	{
		t_strafe -= deltaTime;
		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}
	}

	// Roam after an item
	Roam();
}

//==========================================================================
//
//	Ally_Tag
//
// 	[FB] Follow our buddy if we're tagging along
//
//==========================================================================

void Ally_Tag(float deltaTime)
{
	float matedist, an;

	if (t_strafe)
	{
		t_strafe -= deltaTime;
		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}
	}

	matedist = botmo.DistTo(ally);

	SetAngle(AngleTo(ally.Origin));

	if (matedist > (FRIEND_DIST * 2.0))
		forwardmove = FORWARDRUN;
	else if (matedist > FRIEND_DIST)
		forwardmove = FORWARDWALK;
	else if (matedist < FRIEND_DIST - (FRIEND_DIST / 3.0)) // [FB] Got too close, so move away.
		forwardmove = -FORWARDWALK;
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack()
{
	// Still reacting to something or we don't have an enemy to fight
	if (t_react || !enemy)
		return;

	// [FB] Check if our allies are out of the way of the attack
	if (ally && Check_LOS(ally, SHOOTFOV))
		return;

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
		return;

	// [FB] Don't attack if the distance is not the right one for this weapon
	float combatdist = player.ReadyWeapon.BotCombatDist;
	if ((MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep ||
		MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweepteam) &&
		combatdist > Actor::MELEERANGE)
	{
		combatdist /= 2.0;
	}
	if (botmo.DistTo(enemy) > combatdist)
		return;
	
	player.Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//
//==========================================================================

void Turn()
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

	if (!enemy)
	{
		player.ViewAngles.yaw = GetAngle();
		return;
	}

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			if (distance > 7.5)
				distance = 7.5;
			if (distance < -7.5)
				distance = -7.5;
			break;
		case bsk_medium:
			if (distance > 15.0)
				distance = 15.0;
			if (distance < -15.0)
				distance = -15.0;
			break;
		case bsk_high:
			if (distance > 22.5)
				distance = 22.5;
			if (distance < -22.5)
				distance = -22.5;
			break;
		case bsk_excellent:
			if (distance > 30.0)
				distance = 30.0;
			if (distance < -30.0)
				distance = -30.0;
			break;
		case bsk_supreme:
			if (distance > 37.5)
				distance = 37.5;
			if (distance < -37.5)
				distance = -37.5;
			break;
	}
	player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch()
{
	TVec dir;
	TAVec ang;

	// [FB] Set pitch for underwater areas
	if (player.MO.WaterLevel > 2)
	{
		if (missile)
		{
			/*float missiledist;
		
			missiledist = botmo.DistTo(missile);
			SetAngle(AngleTo(missile.Origin));

			if (missile.Origin.z > botmo.Origin.z)
			{
				//[FB] Missile comes from over our head, move down
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw + missiledist);
			}
			else if (missile.Origin.z < botmo.Origin.z)
			{
				//[FB] Missile comes from under us, move up
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw - missiledist);
			}*/
			dir = missile.Origin - botmo.Origin;
			VectorAngles(&dir, &ang);
			botmo.Angles.pitch = -ang.pitch;

			// Look at the missile and sidestep it
			SetAngle(AngleTo(missile.Origin));
			forwardmove = -FORWARDRUN;
			return;
		}

		if (enemy)
		{
			dir = enemy.Origin - botmo.Origin;
			VectorAngles(&dir, &ang);
			botmo.Angles.pitch = -ang.pitch;
			return;
		}

		if (item)
		{
			/*float itemdist;

			itemdist = botmo.DistTo(item);

			if (item.Origin.z < botmo.Origin.z)
			{
				//[FB] Item is below us, let's go down
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw + itemdist);
			}
			else if (item.Origin.z > botmo.Origin.z)
			{
				//[FB] Item is over us, let's go up
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw - itemdist);
			}*/
			dir = item.Origin - botmo.Origin;
			VectorAngles(&dir, &ang);
			botmo.Angles.pitch = -ang.pitch;
			return;
		}

		// [FB] Follow our buddy if we're tagging along
		if (ally || (ally && !enemy))
		{
			/*float allydist;

			allydist = botmo.DistTo(ally);
		
			if (ally.Origin.z > botmo.Origin.z)
			{
				//[FB] Ally is over us, let's go down
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw + allydist);
			}
			else if (ally.Origin.z < botmo.Origin.z)
			{
				//[FB] Ally is beluw us, let's go up
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw - allydist);
			}*/
			dir = ally.Origin - botmo.Origin;
			VectorAngles(&dir, &ang);
			botmo.Angles.pitch = -ang.pitch;
			return;
		}

		if (ball)
		{
			float balldist;

			balldist = botmo.DistTo(ball);

			/*if (ball.Origin.z > botmo.Origin.z)
			{
				//[FB] Ball is over us, let's go down
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw + balldist);
			}
			else if (ball.Origin.z < botmo.Origin.z)
			{
				//[FB] Ball is below us, let's go up
				player.ViewAngles.pitch = AngleMod360(botmo.Angles.yaw - balldist);
			}*/
			dir = ball.Origin - botmo.Origin;
			VectorAngles(&dir, &ang);
			botmo.Angles.pitch = -ang.pitch;

			// [FB] We are close enough to kick the ball
			if (CheckTo(ball.Origin) && balldist <= Actor::MELEERANGE * 6.0)
			{
				botmo.Player.Buttons |= BT_USE;
			}
			return;
		}
	}
	else
	{
		if (enemy)
		{
			dir = enemy.Origin - botmo.Origin;
			VectorAngles(&dir, &ang);
			botmo.Angles.pitch = ang.pitch;
			return;
		}
	}

	botmo.Angles.pitch = 0.0;
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(Actor victim)
{
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;

	// [BC] Don't need to worry about following him anymore
	lastpos_valid = false;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(Actor killer)
{
}

//==========================================================================
//
//	BotSkill
//
//	[FB] Determine the bot skills depending the game skill
//
//==========================================================================

int BotSkill()
{
	if(player.Level.Game.gameskill == sk_nightmare)
	{
		return 4;
	}
	else if(player.Level.Game.gameskill == sk_hard)
	{
		return 3;
	}
	else if(player.Level.Game.gameskill == sk_medium)
	{
		return 2;
	}
	else if(player.Level.Game.gameskill == sk_easy)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay()
{
	int bottype;
	botinfo_t *binfo;
	int i;

	if (strcmp(player.PlayerName, ""))
	{
		for (i = 0; i < MainGameInfo::NUMTOTALBOTS; i++)
		{
			if (!stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % MainGameInfo::NUMBOTTYPES;
	}

	binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];

	t_strafe = 1.0;

	MainGameInfo(player.Level.Game).botskill = BotSkill();

	if (MainGameInfo(player.Level.Game).botskill > 4)
		MainGameInfo(player.Level.Game).botskill = 4;
	if (MainGameInfo(player.Level.Game).botskill < 0)
		MainGameInfo(player.Level.Game).botskill = 0;

	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - MainGameInfo(player.Level.Game).botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - MainGameInfo(player.Level.Game).botskill);
	info.evade = SkillLower(binfo->evade, 4 - MainGameInfo(player.Level.Game).botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - MainGameInfo(player.Level.Game).botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - MainGameInfo(player.Level.Game).botskill);
	player.UserInfo = binfo->userinfo;
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn()
{
	enemy = none;
	accuracy_r = false;
	intelect_r = false;
	evade_r = false;
	anticip_r = false;
}

//==========================================================================
//
//	B_AffectStat
//
//  [FB] Check if we are blind by darkness!!
//
//==========================================================================

void B_AffectStat()
{
	if (!accuracy_r)
	{
		old_accuracy = info.accuracy;
		accuracy_r = true;
	}
	if (!intelect_r)
	{
		old_intelect = info.intelect;
		intelect_r = true;
	}
	if (!evade_r)
	{
		old_evade = info.evade;
		evade_r = true;
	}
	if (!anticip_r)
	{
		old_anticip = info.anticip;
		anticip_r = true;
	}
	if (accuracy_r && player.BlindCount <= 50)
	{
		if (info.accuracy)
			info.accuracy--;
		// [FB] Make sure this stat isn't zero
		else if (info.accuracy < 0)
			info.accuracy = 0;
	}
	else if (intelect_r && (player.BlindCount > 50 && player.BlindCount <= 100))
	{
		if (info.intelect)
			info.intelect--;
		else if (info.intelect < 0)
			info.intelect = 0;
	}
	else if (evade_r && (player.BlindCount > 100 && player.BlindCount <= 150))
	{
		if (info.evade)
			info.evade--;
		else if (info.evade < 0)
			info.evade = 0;
	}
	else if (anticip_r && (player.BlindCount > 150 && player.BlindCount <= 200))
	{
		if (info.anticip)
			info.anticip--;
		else if (info.anticip < 0)
			info.anticip = 0;
	}
}

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//==========================================================================

void BotTick(float deltaTime)
{
	botmo = Actor(player.MO);

	player.ForwardMove = 0.0;
	player.SideMove = 0.0;
	player.FlyMove = 0.0;
	player.Buttons = 0;

	// Don't do anything if we're talking
//	if (B_Chat())
//		return;

	// We're dead, so hit space to respawn
	if (botmo.Health <= 0 && player.respawn_counter <= 0.0)
	{
		player.Buttons |= BT_USE;
		return;
	}

	// [FB] Apply blind status
	if(player.BlindCount)
		B_AffectStat();
	else if (player.BlindCount <= 0)
	{
		//[FB] Darkness effects faded out, now restore everything back!
		if (anticip_r)
		{
			info.anticip = old_anticip;
			anticip_r = false;
		}
		if (evade_r)
		{
			info.evade = old_evade;
			evade_r = false;
		}
		if (intelect_r)
		{
			info.intelect = old_intelect;
			intelect_r = false;
		}
		if (accuracy_r)
		{
			info.accuracy = old_accuracy;
			accuracy_r = false;
		}
	}

	// Periodically let out some anger
	if (!(player.Level.XLevel.Time == 255.0))
	{
		if (angerlevel)
			angerlevel--;
		else if (angerlevel < 0)
			angerlevel = 0;
	}

	// [FB] Set an ally if we're in a mode that has one...
	if (((MainGameInfo(player.Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM ||
			MainGameInfo(player.Level.Game).GameType == HexenDefs::game_sweep) || 
			MainGameInfo(player.Level.Game).GameModel) && !ally)
	{
		ally = B_SetAlly();
		// [FB] ...and decide what action we'll take
		if (MainGameInfo(player.Level.Game).GameType != HexenDefs::game_dmteam)
			SetAction();
	}
	else
		ally = none;

	// [FB] Tag with our allies
	if (ally || (ally && !enemy))
	{
		Ally_Tag(deltaTime);
	}

	// Weed out any bad destinations/enemies
	CheckStuff();

	// Destination setting...
	SetEnemy();
	Scan();

	// Turning towards destination...
	BotAim();
	Turn();
	Attack();
	Move(deltaTime);

	Pitch();

	// Only walk if we're on skill 0
	if (!MainGameInfo(player.Level.Game).botskill || player.Level.Game.gameskill == sk_baby)
	{
		if (forwardmove == FORWARDRUN)
			forwardmove = FORWARDWALK;
		if (forwardmove == -FORWARDRUN)
			forwardmove = -FORWARDWALK;
		if (sidemove == SIDERUN)
			sidemove = SIDEWALK;
		if (sidemove == -SIDERUN)
			sidemove = -SIDEWALK;
	}

	player.SideMove = sidemove;
	player.ForwardMove = forwardmove;

	t_react -= deltaTime;
	if (t_react <= 0.0)
	{
		t_react = 0.0;
	}
	t_anticip -= deltaTime;
	if (t_anticip <= 0.0)
	{
		t_anticip = 0.0;
	}
}

defaultproperties
{
}
