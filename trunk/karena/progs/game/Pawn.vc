//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Pawn : Actor
	abstract;

bool bCheckNoMonsters;		// Don't spawn if monsters are disabled

float StepSpeed;

// If >0, the target will be chased
// no matter what (even if shot)
int Threshold;

// Player number last looked for.
int LastLook;

// Movement direction, movement generation (zig-zagging).
int MoveDir;	// 0-7
int MoveCount;	// when 0, select a new dir

bool bInstantRanged;	// [CW] TRUE if pawn's ranged fire do not spawn any missiles, but
						// damages target directly (by using Damage, LineAttack etc)
//[CW] PawnName index is used for deathmessages and such
// (text strings themselves are members of MainGameInfo).
int pawnname;

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t * mthing)
{
	if (bCheckNoMonsters && Level.Game.nomonsters)
	{
		Remove();
		return;
	}
	if (Level.Game.gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	LastLook = P_Random() % MAXPLAYERS;

	::OnMapSpawn(mthing);
}

//==========================================================================
//
//	Activate
//
//==========================================================================

bool Activate()
{
	// Monster
	if (bDormant)
	{
		bDormant = false;
		StateTime = 0.1;
		return true;
	}
	return false;
}

//==========================================================================
//
//	Deactivate
//
//==========================================================================

bool Deactivate()
{
	// Monster
	if (!bDormant)
	{
		bDormant = true;
		StateTime = -1.0;
		return true;
	}
	return false;
}

//==========================================================================
//
//  SpawnMissile
//
//  Returns NULL if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

Actor SpawnMissile(Actor dest, class<Actor> type)
{
	Actor th;
	TVec org;
	TVec dir;

	org = Origin;
	if (type == MinotaurMissile)
	{
		// Minotaur swing attack missile
		org.z = Origin.z + 40.0;
	}
	else if (type == MinotaurFloorFire1)
	{
		// Minotaur floor fire missile
		org.z = ONFLOORZ + FloorClip;
	}
	else if (type == CentaurMissile)
	{
		org.z = Origin.z + 45.0;
	}
	else if (type == IceGuyMissile)
	{
		org.z = Origin.z + 40.0;
	}
	else if (type == HolyMissile)
	{
		org.z = Origin.z + 40.0;
	}
	else
	{
		org.z = Origin.z + 32.0;
	}
	org.z -= FloorClip;
	th = Spawn(type, org);
	if (th.SightSound)
	{
		th.PlaySound(th.SightSound, CHAN_VOICE);
	}
	th.Instigator = self;	// Originator
	dir = dest.Origin - Origin;
	if (dest.Alpha < 1.0)
	{
		// Invisible target
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0);
	}
	dir = Normalise(dir);
	th.Velocity = dir * th.Speed;
	VectorAngles(&dir, &th.Angles);
	return th.CheckMissileSpawn() ? th : none;
}

//==========================================================================
//
//  SpawnMissileXYZ
//
//  Returns NULL if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

Actor SpawnMissileXYZ(TVec org, Actor dest, class<Actor> type)
{
	TVec dir;
	Actor th;

	org.z -= FloorClip;
	th = Spawn(type, org);
	if (th.SightSound)
	{
		th.PlaySound(th.SightSound, CHAN_VOICE);
	}
	th.Instigator = self;	// Originator
	dir = dest.Origin - Origin;
	if (dest.Alpha < 1.0)
	{
		// Invisible target
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0);
	}
	dir = Normalise(dir);
	th.Velocity = dir * th.Speed;
	VectorAngles(&dir, &th.Angles);
	return th.CheckMissileSpawn() ? th : none;
}

//==========================================================================
//
//  CheckMeleeRange
//
//==========================================================================

bool CheckMeleeRange()
{
	float dist;

	if (!Enemy)
	{
		return false;
	}
	dist = DistTo(Enemy);
	if (dist >= MELEERANGE)
	{
		return false;
	}
	if (!CanSee(Enemy))
	{
		return false;
	}
	if (Enemy.Origin.z > Origin.z + Height)
	{
		// Enemy is higher than the attacker
		return false;
	}
	else if (Origin.z > Enemy.Origin.z + Enemy.Height)
	{
		// Attacker is higher
		return false;
	}
	return true;
}

//==========================================================================
//
//  CheckMeleeRange2
//
//==========================================================================

bool CheckMeleeRange2()
{
	float dist;

	if (!Enemy)
	{
		return false;
	}
	dist = DistTo(Enemy);
	if (dist >= MELEERANGE * 2.0 || dist < MELEERANGE)
	{
		return false;
	}
	if (!CanSee(Enemy))
	{
		return false;
	}
	if (Enemy.Origin.z > Origin.z + Height)
	{
		// Enemy is higher than the attacker
		return false;
	}
	else if (Origin.z > Enemy.Origin.z + Enemy.Height)
	{
		// Attacker is higher
		return false;
	}
	return true;
}

//==========================================================================
//
//  CheckMissileRange
//
//==========================================================================

bool CheckMissileRange()
{
	float dist;

	if (!CanSee(Enemy))
	{
		return false;
	}
	if (bJustHit)
	{
		// The target just hit the enemy, so fight back!
		bJustHit = false;
		return true;
	}
	if (ReactionCount)
	{
		// Don't attack yet
		return false;
	}
	dist = DistTo(Enemy) - 64.0;
	if (!MeleeState)
	{
		// No melee attack, so fire more frequently
		dist -= 128.0;
	}
	if (dist > 200.0)
	{
		dist = 200.0;
	}
	if (Random() * 256.0 < dist)
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  FaceMovementDirection
//
//==========================================================================

void FaceMovementDirection()
{
	switch (MoveDir)
	{
	case DI_EAST:
		Angles.yaw = 0.0;
		break;
	case DI_NORTHEAST:
		Angles.yaw = 45.0;
		break;
	case DI_NORTH:
		Angles.yaw = 90.0;
		break;
	case DI_NORTHWEST:
		Angles.yaw = 135.0;
		break;
	case DI_WEST:
		Angles.yaw = 180.0;
		break;
	case DI_SOUTHWEST:
		Angles.yaw = 225.0;
		break;
	case DI_SOUTH:
		Angles.yaw = 270.0;
		break;
	case DI_SOUTHEAST:
		Angles.yaw = 315.0;
		break;
	}
}

//============================================================================
//
//  LookForMonsters
//
//============================================================================

bool LookForMonsters()
{
	int count;
	Actor mo;

	if (!Level.Game.Players[0].MO.CanSee(self))
	{
		// Player can't see monster
		return false;
	}
	count = 0;
	FOREACH(Actor, mo)
	{
		if (!mo.bCountKill || (mo == self) || (mo.Health <= 0))
		{
			// Not a valid monster
			continue;
		}
		if (DistTo(mo) > MONS_LOOK_RANGE)
		{
			// Out of range
			continue;
		}
		if (P_Random() < 16)
		{
			// Skip
			continue;
		}
		if (count++ > MONS_LOOK_LIMIT)
		{
			// Stop searching
			return false;
		}
		if (!CanSee(mo))
		{
			// Out of sight
			continue;
		}
		if (Class == Minotaur)
		{
			if ((mo.Class == Minotaur) && (mo.Enemy != Instigator))
			{
				continue;
			}
		}
		// Found a target monster
		Enemy = mo;
		return true;
	}
	return false;
}

//============================================================================
//
//  LookForPlayers
//
//  If allaround is false, only look 180 degrees in front
//  returns true if a player is targeted
//
//============================================================================

bool LookForPlayers(bool allaround)
{
	int c;
	int stop;
	Player P;
	float an;
	float dist;

	if (!Level.Game.netgame && Level.Game.Players[0] && Level.Game.Players[0].bSpawned && Level.Game.Players[0].Health <= 0)
	{
		// Single player game and player is dead, look for monsters
		return LookForMonsters();
	}
	c = 0;
	stop = (LastLook - 1) & (MAXPLAYERS - 1);
	for (;; LastLook = (LastLook + 1) & (MAXPLAYERS - 1))
	{
		if (LastLook == stop)
			return false;	// done looking

		if (!Level.Game.Players[LastLook])
			continue;

		if (c++ == 2)
			return false;	// done looking

		P = Player(Level.Game.Players[LastLook]);
		if (!P.bSpawned || !P.MO)
			continue;	//  not spawned yet
		if (P.Health <= 0)
			continue;	// dead
		if (!CanSee(P.MO))
			continue;	// out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(P.MO.Origin.y - Origin.y,
				P.MO.Origin.x - Origin.x) - Angles.yaw);
			if (an > 90.0 && an < 270.0)
			{
				dist = DistTo(P.MO);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}
		if (P.MO.Alpha < 1.0)
		{
			// Player is invisible
			if (DistTo(P.MO) > 2.0 * MELEERANGE &&
				Length(P.MO.Velocity) < 5.0 * 35.0)
			{
				// Player is sneaking - can't detect
				return false;
			}
			if (P_Random() < 225)
			{
				// Player isn't sneaking, but still didn't detect
				return false;
			}
		}
		if (Class == Minotaur)
		{
			if (Instigator == P.MO)
			{
				continue;	// Don't target master
			}
		}
		Enemy = Actor(P.MO);
		return true;
	}
	return false;
}

//==========================================================================
//
//  StepMove
//
//  Move in the current direction, returns false if the move is blocked.
//
//==========================================================================

bool StepMove()
{
	float tryx, deltax, origx;
	float tryy, deltay, origy;
	float maxmove;
	int steps;
	float xspeed;
	float yspeed;
	int i;
	bool try_ok;

	line_t *ld;
	int good;

	if (bBlasted)
		return true;
	if (MoveDir == DI_NODIR)
		return false;

#ifdef RANGECHECK
	if (MoveDir >= 8 || MoveDir < 0)
		Error("Weird actor->MoveDir!");
#endif

	origx = Origin.x;
	origy = Origin.y;
	deltax = StepSpeed * MainGameInfo(Level.Game).xspeed[MoveDir];
	deltay = StepSpeed * MainGameInfo(Level.Game).yspeed[MoveDir];
	tryx = origx + deltax;
	tryy = origy + deltay;

	// Like P_XYMovement this should do multiple moves if the step size is too large
	maxmove = Radius;
	steps = 1;

	if (maxmove > 0.0)
	{ 
		xspeed = fabs(deltax);
		yspeed = fabs(deltay);

		if (xspeed > yspeed)
		{
			if (xspeed > maxmove)
			{
				steps = 1 + ftoi(xspeed / maxmove);
			}
		}
		else
		{
			if (yspeed > maxmove)
			{
				steps = 1 + ftoi(yspeed / maxmove);
			}
		}
	}

	try_ok = true;
	tmtrace_t tmtrace;
	for(i=1; i < steps; i++)
	{
		try_ok = TryMoveEx(&tmtrace, vector(origx + (deltax / itof(steps * i)), origy +
					(deltay / itof(steps * i)), Origin.z));
		if (!try_ok)
			break;
	}

	// killough 3/15/98: don't jump over dropoffs:
	if (try_ok)
		try_ok = TryMoveEx(&tmtrace, vector(tryx, tryy, Origin.z));

	if (!try_ok)
	{
		// open any specials
		if (bFloat && tmtrace.bFloatOk)
		{
			// must adjust height
			if (Origin.z < tmtrace.FloorZ)
				Origin.z += FLOATSPEED * Level.Game.frametime;
			else
				Origin.z -= FLOATSPEED * Level.Game.frametime;

			// Check to make sure there's nothing in the way of the float
			if(TestMobjZ())
			{
				bInFloat = true;
				return true;
			}
		}

		if (!tmtrace.NumSpecHit)
			return false;

		MoveDir = DI_NODIR;
		// if the special is not a door that can be opened, return false
		//
		// killough 8/9/98: this is what caused monsters to get stuck in
		// doortracks, because it thought that the monster freed itself
		// by opening a door, even if it was moving towards the doortrack,
		// and not the door itself.
		//
		// killough 9/9/98: If a line blocking the monster is activated,
		// return true 90% of the time. If a line blocking the monster is
		// not activated, but some other line is, return false 90% of the
		// time. A bit of randomness is needed to ensure it's free from
		// lockups, but for most cases, it returns the correct result.
		//
		// Do NOT simply return false 1/4th of the time (causes monsters to
		// back out when they shouldn't, and creates secondary stickiness).

		good = 0;
		while (tmtrace.NumSpecHit--)
		{
			ld = tmtrace.SpecHit[tmtrace.NumSpecHit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (HexenLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_USE) ||
			    (bActivatePushWall && HexenLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_PUSH)))
			{
				good |= ld == tmtrace.BlockingLine ? 1 : 2;//true;
			}
		}
		return good && ((Random() >= 203.0) ^ (good & 1));
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat)
	{
		if (Origin.z > FloorZ)
		{
			HitFloorType();
		}
		Origin.z = FloorZ;
	}
	return true;
}

//==========================================================================
//
//  TryWalk
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

bool TryWalk()
{
	if (!StepMove())
	{
		return false;
	}
	MoveCount = P_Random() & 15;
	return true;
}

//============================================================================
//
//  DO_NewChaseDir
//
//============================================================================

void DO_NewChaseDir(float deltax, float deltay)
{
	int d[3];
	int tdir, olddir, turnaround;

	olddir = MoveDir;
	turnaround = MainGameInfo(Level.Game).opposite[olddir];

	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;
	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		MoveDir = MainGameInfo(Level.Game).diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (MoveDir != turnaround && TryWalk())
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		MoveDir = d[1];
		if (TryWalk())
			return;	/*either moved forward or attacked */
	}

	if (d[2] != DI_NODIR)
	{
		MoveDir = d[2];
		if (TryWalk())
			return;
	}

	/* there is no direct path to the player, so pick another direction */

	if (olddir != DI_NODIR)
	{
		MoveDir = olddir;
		if (TryWalk())
			return;
	}

	if (P_Random() & 1)	/*randomly determine direction of search */
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir >= DI_EAST; tdir--)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		MoveDir = turnaround;
		if (TryWalk())
			return;
	}

	MoveDir = DI_NODIR;	// can't move
}

//=============================================================================
//
// NewChaseDir
//
// killough 9/8/98: Split into two functions
//
//=============================================================================

void NewChaseDir()
{
	float deltax;
	float deltay;

	deltax = Enemy.Origin.x - Origin.x;
	deltay = Enemy.Origin.y - Origin.y;

	if(!Enemy)
		Error("NewChaseDir: called with no Enemy");

	tmtrace_t tmtrace;
	CheckRelPosition(&tmtrace, Origin);

	// Try to move away from a dropoff
	if (FloorZ - tmtrace.DropOffZ > MaxDropoffHeight &&
		Origin.z <= FloorZ && !bDropOff && !bOnMobj && !bFloat)
	{
		avoiddropoff_t a;
		// We call CheckDropoff here to determine if the
		// bounding box actually needs to be used below
		CheckDropOff(&a);

		if (a.deltax || a.deltay)
		{
			// [Graf Zahl] I have changed P_TryMove to only apply this logic when
			// being called from here. bAvoidingDropoff activates the code that
			// allows monsters to move away from a dropoff. This is different from
			// MBF which requires unconditional use of the altered logic and therefore
			// forcing a massive change in the monster behavior to use this.

			// use different dropoff movement logic in P_TryMove
			bAvoidingDropoff = true;
			DO_NewChaseDir(a.deltax, a.deltay);
			bAvoidingDropoff = false;
		
			// If moving away from dropoff, set movecount to 1 so that
			// small steps are taken to get monster away from dropoff.
			MoveCount = 1;
			return;
		}
	}
	DO_NewChaseDir(deltax, deltay);
}

//==========================================================================
//
//  A_Look
//
//  Stay in state until a player is sighted
//
//==========================================================================

final void A_Look()
{
	Actor targ;

	Threshold = 0;	// any shot will wake up
	targ = Actor(Sector->SoundTarget);

	if (targ && targ.bShootable)
	{
		Enemy = targ;

		if (bAmbush)
		{
			if (!CanSee(Enemy))
			{
				if (!LookForPlayers(false))
					return;
			}
		}
	}
	else
	{
		if (!LookForPlayers(false))
			return;
	}

	// go into chase state
	if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	SetState(SeeState);
}

//==========================================================================
//
//  A_Chase
//
//  Actor has a melee attack, so it tries to close as fast as possible
//
//==========================================================================

final void A_Chase()
{
	float delta;

	if (ReactionCount)
	{
		ReactionCount--;
	}

	// modify target threshold
	if (Threshold)
	{
		if (!Enemy || Enemy.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (Level.Game.fastparm)
	{
		// Monsters move faster in nightmare mode
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	// turn towards movement direction if not there yet
	if (MoveDir < 8)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (!Enemy || !Enemy.bShootable)
	{
		// look for a new target
		if (LookForPlayers(true))
		{
			return;	// got a new target
		}
		SetState(IdleState);
		return;
	}

	// do not attack twice in a row
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm)
		{
			NewChaseDir();
		}
		return;
	}

	// check for melee attack
	if (MeleeState && CheckMeleeRange())
	{
		if (AttackSound)
		{
			PlaySound(AttackSound, CHAN_WEAPON);
		}
		SetState(MeleeState);
		return;
	}

	// check for missile attack
	if (MissileState)
	{
		if (Level.Game.fastparm || !MoveCount)
		{
			if (CheckMissileRange())
			{
				SetState(MissileState);
				bJustAttacked = true;
				return;
			}
		}
	}

	// possibly choose another target
	if (Level.Game.netgame && !Threshold)
	{
		if (!CanSee(Enemy))
		{
			if (LookForPlayers(true))
				return;	// got a new target
		}
	}

	// chase towards player
	if (--MoveCount < 0 || !StepMove())
	{
		NewChaseDir();
	}

	// make active sound
	if (ActiveSound && P_Random() < 3)
	{
		if (Class == Bishop && P_Random() < 128)
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
		else if (Class == Pig)
		{
			PlaySound((P_Random() & 1) ? 'PigActive2' :
				'PigActive1', CHAN_VOICE);
		}
		else if (bBoss)
		{
			PlaySound(ActiveSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(ActiveSound, CHAN_VOICE);
		}
	}
}

//==========================================================================
//
//  A_FaceTarget
//
//==========================================================================

final void A_FaceTarget()
{
	if (!Enemy)
		return;

	bAmbush = false;

	Angles.yaw = atan2(Enemy.Origin.y - Origin.y,
		Enemy.Origin.x - Origin.x);

	if (Enemy.Alpha < 1.0)
	{
		Angles.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
}

//============================================================================
//
//	A_FreezeDeath
//
//============================================================================

final void A_FreezeDeath()
{
	StateTime = 2.0 + Random() * 8.0 + Random() * 8.0;
	bSolid = true;
	bShootable = true;
	bNoBlood = true;
	bPushable = true;
	bTelestomp = true;
	bSlide = true;
	bNoPassMobj = false;
	Height *= 4.0;
	PlaySound('FreezeDeath', CHAN_VOICE);

	if (bIsPlayer)
	{
		Player(Player).DamageFlash = 0.0;
		Player(Player).PoisonCount = 0;
		Player(Player).BonusFlash = 0.0;
	}
	else
	{
		if (bCountKill && Special)
		{
			// Initiate monster death actions
			Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
				Args[3], Args[4], NULL, 0, self);
		}
	}
}

//============================================================================
//
//  A_FreezeDeathChunks
//
//============================================================================

final void A_FreezeDeathChunks()
{
	int i;
	Actor A;

	MSG_Select(MSG_SV_DATAGRAM);
	MSG_WriteByte(HexenDefs::svc_chunks);
	MSG_WriteShort(ftoi(Origin.x));
	MSG_WriteShort(ftoi(Origin.y));
	MSG_WriteShort(ftoi(Origin.z + Height * 0.5));

	if (Length(Velocity) > 1.0)
	{
		StateTime = 3.0;
		return;
	}
	PlaySound('FreezeShatter', CHAN_VOICE);

	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		switch (P_Random() % 3)
		{
		case 0: A.SetState(IceChunk::S_ICECHUNK1); break;
		case 1: A.SetState(IceChunk::S_ICECHUNK2); break;
		case 2: A.SetState(IceChunk::S_ICECHUNK3); break;
		}
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	for (i = 12 + (P_Random() & 15); i >= 0; i--)
	{
		A = Spawn(IceChunk, Origin + vector(
			(Random() - 0.5) * 2.0 * Radius,
			(Random() - 0.5) * 2.0 * Radius,
			Random() * Height));
		switch (P_Random() % 3)
		{
		case 0: A.SetState(IceChunk::S_ICECHUNK1); break;
		case 1: A.SetState(IceChunk::S_ICECHUNK2); break;
		case 2: A.SetState(IceChunk::S_ICECHUNK3); break;
		}
		if (A)
		{
			A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
			A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
			A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
			IceChunk(A).A_IceSetTics();	// set a random tic wait
		}
	}
	if (bIsPlayer)
	{
		// attach the player's view to a chunk of ice
		A = Spawn(IceChunkHead, Origin + vector(0.0, 0.0, PlayerPawn(self).ViewHeight /*Player::VIEWHEIGHT*/));
		A.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
		A.Velocity.z = (A.Origin.z - Origin.z) / Height * 4.0 * 35.0;
		A.Player = Player;
		A.bIsPlayer = true;
		Player = none;
		bIsPlayer = false;
		A.Health = Health;
		A.Angles.yaw = Angles.yaw;
		A.Player.MO = A;
		A.Angles.pitch = 0.0;
	}
	RemoveFromTIDList();
	SetState(S_FREETARGMOBJ);
	bHidden = true;
}

defaultproperties
{
	bSolid = true;
	bShootable = true;
	bCountKill = true;
	bFloorClip = true;
	bTelestomp = true;
	bActivatePushWall = true;
	bActivateMCross = true;
	bCheckNoMonsters = true;
}
