//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**		##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: template.vc 508 2006-07-10 19:02:43Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class GameFootball : Game;

enum
{
	state_preparematch,
	state_kickoff,
	state_freeplay,
	state_finished,
	state_waitforplayerspawn
};

enum
{
	event_goal,
	event_offside
};

enum
{
	object_ballspot,
	object_playerspot,
	object_ball
};

SoccerBall	Ball;
MapSpot		spot_ball;
struct spot_players_t
{
	MapSpot	ms[MAXPLAYERS];
};
spot_players_t spot_players[2];
PlayerTeam	Teams[2];


//==========================================================================
//
//	BeginState
//
//	ACS callable
//
//==========================================================================

void BeginState(int newstate)
{
	int i;

	switch(newstate)
	{
	case state_preparematch:
		//UpdateTeams();
		if (!Teams[0] && !Teams[1])
		{
			State = -1;
			return;
		}
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Teams[0] && Teams[0].Players[i])
			   Teams[0].Players[i].UpdateScore(HexenDefs::scoreevent_PlayerReset);
			if (Teams[1] && Teams[1].Players[i])
			   Teams[1].Players[i].UpdateScore(HexenDefs::scoreevent_PlayerReset);
		}
		if (Teams[0])
			Teams[0].UpdateScore(HexenDefs::scoreevent_TeamReset);
		if (Teams[1])
			Teams[1].UpdateScore(HexenDefs::scoreevent_TeamReset);
		EndCurrentState(state_kickoff);
		return;
	case state_kickoff:
		if (spot_ball)
		{ 
			if (Ball)
				Ball.Teleport(spot_ball.Origin, spot_ball.Angles.yaw, true, true, false);
			else
				Ball = SoccerBall(HexenLevelInfo(Level).Spawn(SoccerBall, spot_ball.Origin));
		}
		if (!spot_ball && !Ball)
		{
			dprint("GameFootball::BeginState : state_kickoff : there's no ball or ball_spot");
			EndCurrentState(state_finished);
			return;
		}
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Teams[0] && Teams[0].Players[i] && spot_players[0].ms[i])
			   Actor(Teams[0].Players[i].MO).Teleport(spot_players[0].ms[i].Origin, spot_players[0].ms[i].Angles.yaw, true, true, false);
			if (Teams[1] && Teams[1].Players[i] && spot_players[1].ms[i])
			   Actor(Teams[1].Players[i].MO).Teleport(spot_players[1].ms[i].Origin, spot_players[1].ms[i].Angles.yaw, true, true, false);
		}
		EndCurrentState(state_freeplay);
		return;
	case state_freeplay:
	case state_finished:
	case state_waitforplayerspawn:
		break;
	};

	State = newstate;
}

//==========================================================================
//
//	EndCurrentState
//
//	ACS callable
//
//==========================================================================

void EndCurrentState(int nextstate)
{
	// FIXME! - destroy ball only if it was spawned by GameFootball
	/*if (nextstate == state_finished && Ball)
		Ball.Destroy();*/

	BeginState(nextstate);
}

//==========================================================================
//
//	NotifyUpdateTeams
//
//==========================================================================

void NotifyUpdateTeams()
{
	//[CW] Actually (and hypothetically) more than 2 teams may
	//     participate in game, but that's the question of future updates
	//     (if there'll be any).

	bool playingteamschange = false;
	if (State >= 0 && (Teams[0] != Game.Teams[0] ||
								Teams[1] != Game.Teams[1]))
	{
		playingteamschange = true;
	}
	Teams[0] = Game.Teams[0];
	Teams[1] = Game.Teams[1];
	if (playingteamschange)
		EndCurrentState(state_waitforplayerspawn);
}

//==========================================================================
//
//	NotifyPlayerSpawn
//
//==========================================================================

void NotifyPlayerSpawn(Player pl)
{
	if (State == state_waitforplayerspawn)
		EndCurrentState(state_preparematch);
}

//==========================================================================
//
//	HandleGameEvent
//
//	ACS callable
//
//==========================================================================

void HandleGameEvent(Actor A, int Event, int arg1, int arg2, int arg3, int arg4)
{
	switch (Event)
	{
	case event_goal:
		if (!A || A != Ball)
			break;
		// arg1 is a team, in which gates a ball was thrown
		if (arg1 >= 0 && arg1 < 2 && Teams[arg1])
		{
			if (Ball.Owner && Teams[arg1] == Ball.Owner.Team)
			{
				// 'self-goal'
				Ball.Owner.UpdateScore(HexenDefs::scoreevent_FtbSelfGoal);
				// opponent team is getting aware of happening
				// (in case special score should be provided for it)
				if (arg1 && Teams[0])
				   Teams[0].UpdateScore(HexenDefs::scoreevent_FtbOpSelfGoal);
				else if (!arg1 && Teams[1])
				   Teams[1].UpdateScore(HexenDefs::scoreevent_FtbOpSelfGoal);
				Game.bcentreprint(va("YAHOO! Team %d kicked a ball into their own gates!", arg1));
			}
			else
			{
				// normal goal
				if (Ball.Owner)
				{
					Ball.Owner.UpdateScore(HexenDefs::scoreevent_FtbGoal);
					Game.bcentreprint(va("WHOA! Team %d scores a goal!", arg1 ? 0 : 1));
				}
			}
		}
		EndCurrentState(state_kickoff);
		break;
	case event_offside:

		//[CW] continue from kickoff maybe??
		// need timer here though, since there should be delay
		// before players are repositioned

		break;
	}
}

//==========================================================================
//
//	SetGameObject
//
//	ACS callable
//
//==========================================================================

void SetGameObject(Actor A, int object, int arg1, int arg2, int arg3)
{
	if ((object == object_ballspot || object == object_playerspot) &&
			!A.IsA('MapSpot'))
	{
		dprint("GameFootball::SetGameObject : A is not of MapSpot class");
		return;
	}

	switch (object)
	{
	case object_ballspot:
		spot_ball = MapSpot(A);
		break;
	case object_playerspot:
		if (arg1 >= 0 && arg1 < 2 && arg2 >= 0 && arg2 < MAXPLAYERS)
			spot_players[arg1].ms[arg2] = MapSpot(A);
		else
			dprint("GameFootball::SetGameObject : bad argument(s) for playerspot");
		break;
	case object_ball:
		if (!A.IsA('SoccerBall'))
		{
			dprint("GameFootball::SetGameObject : A is not of Ball class");
			return;
		}
		Ball = SoccerBall(A);
	}
}

//==========================================================================
//
//	End
//
//==========================================================================

void End()
{
	EndCurrentState(state_finished);
	::End();
}

defaultproperties
{
}
