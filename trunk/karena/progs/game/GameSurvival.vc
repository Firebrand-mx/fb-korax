//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**	        ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id: GameSurvival.vc 508 2006-07-10 19:02:43Z firebrand_kh $
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class GameSurvival : KArenaGameModel;

enum
{
	state_preparegame,
	state_countdownsequence,
	state_wave
};

enum
{
	event_wavestart		= GameModel::event_custom,
	event_waveend,
	event_countdown,
	event_wavespawn,
	num_survivalevents	= event_wavespawn - GameModel::event_custom + 1
};

acsnotifier_t	AcsNotifiersSurvival[num_survivalevents];

// monster classes in the order of growing difficulty
array< name > MonsterClasses; 		// array of monster class names
array< name > BossClasses;			// array of monster boss class names

int Wave;
int LoLimit;						// lower index in monster array
int HiLimit;						// higher index in monster array
int BoostedLimit;					// highest index in monster array that allows spawning of boosted versions of monsters
int CountToSpawnMonsters;			// how many monsters to spawn
int CountToSpawnBosses;				// how many bosses to spawn
int CountMonstersAtOnce;			// how many monsters & bosses can be on the level at the same time

GameSequencer		countdownSequencer;
int					countDown;
GameSequencer		waveSequencer;

//==========================================================================
//
//	AllowedTeams
//
//==========================================================================

int AllowedTeams()
{
	return 1;
}

//==========================================================================
//
//	AllowAllies
//
//==========================================================================

int AllowAllies()
{
	return true;
}

//==========================================================================
//
//	BeginState
//
//	ACS callable
//
//==========================================================================

void BeginState(int newstate)
{
	dprint("GameSurvival::BeginState : %i", newstate);

	switch(newstate)
	{
	case state_preparegame:
		Wave = -1;
		EndCurrentState(state_countdownsequence);
		return;

	case state_countdownsequence:
		SetUpWave();
		//
		// Setup countdown sequence
		countDown = 10;
		countdownSequencer = Level.Spawn(GameSequencer);
		if (countdownSequencer)
		{
			countdownSequencer.time_limit = 1.0;
			countdownSequencer.event_id = event_countdown;
		}
		break;

	case state_wave:
		waveSequencer = Level.Spawn(GameSequencer);
		if (waveSequencer)
		{
			waveSequencer.time_limit = 1.0;
			waveSequencer.event_id = event_wavespawn;
		}
		HandleEvent(event_wavestart, none, 0, 0, 0, 0);
		break;
	};

	State = newstate;
}

//==========================================================================
//
//	EndCurrentState
//
//	ACS callable
//
//==========================================================================

void EndCurrentState(int nextstate)
{
	int i;

	switch (State)
	{
	case state_wave:
		waveSequencer.Destroy();
		waveSequencer = none;
		//
		// Kill all existing monsters, just in case
		Level.P_Massacre();
		//
		// Ressurect killed players
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Players[i] && Game.Players[i].MO && Game.Players[i].MO.Class == PlayerSpectator)
			{
				Game.Players[i].PlayerState = PST_REBORN;
				Game.Players[i].NetGameReborn();
			}
		}
		HandleEvent(event_waveend, none, 0, 0, 0, 0);
		break;

	case state_countdownsequence:
		countdownSequencer.Destroy();
		countdownSequencer = none;
		break;
	}

	::EndCurrentState(nextstate);
}

//==========================================================================
//
//	IsInPlayableState
//
//==========================================================================

bool IsInPlayableState()
{
	return State > state_preparegame;
}

//==========================================================================
//
//	TeamFactor
//
//==========================================================================

int TeamFactor(EntityEx a1, EntityEx a2)
{
	return teamfactor_coop;
}

//==========================================================================
//
//	OnActorDeath
//
//==========================================================================

void OnActorDeath(Actor a, EntityEx source)
{
	if (!a.bMonster)
	{
		return;
	}

	int mleft = (Level.TotalKills - Level.CurrentKills) + CountToSpawnMonsters + CountToSpawnBosses;
	if (mleft > 0 && mleft <= 10)
	{
		Game.BroadcastLocalSoundNamed('misc/chat', true, 0.0);
		Game.bcentreprint(va("%i monsters left!", (Level.TotalKills - Level.CurrentKills) + CountToSpawnMonsters + CountToSpawnBosses));
	}

	if (!mleft)
	{
		EndCurrentState(state_countdownsequence);
	}
}

//==========================================================================
//
//	OnPlayerSpawn
//
//==========================================================================

void OnPlayerSpawn(BasePlayer pl)
{
	// If the game hasn't been started yet and
	// if there're at least 1 player in game, begin gameplay
	if (State < 0)
	{
		BeginState(state_preparegame);
	}
}

//==========================================================================
//
//	OnPlayerDeath
//
//==========================================================================

void OnPlayerDeath(BasePlayer pl, EntityEx source)
{
	// When player is killed during the monster wave he becomes a
	// spectator until the end of the wave.
	if (State == state_wave)
	{
		Player(pl).bRespawnAsSpectator = true;
		Player(pl).bAllowEndSpectate = false;

		int i;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Game.Players[i] && Game.Players[i].MO && Game.Players[i].MO.Class != PlayerSpectator && Game.Players[i].MO.Health > 0)
			{
				// There are still living players around, so game should continue
				//
				return;
			}
		}

		// Too bad, all players died, end the game
		End();
	}
}

//==========================================================================
//
//	HandleEvent
//
//	ACS callable
//
//==========================================================================

void HandleEvent(int Event, EntityEx A, int arg1, int arg2, int arg3, int arg4)
{
	dprint("GameSurvival::HandleEvent : %i", Event);

	switch (Event)
	{
	case event_wavestart:
		Game.BroadcastLocalSoundNamed('BellRing', false, 0.0);
		Game.bcentreprint(va("wave %i!", Wave + 1));
		break;
	case event_waveend:
		break;
	case event_countdown:
		countDown--;
		if (!countDown)
		{
			EndCurrentState(state_wave);
		}
		else
		{
			Game.BroadcastLocalSoundNamed('ClockTick', false, 0.0);
			Game.bcentreprint(va("next wave in %i seconds", countDown));
		}
		break;
	case event_wavespawn:
		WaveSpawn();
		break;
	default:
		::HandleEvent(Event, A, arg1, arg2, arg3, arg4);
		return;
	}

	NotifyACS(Event, 0, 0, 0);
}

//==========================================================================
//
//	SetACSNotifier
//
//	ACS callable
//
//==========================================================================

void SetACSNotifier(int event, int script)
{
	if (event >= GameModel::event_custom && event < event_wavestart + num_survivalevents)
	{
		event -= GameModel::event_custom;
		AcsNotifiersSurvival[event].enabled = true;
		AcsNotifiersSurvival[event].script = script;
	}
	else
	{
		::SetACSNotifier(event, script);
	}
}

//==========================================================================
//
//	NotifyACS
//
//==========================================================================

void NotifyACS(int Event, int Arg1, int Arg2, int Arg3)
{
	dprint("GameSurvival::NotifyACS : Event = %i", Event);
	if (Event >= GameModel::event_custom && Event < event_wavestart + num_survivalevents)
	{
		Event -= GameModel::event_custom;
		if (AcsNotifiersSurvival[Event].enabled)
		{
			Level.ExecuteActionSpecial(LNSPEC_ACSExecuteAlways,
					AcsNotifiersSurvival[Event].script,
					0,
					Arg1,
					Arg2,
					Arg3,
					NULL, 0, none);
		}
	}
	else
		::NotifyACS(Event, Arg1, Arg2, Arg3);
}

//==========================================================================
//
//	SetUpWave
//
//==========================================================================

void SetUpWave()
{
	Wave++;

	// We'll divide the setting up in two phases, counts and limits :D
	// this is done so we can randomize things further depending waves

	//
	//	MONSTER COUNTS
	//
	if (Wave <= 3)
	{
		CountToSpawnMonsters = 20;
		CountToSpawnBosses = 0;
		CountMonstersAtOnce = P_Random() % 15;
	}
	else if (Wave > 3 && Wave <= 6)
	{
		CountToSpawnMonsters = 25;
		CountToSpawnBosses = 0;
		CountMonstersAtOnce = P_Random() % 15;
	}
	else if (Wave > 6 && Wave <= 9)
	{
		CountToSpawnMonsters = 25;
		CountToSpawnBosses = 1;
		CountMonstersAtOnce = P_Random() % 15;
	}
	else if (Wave > 9 && Wave <= 12)
	{
		CountToSpawnMonsters = 30;
		CountToSpawnBosses = 1;
		CountMonstersAtOnce = P_Random() % 20;
	}
	else if (Wave > 12 && Wave <= 15)
	{
		CountToSpawnMonsters = 35;
		if (Wave == 15)
			CountToSpawnBosses = 2;
		else
			CountToSpawnBosses = 1;
		CountMonstersAtOnce = P_Random() % 25;
	}
	else if (Wave > 15 && Wave <= 18)
	{
		CountToSpawnMonsters = 40;
		if (Wave == 18)
			CountToSpawnBosses = 2;
		else
			CountToSpawnBosses = 1;
		CountMonstersAtOnce = P_Random() % 25;
	}
	else if (Wave > 18 && Wave <= 21)
	{
		CountToSpawnMonsters = 45;
		if (Wave == 21)
			CountToSpawnBosses = 2;
		else
			CountToSpawnBosses = 1;
		CountMonstersAtOnce = P_Random() % 25;
	}
	else if (Wave > 21 && Wave <= 24)
	{
		CountToSpawnMonsters = 50;
		if (Wave == 24)
		{
			CountToSpawnBosses = 2;
		}
		else
		{
			CountToSpawnBosses = 1;
		}
		CountMonstersAtOnce = 25;
	}
	else if (Wave > 21 && Wave <= 24)
	{
		CountToSpawnMonsters = 55;
		if (Wave == 24)
		{
			CountToSpawnBosses = 2;
		}
		else
		{
			CountToSpawnBosses = 1;
		}
		CountMonstersAtOnce = 25;
	}
	else if (Wave > 24)
	{
		// Let's Randomize this even further!!
		CountToSpawnMonsters = 55 + P_Random() % 15;
		CountToSpawnBosses = P_Random() % 2;
		CountMonstersAtOnce = P_Random() % 25;
	}
	//
	//	MONSTER LIMITS
	//
	if (Wave <= 3)
	{
		LoLimit = 0;
		HiLimit = 3;
		if (Wave == 3)
		{
			BoostedLimit = 1;
		}
		else
		{
			BoostedLimit = -1;
		}
	}
	else if (Wave > 3 && Wave <= 6)
	{
		LoLimit = 0;
		HiLimit = 6;
		if (Wave >= 5)
		{
			BoostedLimit = P_Random() % 2;
		}
		else
		{
			BoostedLimit = 1;
		}
	}
	else if (Wave > 6 && Wave <= 9)
	{
		LoLimit = 0;
		HiLimit = 9;
		if (Wave >= 7)
		{
			BoostedLimit = 2 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 2;
		}
	}
	else if (Wave > 9 && Wave <= 12)
	{
		LoLimit = 0;
		HiLimit = 12;
		if (Wave >= 10)
		{
			BoostedLimit = 4 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 4;
		}
	}
	else if (Wave > 12 && Wave <= 15)
	{
		LoLimit = 0;
		HiLimit = 15;
		if (Wave >= 13)
		{
			BoostedLimit = 6 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 6;
		}
	}
	else if (Wave > 15 && Wave <= 18)
	{
		LoLimit = 0;
		HiLimit = 18;
		if (Wave >= 17)
		{
			BoostedLimit = 8 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 8;
		}
	}
	else if (Wave > 18 && Wave <= 21)
	{
		LoLimit = 0;
		HiLimit = 18;
		if (Wave >= 19)
		{
			BoostedLimit = 10 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 10;
		}
	}
	else if (Wave > 21 && Wave <= 24)
	{
		LoLimit = 0;
		HiLimit = 18;
		if (Wave >= 22)
		{
			BoostedLimit = 12 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 12;
		}
	}
	else if (Wave > 24 && Wave <= 27)
	{
		LoLimit = 0;
		HiLimit = 18;
		if (Wave >= 19)
		{
			BoostedLimit = 14 + P_Random() % 2;
		}
		else
		{
			BoostedLimit = 14;
		}
	}
	else if (Wave > 27)
	{
		LoLimit = 0;
		HiLimit = 18;
		BoostedLimit = 18;
	}
}

//==========================================================================
//
//	WaveSpawn
//
//==========================================================================

void WaveSpawn()
{
	int		mClass;
	class	<Actor> MClass;
	bool	bBoosted;
	int		place;
	Actor	monster;

	// If current number of monsters is equal or greater than this, no new monsters are spawned until some of older ones are killed
	if (CountToSpawnMonsters + CountToSpawnBosses > 0 && (Level.TotalKills - Level.CurrentKills) < CountMonstersAtOnce)
	{
		// If we are to spawn bosses, let's spawn them randomly
		if (CountToSpawnBosses > 0 && (!CountToSpawnMonsters || Random() < 0.25))
		{
			//
			// Spawn Boss monster
			//
			mClass = P_Random() % 6;
			MClass = class<Actor>(FindClass(BossClasses[mClass]));
			CountToSpawnBosses--;
		}
		else
		{
			//
			// Spawn normal monster
			//
			mClass = P_Random() % HiLimit;
			MClass = class<Actor>(FindClass(MonsterClasses[mClass]));

			// There's a chance to make this a boosted monster
			if (mClass <= BoostedLimit && Random() > 0.5)
			{
				bBoosted = true;
			}
			CountToSpawnMonsters--;
		}
		place = P_Random() % Level.DeathmatchStarts.Num;
		monster = Level.Spawn(MClass,,, &Level.DeathmatchStarts[place]);
		if (monster)
		{
			Level.Spawn(TeleportFog, monster.Origin);
			if (bBoosted)
			{
				// Spawn a boosted monster with enhanced stats
				float hlth = itof(monster.Health) * 1.5;
				monster.Health *= ftoi(hlth);
				monster.Speed *= monster.Speed * 1.5;
			}

			Level.NoiseAlert(Game.Players[0].MO, monster);
		}
	}
}

defaultproperties
{
	MonsterClasses.Num = 18;
	MonsterClasses[0] = 'KArenaHereticImp';
	MonsterClasses[1] = 'HereticMummy';
	MonsterClasses[2] = 'HereticImpLeader';
	MonsterClasses[3] = 'HereticMummyLeader';
	MonsterClasses[4] = 'KArenaFireDemon';
	MonsterClasses[5] = 'KArenaIceGuy';
	MonsterClasses[7] = 'KArenaCentaur';
	MonsterClasses[8] = 'KArenaDemon1';
	MonsterClasses[9] = 'KArenaDemon2';
	MonsterClasses[10] = 'KArenaCentaurLeader';
	MonsterClasses[11] = 'HereticMummyGhost';
	MonsterClasses[12] = 'HereticMummyLeaderGhost';
	MonsterClasses[13] = 'KArenaBishop';
	MonsterClasses[14] = 'Wraith';
	MonsterClasses[15] = 'KArenaCentaurMash';
	MonsterClasses[16] = 'KArenaDemon1Mash';
	MonsterClasses[17] = 'KArenaDemon2Mash';

	BossClasses.Num = 6;
	BossClasses[0] = 'KArenaDragon';
	BossClasses[1] = 'MageBoss';
	BossClasses[2] = 'FighterBoss';
	BossClasses[3] = 'ClericBoss';
	BossClasses[4] = 'Heresiarch';
	BossClasses[5] = 'Korax';
}
