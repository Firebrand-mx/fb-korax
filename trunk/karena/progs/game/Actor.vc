//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**	        ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : ScriptedEntity
	abstract;

const float MORPHTIME 		= 40.0;
const float MAULATORTIME 	= 25.0;

const float TELEFOGHEIGHT	= 32.0;

const float
	BLAST_RADIUS_DIST		= 255.0,
	BLAST_FULLSTRENGTH		= 0.0038909912,
	BLAST_SPEED				= 20.0;

//const float BONUSADD		= 0.2;

int experience;

bool bOverrideCoop;	// [CW] Override IsTeammate method by always returning false
					// currently is used as a temporary fix for targetinfo not showing for allies

// [CW] Since there are sometimes references to pawn stored for future use,
// it is important to store reference to player as well (in case it is player pawn)
// so that if that pawn die, player reference will be still accessible.
Player		PInstigator;

// [CW] Obituary; used by those who can damage directly
//		(anything from enviroment to pawns with melee attacks)
string		Obituary;


//==========================================================================
//
//	MoveToFreePosition
//
//	[CW]
//
//==========================================================================

bool MoveToFreePosition()
{
	TVec bak_org;
	float test_ang;
	TVec test_dir;
	float test_dist;

	bak_org = Origin;
	test_dir = vector(1.0, 0.0, 0.0);

	for (test_dist = 0.0; test_dist <= 512.0; test_dist += 64.0)
	{
		for (test_ang = 0.0; test_ang < 360.0; test_ang += 45.0)
		{
			VectorRotateAroundZ(&test_dir, test_ang);
			UnlinkFromWorld();
			Origin = bak_org + test_dir * test_dist;
			LinkToWorld();
			// [FB] We must check if the move is being done inside the map
			if (!CheckSides(Origin + vector((4.0 + 3.0 * (Radius) / 2.0) * cos(test_ang), (4.0 + 3.0 * (Radius) / 2.0) * sin(test_ang), ONFLOORZ)))
			{
				// [FB] OK, we are inside the map
				if (TestLocation()/*TeleportMove(bak_org + test_dir * test_dist)*/)
				{
					return true;
				}
			}

			if (test_dist == 0.0)
				break;
		}
	};

	UnlinkFromWorld();
	Origin = bak_org;
	LinkToWorld();
	return false;
}

//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================

final int HITDICE(int a)
{
	return (1 + (P_Random() & 7)) * a;
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t* mthing)
{
	//[Korax]
	if (!bMissile && !bPickUp && Class != PlayerPig)
	{
		experience = default.Health;
	}
	::OnMapSpawn(mthing);
}

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	// Remove from creature queue
	if (bMonster && bCorpse)
	{
		A_DeQueueCorpse();
	}

	::Destroyed();
}

//==========================================================================
//
//  FloorBounceActor
//
//  [FB] New variant for soccer ball
//
//==========================================================================

void FloorBounceActor()
{
	Velocity.z = Velocity.z * -0.7;
	Velocity.x = 2.0 * Velocity.x / 3.0;
	Velocity.y = 2.0 * Velocity.y / 3.0;
	if (SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}
}


//==========================================================================
//
//  Thrust3d
//
//	[CW] A three-dimensional vector variant of Thrust, that
//		 uses vector angles and single vector length.
//
//==========================================================================

void Thrust3d(float angle2d, float angle3, float move)
{
	Thrust(angle2d, move * cos(angle3));
	Velocity.z += move * sin(angle3) * 35.0;
}

//==========================================================================
//
//  Thrust3d2
//
//	[CW] Variant of Thrust3d, that allows explicit definition
//	     of horizontal and vertical velocities.
//
//==========================================================================

void Thrust3d2(float angle2d, float move2d, float move3)
{
	Thrust(angle2d, move2d);
	Velocity.z += move3 * 35.0;
}

//==========================================================================
//
//	Kill
//
//==========================================================================

void Kill(optional EntityEx inflictor, optional EntityEx source, optional bool bXDeath, optional name DamageType)
{
	Damage(inflictor, source, bXDeath ? Health - GibsHealth + 1 : Health + 1,
		specified_DamageType ? DamageType : 'InstantKill');
}

//==========================================================================
//
//  Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
	::Died(source, inflictor);

	if (inflictor && ClassIsChildOf(inflictor.Class, Actor))
		Actor(inflictor).IsDeathInflictor(self);

//[Korax]
	if (source && !bIsPlayer)
	{
		if (!source.bIsPlayer)
		{
			Actor(source).experience += ftoi(itof(experience) * ((90.0 + 
				itof(P_Random()) / 255.0 * 21.0) / 100.0));  //RPG
		}
		else
		{
			Player(source.Player).GiveExperience(ftoi(itof(experience) * ((90.0 + 
				itof(P_Random()) / 255.0 * 21.0) / 100.0) * (Level.Game.gameskill < 2 ? 
				125.0 : (Level.Game.gameskill < 3 ? 100.0 : 80.0)) / 100.0));
		}
	}
//[Korax]
	// [FB] Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}
}

//==========================================================================
//
//  IsDeathInflictor
//
//	[CW]
//
//==========================================================================

void IsDeathInflictor(EntityEx victim)
{
}

//==========================================================================
//
//	IsTeammate
//
//==========================================================================

bool IsTeammate(EntityEx Other)
{
	if (bOverrideCoop)
		return false;

	if (::IsTeammate(Other))
	{
		return true;
	}
	if (bIsPlayer && Other.bIsPlayer)
	{
		if (MainGameInfo(Level.Game).GameModel &&
			MainGameInfo(Level.Game).GameModel.TeamFactor(self, Other) ==
			GameModel::teamfactor_coop)
		{
			return true;
		}
		if ((MainGameInfo(Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM ||
			MainGameInfo(Level.Game).bIsCoopGame[MainGameInfo(Level.Game).GameType]) &&
			Player(Player).Team == Player(Other.Player).Team)
		{
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//	KilledByPlayer
//
//==========================================================================

void KilledByPlayer(EntityEx source)
{
	bool bKilledByAlly = false;
	if (source)
	{
		bKilledByAlly = IsTeammate(source);
	}

	// [FB] Increase the player's KillCount
	if (bMonster)
	{
		//[CW] update player's score
		Player(source.Player).UpdateScore(HexenDefs::scoreevent_Kill);

		//[CW] update kill trophies
		Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_killsatonce, 1);
		Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_killsrow, 1);
	}

	// Check for frag changes
	if (bIsPlayer)
	{
		if (source.Player.bIsBot)
		{
			Player(source.Player).Bot.Killed(self);
		}

		if (Player.bIsBot)
		{
			Player(Player).Bot.Died(Actor(source));
		}

		if (self == source)
		{
			// Self-frag
			Player.Frags--;

			Player(Player).UpdateScore(HexenDefs::scoreevent_SelfFrag);
		}
		else
		{
			int se = bKilledByAlly ? HexenDefs::scoreevent_TeamFrag : HexenDefs::scoreevent_Frag;

			if (bKilledByAlly)
			{
				source.Player.Frags--;
			}
			else
			{
				source.Player.Frags++;
				Player(source.Player).GiveExperience(500 * Player(Player).exp_level / Player(source.Player).exp_level);
			}

			if (MainGameInfo(Level.Game).GameModel)
				se = MainGameInfo(Level.Game).GameModel.GetFragScoreEvent(Player(source.Player), Player(self.Player));

			Player(source.Player).UpdateScore(se);

			//[CW] update frag trophies
			if (!bKilledByAlly)
			{
				Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_fragsatonce, 1);
				Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_fragsrow, 1);
			}
		}
	}
}

//==========================================================================
//
//	PlayerKilled
//
//==========================================================================

void PlayerKilled(EntityEx source, EntityEx inflictor)
{
	//[CW] process obituary
	Player(Player).DisplayObituary(inflictor, source, DamageType);
	Player(Player).Deaths++;

	//[CW] Show scoreboard for died player
	Player(Player).Scoreboard(true);

	if (Player(Player).Morph.bMorphed)
		Player(Player).bRecalculateLevelOnRespawn = true;

	// Player death
	if (!source)
	{
		// Fragged by enviroment
		Player.Frags--;
	}

	//[CW] notify advanced game mode
	if (MainGameInfo(Level.Game).GameModel)
		MainGameInfo(Level.Game).GameModel.NotifyPlayerDeath(Player(Player), source);

	Player(Player).SetFOV(HexenDefs::DEFAULT_FOV);
}

//==========================================================================
//
//  HeresiarchMorphPlayer
//
//  [CW] Morph player into... err... something
//
//==========================================================================

bool HeresiarchMorphPlayer(int pclass, class<Actor> moclass, bool timed,
	bool until_death)
{
	Actor fog;
	Actor beastMo;
	int i;
	int bak_level;

	if (bInvulnerable)
	{
		// Immune when invulnerable
		return false;
	}
	if (Player(Player).Morph.bMorphed)
	{
		// Player is already a beast
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('Teleport', CHAN_VOICE);

	beastMo = Spawn(moclass, Origin);
	beastMo.Tracer = Player(Player).ReadyWeapon;
	beastMo.Angles = Angles;
	beastMo.Player = Player;
	beastMo.bIsPlayer = true;
	Player.Health = beastMo.Health;
	Player.MO = beastMo;
	Player.Camera = beastMo;
	BasicArmor BArmor = BasicArmor(FindInventory(BasicArmor));
	BArmor.Amount = 0;
	Player.PClass = pclass;
	beastMo.bFly = bFly;
	Player(Player).Morph.bMorphed = true;
	Player(Player).Morph.bTimer = timed;
	Player(Player).Morph.bUntilDeath = until_death;
	if (timed)
		Player(Player).Morph.MorphTime = Player::MORPHTIME;
	Player(Player).ActivateMorphWeapon();

	// [CW] If morphed player cannot move from current position try to find more appropriate position or him
	if (!Actor(Player.MO).TryMove(Origin))
	{
		Actor(Player.MO).MoveToFreePosition();
	}
	else
	{
		fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
		fog.PlaySound('Teleport', CHAN_VOICE);
	}

	// [CW] Recalc attributes based on the new player's body
	bak_level = Player(Player).exp_level;
	Player(Player).InitiateLevel();
	Player(Player).ActivateLevel(bak_level, false);

	SetState(FindState('FreeTargMobj'));

	return true;
}

//==========================================================================
//
//  PoisonPlayer - Sets up all data concerning poisoning
//
//==========================================================================

final void PoisonPlayer(Actor poisoner, int poison)
{
	if (!Player)
		Error("Actor::PoisonPlayer : Player reference not set to an instance of an object");

	if ((Player(Player).Cheats & Player::CF_GODMODE) || bInvulnerable)
	{
		return;
	}
	Player(Player).PoisonCount += poison;
	if (poisoner)
		Player(Player).Poisoner = Player(poisoner.Player);
	if (Player(Player).PoisonCount > 100)
	{
		Player(Player).PoisonCount = 100;
	}
	Player(Player).LastPoisonTime = XLevel.Time;
}

//==========================================================================
//
//  PoisonDamage
//
//  Similar to Actor::Damage
//
//==========================================================================

final void PoisonDamage(Actor inflictor, Actor source, int damage, bool playPainSound)
{
	//Actor inflictor;

	//inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
		bInvulnerable))
	{
		return;
	}
	Player.Health -= damage;	// mirror mobj health here for Dave
	if (Player.Health < 0)
	{
		Player.Health = 0;
	}
	Player(Player).Attacker = source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (bIsPlayer && inflictor && Player(Player).PClass != HexenDefs::PCLASS_PIG)
		{
			// Check for flame death
			if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
			{
				DamageType = 'Fire';
			}
			else
			{
				DamageType = inflictor.DamageType;
			}
		}
		DamageType = 'Poison';
		Died(source, inflictor);
		return;
	}
	if (!(XLevel.TicTime & 63) && playPainSound)
	{
		SetState(FindState('Pain'));
	}
}

//==========================================================================
//
//  BlindPlayer
//
//  [FB] Similar to Actor::Damage
//
//==========================================================================

void BlindPlayer(Actor blinder, int blind)
{
	if ((Player(Player).Cheats & Player::CF_GODMODE) || bInvulnerable)
	{
		return;
	}
	Player(Player).BlindCount += blind;
	if (blinder)
		Player(Player).Blinder = Player(blinder.Player);
	if (Player(Player).BlindCount > 220)
	{
		Player(Player).BlindCount = 220;
	}
	Player(Player).LastBlindTime = XLevel.Time;
}

//==========================================================================
//
//  BlindDamage
//
//==========================================================================

void BlindDamage(Actor source, int damage, bool playPainSound)
{
	Actor inflictor;

	inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
		bInvulnerable))
	{
		return;
	}
	Player.Health -= damage;	// mirror mobj health here for Dave
	if (Player.Health < 0)
	{
		Player.Health = 0;
	}
	Player(Player).Attacker = source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (bIsPlayer && inflictor && Player(Player).PClass != HexenDefs::PCLASS_PIG)
		{
			// Check for flame death
			if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
			{
				DamageType = 'Fire';
			}
			else
			{
				DamageType = inflictor.DamageType;
			}
		}
		DamageType = 'Blind';
		Died(source, inflictor);
		return;
	}
	if (playPainSound)
	{
		SetState(FindState('Pain'));
	}
}

//==========================================================================
//
//  SpawnCombatAttributes
//
//==========================================================================

void SpawnCombatAttributes(Actor master, Thinker shooter)
{
	if (master.IsA('PlayerPawn'))
	{
		Target = master;
		PInstigator = Player(Target.Player);
	}
	else
	{
		Target = master.Target;
		PInstigator = master.PInstigator;
	}

	if (!Target)
		Error("Actor::SpawnCombatAttributes : Target reference is not set to an object; bad algorythm?");
	
	if (shooter)
	{
		if (shooter.IsA('KArenaWeapon'))
			Obituary = KArenaWeapon(shooter).RangedObituary;
		else if (shooter.IsA('Pawn'))
			Obituary = Pawn(shooter).RangedObituary;
		else if (shooter.IsA('Actor'))
			Obituary = Actor(shooter).Obituary;
	}
}

//==========================================================================
//
//  Spawn_2
//
//==========================================================================

Actor Spawn_2(Thinker shooter, class<Thinker> Type, optional TVec AOrigin,
	optional TAVec AAngles, optional mthing_t* mthing)
{
	Actor A;
	if (specified_mthing)
		A = Actor(Spawn(Type, AOrigin, AAngles, mthing));
	else if (specified_AAngles)
		A = Actor(Spawn(Type, AOrigin, AAngles));
	else if (specified_AOrigin)
		A = Actor(Spawn(Type, AOrigin));
	else
		A = Actor(Spawn(Type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnMissileAngles_2
//
//==========================================================================

Actor SpawnMissileAngles_2(Thinker shooter, class<EntityEx> type, float yaw, float pitch,
	optional float SpawnHeight)
{
	Actor A;
	if (specified_SpawnHeight)
		A = Actor(SpawnMissileAngles(type, yaw, pitch, SpawnHeight));
	else
		A = Actor(SpawnMissileAngles(type, yaw, pitch));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissile_2
//
//==========================================================================

Actor SpawnPlayerMissile_2(Thinker shooter, class<EntityEx> type)
{
	Actor A = Actor(SpawnPlayerMissile(type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileAngle_2
//
//==========================================================================

Actor SpawnPlayerMissileAngle_2(Thinker shooter, class<EntityEx> type, float angle)
{
	Actor A = Actor(SpawnPlayerMissileAngle(type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//===========================================================================
//
//  SpawnPlayerMissileAngleXYZ_2
//
//===========================================================================

Actor SpawnPlayerMissileAngleXYZ_2(Thinker shooter, TVec org, class<EntityEx> type,
	float angle)
{
	Actor A = Actor(SpawnPlayerMissileAngleXYZ(org, type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileEx_2
//
//==========================================================================

Actor SpawnPlayerMissileEx_2(Thinker shooter, class<EntityEx> type, bool RetExploded,
	out EntityEx AimTarget, optional float angle, optional TVec SpawnOrg)
{
	Actor A;
	if (specified_SpawnOrg)
		A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle, SpawnOrg));
	else if (specified_angle)
		A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle));
	else
		A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================

final void SpawnDirt(float radius)
{
	float angle;
	TVec org;
	class<Actor> dtype;
	Actor dirt;

	angle = 360.0 * Random();
	org.x = Origin.x + radius * cos(angle);
	org.y = Origin.y + radius * sin(angle);
	org.z = Origin.z + Random() * 2.0 + 1.0;
	switch (P_Random() % 6)
	{
	case 0:
		dtype = Dirt1;
		break;
	case 1:
		dtype = Dirt2;
		break;
	case 2:
		dtype = Dirt3;
		break;
	case 3:
		dtype = Dirt4;
		break;
	case 4:
		dtype = Dirt5;
		break;
	case 5:
		dtype = Dirt6;
		break;
	}
	dirt = Spawn(dtype, org);
	if (dirt)
	{
		dirt.Velocity.z = Random() * 4.0 * 35.0;
	}
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

final TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//==========================================================================
//
//	CanReach
//
//  Checks whether this Actor can pass to target directly
//	(along the straight line).
//	TargetEntity is optional.
//
//==========================================================================

bool CanReach(TVec TargetPos, optional EntityEx TargetEntity,
			  // [CW] use these three to override default passability calculations
			  optional float MaxPassableStep,
			  optional float MaxPassableDropOff,
			  optional float MinPassableOpening,
			  optional bool bCanUseLines)
{
	bool canreach;
	ReachTraverse::reach_traverse_data_t CRTRData;

	if (!specified_TargetEntity)
		TargetEntity = none;

	if (!specified_MaxPassableStep)
		MaxPassableStep = MaxStepHeight;
	if (!specified_MaxPassableDropOff)
		MaxPassableDropOff = MaxDropoffHeight;
	if (!specified_MinPassableOpening)
		MinPassableOpening = Height;
	
	canreach = DoCanReachPathTraverse(TargetPos, &CRTRData,
		MaxPassableStep, MaxPassableDropOff, MinPassableOpening, bCanUseLines);
	
	if (!CRTRData.intercepted_once && XLevel.PointInSector(Origin) != XLevel.PointInSector(TargetPos))
		return false;
	
	if (canreach && TargetEntity)
	{
	//
	// [CW] CHECKME ---
	//
	//	if (CRTRData.linetarget != TargetEntity)
	//		return false;

		//
		// [CW] TODO!! --- no 3d floors support here
		//
		// [CW] prev_sector is now the last sector met

		if (TargetEntity.Origin.z > CRTRData.prev_sector->floorheight + MaxPassableStep)
			return false;		// [CW] target thing is too high to reach
		if (TargetEntity.Origin.z < CRTRData.prev_sector->floorheight)
			return false;		// [CW] target thing is under the floor
	}

	return canreach;
}

//==========================================================================
//
//	PTR_CanReachTraverse
//
// [CW] TODO!! --- no 3d floors support here
//
//==========================================================================

bool DoCanReachPathTraverse(TVec TargetPos,
							ReachTraverse::reach_traverse_data_t * pCRTRData,
							float MaxPassableStep,
							float MaxPassableDropOff,
							float MinPassableOpening,
							bool bCanUseLines)
{
	intercept_t * in;
	pCRTRData->intercepted_once = false;
	pCRTRData->prev_sector = Sector;

	foreach PathTraverse(in, Origin.x, Origin.y, TargetPos.x, TargetPos.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		pCRTRData->intercepted_once = true;

		if (in->bIsALine)
		{
			sector_t * p_sector;

			// single-sided lines abort traverse
			if (!(in->line->flags & ML_TWOSIDED) || (in->line->flags & ML_BLOCKING) ||
					!in->line->backsector)
				return false;


			// in case of two-sided lines a passability check is made
			if (in->line->frontsector == pCRTRData->prev_sector)
				p_sector = in->line->backsector;
			else if (in->line->backsector == pCRTRData->prev_sector)
				p_sector = in->line->frontsector;
			else
				// something was really messed up		
				return false;

			if (p_sector->floorheight > pCRTRData->prev_sector->floorheight + MaxPassableStep)
				// will stuck in high floor
				return false;
			if (p_sector->floorheight < pCRTRData->prev_sector->floorheight - MaxPassableDropOff)
				// must avoid dropoffs
				return false;
			if (p_sector->ceilingheight < pCRTRData->prev_sector->floorheight + MinPassableOpening ||
				p_sector->floorheight + MinPassableOpening > pCRTRData->prev_sector->ceilingheight)
				// will stuck in low ceiling...
				return false;

			pCRTRData->prev_sector = p_sector;
		}
		else
		{
			// TODO: check this precisely...
			pCRTRData->linetarget = Actor(in->Thing);
		}
	}

	return true;
}

//===========================================================================
//
//	PlayerIsMorphed
//
//===========================================================================

bool PlayerIsMorphed()
{
//	return Player(Player).PClass == HexenDefs::PCLASS_PIG;
	// [FB] This one seems to fix the random crashes
	return self.Class == PlayerPig;
}

//==========================================================================
//
//	GetBaseViewHeight
//
//==========================================================================

float GetBaseViewHeight()
{
	return PlayerPawn(self).ViewHeight;
}

//============================================================================
//
//  A_PlayerScream
//
//============================================================================

final void A_PlayerScream()
{
	// Handle the different player death screams
	if (Velocity.z <= -39.0 * 35.0)
	{
		// Falling splat
		PlaySound('*splat', CHAN_VOICE);
	}
	else if (Health > -50)
	{
		// Normal death sound
		PlaySound('*death', CHAN_VOICE);
	}
	else if (Health > -100)
	{
		// Crazy death sound
		PlaySound('*crazydeath', CHAN_VOICE);
	}
	else
	{
		// Extreme death sound
		PlaySound('*xdeath', CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_AddPlayerCorpse
//
//==========================================================================

final void A_AddPlayerCorpse()
{
	int n = HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo(Level).BodyQueSize;
	if (HexenLevelInfo(Level).bodyqueslot >= HexenLevelInfo(Level).BodyQueSize)
	{
		// Too many player corpses - remove an old one
		if (HexenLevelInfo(Level).bodyque[n])
			HexenLevelInfo(Level).bodyque[n].Destroy();
	}
	HexenLevelInfo(Level).bodyque[n] = self;
	Translation = XLevel.SetBodyQueueTrans(n, Translation);
	HexenLevelInfo(Level).bodyqueslot++;
}

//============================================================================
//
//  A_CheckBurnGone
//
//============================================================================

final void A_CheckBurnGone()
{
	if (Special2 == 666)
	{
		SetState(FindState('BurnGone'));
	}
}

//==========================================================================
//
//  A_QueueCorpse
//
//  Throw another corpse on the queue.
//
//==========================================================================

final void A_QueueCorpse()
{
	EntityEx corpse;

	if (HexenLevelInfo(Level).corpseQueueSlot >= HexenLevelInfo(Level).CorpseQueSize)
	{
		// Too many corpses - remove an old one
		corpse = HexenLevelInfo(Level).corpseQueue[HexenLevelInfo(Level).corpseQueueSlot % HexenLevelInfo(Level).CorpseQueSize];
		if (corpse)
			corpse.Destroy();
	}
	HexenLevelInfo(Level).corpseQueue[HexenLevelInfo(Level).corpseQueueSlot % HexenLevelInfo(Level).CorpseQueSize] = self;
	HexenLevelInfo(Level).corpseQueueSlot++;
}

//============================================================================
//
//  A_DeQueueCorpse
//
//  Remove a mobj from the queue (for resurrection)
//
//============================================================================

final void A_DeQueueCorpse()
{
	int slot;

	for (slot = 0; slot < HexenLevelInfo(Level).CorpseQueSize; slot++)
	{
		if (HexenLevelInfo(Level).corpseQueue[slot] == self)
		{
			HexenLevelInfo(Level).corpseQueue[slot] = none;
			break;
		}
	}
}

//==========================================================================
//
//  A_PigPain
//
//==========================================================================

final void A_PigPain()
{
	A_Pain();
	if (Origin.z <= FloorZ)
	{
		Velocity.z = 3.5 * 35.0;
	}
}

//==========================================================================
//
//	A_PlayerBurnScream
//
//==========================================================================

final void A_PlayerBurnScream()
{
	PlaySound('*burndeath', CHAN_VOICE);
}

//==========================================================================
//
//	A_GetNearestEntity
//
//==========================================================================

final EntityEx A_GetNearestEntity(class<EntityEx> EClass, optional bool bReachable)
{
	EntityEx EE;
	EntityEx ee;
	float dist = -1.0;

	foreach AllThinkers(EClass, ee)
	{
		if (dist < 0.0 || Length(ee.Origin - Origin) < dist)
		{
			if (bReachable && !CanReach(ee.Origin))
				continue;
			EE = ee;
			dist = Length(ee.Origin - Origin);
		}
	}

	return EE;
}

//==========================================================================
//
//  Blast
//
//==========================================================================

final void Blast(Actor victim, Actor source, float strength)
{
	float angle;
	float ang;
	Actor A;
	float x;
	float y;
	float z;

	angle = atan2(victim.Origin.y - source.Origin.y,
		victim.Origin.x - source.Origin.x);
	if (strength < BLAST_FULLSTRENGTH)
	{
		victim.Velocity.x = strength * cos(angle) * 35.0;
		victim.Velocity.y = strength * sin(angle) * 35.0;
		if (victim.bIsPlayer)
		{
			// Players handled automatically
		}
		else
		{
			victim.bSlide = true;
			victim.bBlasted = true;
		}
	}
	else	// full strength blast from artifact
	{
		if (victim.bMissile)
		{
			if (SorcererBall(victim))
			{
				// don't blast sorcerer balls
				return;
			}
			else if (MageStaffFX2(victim) || InfernalHandFX(victim))
			{
				// Reflect to originator
				victim.Tracer = victim.Target;
				victim.Target = source;
			}
		}
		if (victim.Class == HolyFX)
		{
			if (victim.Tracer == source)
			{
				victim.Tracer = victim.Target;
				victim.Target = source;
			}
		}
		victim.Velocity.x = BLAST_SPEED * cos(angle) * 35.0;
		victim.Velocity.y = BLAST_SPEED * sin(angle) * 35.0;

		// Spawn blast puff
		ang = atan2(source.Origin.y - victim.Origin.y,
			source.Origin.x - victim.Origin.x);
		x = victim.Origin.x + (victim.Radius + 1.0) * cos(ang);
		y = victim.Origin.y + (victim.Radius + 1.0) * sin(ang);
		z = victim.Origin.z - victim.FloorClip + victim.Height / 2.0;
		A = Level.Spawn(BlastEffect, vector(x, y, z));
		if (A)
		{
			A.Velocity.x = victim.Velocity.x;
			A.Velocity.y = victim.Velocity.y;
		}

		if (victim.bMissile)
		{
			victim.Velocity.z = 8.0 * 35.0;
			A.Velocity.z = victim.Velocity.z;
		}
		else
		{
			victim.Velocity.z = 1000.0 / victim.Mass * 35.0;
		}
		if (victim.bIsPlayer)
		{
			// Players handled automatically
		}
		else
		{
			victim.bSlide = true;
			victim.bBlasted = true;
		}
	}
}

//==========================================================================
//
//  BlastRadius
//
//==========================================================================

final void BlastRadius(optional int Limit)
{
	Actor mo;
	float dist;
	int blasts = 0;

	PlaySound('BlastRadius', CHAN_ITEM);
	HexenLevelInfo(Level).NoiseAlert(self, self);

	foreach AllThinkers(Actor, mo)
	{
		if ((mo == self) || mo.bBoss)
		{
			// Not a valid monster
			continue;
		}
		if (mo.Class == BlastRadiusBomb ||
			mo.Class == BlastRadiusMissile)
		{
			continue;
		}
		if ((mo.Class == PoisonCloud) ||	// poison cloud
			(mo.Class == HolyFX) ||		// holy fx
			mo.bIceCorpse)			// frozen corpse
		{
			// Let these special cases go
		}
		else if (mo.bMonster && (mo.Health <= 0))
		{
			continue;
		}
		else if (!mo.bMonster && !mo.bIsPlayer && !mo.bMissile)
		{
			// Must be monster, player, or missile
			continue;
		}
		if (mo.bDormant)
		{
			continue;	// no dormant creatures
		}
		if ((mo.Class == WraithBuried) && mo.bHidden)
		{
			continue;	// no underground wraiths
		}
		if ((mo.Class == WaterSplashBase) || (mo.Class == WaterSplash))
		{
			continue;
		}
		if (mo.Class == Serpent || mo.Class == SerpentLeader)
		{
			continue;
		}
		dist = DistTo(mo);
		if (dist > BLAST_RADIUS_DIST)
		{
			// Out of range
			continue;
		}
		Blast(mo, self, BLAST_FULLSTRENGTH);

		blasts++;
		if (specified_Limit && blasts >= Limit)
			break;
	}
}

states
{
Crunch:
	GIBS A -1
	Stop
}

defaultproperties
{
	SoundClass = 'fighter';
	CrunchSound = '*splat';
}
