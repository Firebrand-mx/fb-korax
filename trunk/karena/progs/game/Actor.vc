//**************************************************************************
//**
//**	    ##   ##   ####   ######     ##    ##     ##
//**	    ##  ##   ##  ##  ##   ##  ##  ##   ### ###
//**	    ## ##   ##    ## ##   ## ##    ##   #####
//**	    ######  ##    ## #####   ########   #####
//**	    ## ###   ##  ##  ######  ##    ##  ### ###
//**	    ##   ##   ####   ##  ### ##    ## ##     ##
//**
//**	        ##    ######    ##### ###   ##    ##
//**	      ##  ##  ##   ##  #####  ####  ##  ##  ##
//**	     ##    ## ##   ## ##      ##### ## ##    ##
//**	     ######## #####   #####   ## ##### ########
//**	     ##    ## ######  ##      ##  #### ##    ##
//**	     ##    ## ##  ###  #####  ##   ### ##    ##
//**
//**    $Id$
//**
//**    Copyright (C) 2004-2006 Korax Heritage Team
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : ScriptedEntity
	abstract;

const float MORPHTIME 		= 40.0;
const float MAULATORTIME 	= 25.0;

const float TELEFOGHEIGHT	= 32.0;

const float BONUSADD		= 0.2;

int experience;

// [CW] Since there are sometimes references to pawn stored for future use,
// it is important to store reference to player as well (in case it is player pawn)
// so that if that pawn die, player reference will be still accessible.
Player		PInstigator;

// [CW] Obituary; used by those who can damage directly
//		(anything from enviroment to pawns with melee attacks)
string		Obituary;


//==========================================================================
//
//	MoveToFreePosition
//
//	[CW]
//
//==========================================================================

bool MoveToFreePosition()
{
	TVec bak_org;
	float test_ang;
	TVec test_dir;
	float test_dist;

	bak_org = Origin;
	test_dir = vector(1.0, 0.0, 0.0);

	for (test_dist = 0.0; test_dist <= 512.0; test_dist += 64.0)
	{
		for (test_ang = 0.0; test_ang < 360.0; test_ang += 45.0)
		{
			VectorRotateAroundZ(&test_dir, test_ang);
			UnlinkFromWorld();
			Origin = bak_org + test_dir * test_dist;
			LinkToWorld();
			// [FB] We must check if the move is being done inside the map
			if (!CheckSides(Origin + vector((4.0 + 3.0 * (Radius) / 2.0) * cos(test_ang), (4.0 + 3.0 * (Radius) / 2.0) * sin(test_ang), ONFLOORZ)))
			{
				// [FB] OK, we are inside the map
				if (TestLocation()/*TeleportMove(bak_org + test_dir * test_dist)*/)
				{
					return true;
				}
			}

			if (test_dist == 0.0)
				break;
		}
	};

	UnlinkFromWorld();
	Origin = bak_org;
	LinkToWorld();
	return false;
}

//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================

final int HITDICE(int a)
{
	return (1 + (P_Random() & 7)) * a;
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t* mthing)
{
	//[Korax]
	if (!bMissile && !bPickUp && Class != PlayerPig)
	{
		experience = default.Health;
	}
	::OnMapSpawn(mthing);
}

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	// Remove from creature queue
	if (bMonster && bCorpse)
	{
		A_DeQueueCorpse();
	}

	::Destroyed();
}

//==========================================================================
//
//  FloorBounceActor
//
//  [FB] New variant for soccer ball
//
//==========================================================================

void FloorBounceActor()
{
	Velocity.z = Velocity.z * -0.7;
	Velocity.x = 2.0 * Velocity.x / 3.0;
	Velocity.y = 2.0 * Velocity.y / 3.0;
	if (SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}
}


//==========================================================================
//
//  Thrust3d
//
//	[CW] A three-dimensional vector variant of Thrust, that
//		 uses vector angles and single vector length.
//
//==========================================================================

void Thrust3d(float angle2d, float angle3, float move)
{
	Thrust(angle2d, move * cos(angle3));
	Velocity.z += move * sin(angle3) * 35.0;
}

//==========================================================================
//
//  Thrust3d2
//
//	[CW] Variant of Thrust3d, that allows explicit definition
//	     of horizontal and vertical velocities.
//
//==========================================================================

void Thrust3d2(float angle2d, float move2d, float move3)
{
	Thrust(angle2d, move2d);
	Velocity.z += move3 * 35.0;
}

//==========================================================================
//
//  Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
	::Died(source, inflictor);

	if (inflictor && ClassIsChildOf(inflictor.Class, Actor))
		Actor(inflictor).IsDeathInflictor(self);

//[Korax]
	if (source && !bIsPlayer)
	{
		if (!source.bIsPlayer)
		{
			Actor(source).experience += ftoi(itof(experience) * ((90.0 + 
				itof(P_Random()) / 255.0 * 21.0) / 100.0));  //RPG
		}
		else
		{
			Player(source.Player).GiveExperience(ftoi(itof(experience) * ((90.0 + 
				itof(P_Random()) / 255.0 * 21.0) / 100.0) * (Level.Game.gameskill < 2 ? 
				125.0 : (Level.Game.gameskill < 3 ? 100.0 : 80.0)) / 100.0));
		}
	}
//[Korax]
	// [FB] Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}
}

//==========================================================================
//
//  IsDeathInflictor
//
//	[CW]
//
//==========================================================================

void IsDeathInflictor(EntityEx victim)
{
}

//==========================================================================
//
//	IsTeammate
//
//==========================================================================

bool IsTeammate(EntityEx Other)
{
	if (::IsTeammate(Other))
	{
		return true;
	}
	if (bIsPlayer && Other.bIsPlayer)
	{
		if (MainGameInfo(Level.Game).GameModel &&
			MainGameInfo(Level.Game).GameModel.TeamFactor(self, Other) ==
			GameModel::teamfactor_coop)
		{
			return true;
		}
		if ((MainGameInfo(Level.Game).GameType >= HexenDefs::NUMGAMESNOTEAM ||
			MainGameInfo(Level.Game).bIsCoopGame[MainGameInfo(Level.Game).GameType]) &&
			Player(Player).Team == Player(Other.Player).Team)
		{
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//	KilledByPlayer
//
//==========================================================================

void KilledByPlayer(EntityEx source)
{
	bool bKilledByAlly = false;
	if (source)
	{
		bKilledByAlly = IsTeammate(source);
	}

	// [FB] Increase the player's KillCount
	if (bMonster)
	{
		//[CW] update player's score
		Player(source.Player).UpdateScore(HexenDefs::scoreevent_Kill);

		//[CW] update kill trophies
		Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_killsatonce, 1);
		Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_killsrow, 1);
	}

	// Check for frag changes
	if (bIsPlayer)
	{
		if (source.Player.bIsBot)
		{
			Player(source.Player).Bot.Killed(self);
		}

		if (Player.bIsBot)
		{
			Player(Player).Bot.Died(Actor(source));
		}

		if (self == source)
		{
			// Self-frag
			Player.Frags--;

			Player(Player).UpdateScore(HexenDefs::scoreevent_SelfFrag);
		}
		else
		{
			int se = bKilledByAlly ? HexenDefs::scoreevent_TeamFrag : HexenDefs::scoreevent_Frag;

			if (bKilledByAlly)
			{
				source.Player.Frags--;
			}
			else
			{
				source.Player.Frags++;
				Player(source.Player).GiveExperience(500 * Player(Player).exp_level / Player(source.Player).exp_level);
			}

			if (MainGameInfo(Level.Game).GameModel)
				se = MainGameInfo(Level.Game).GameModel.GetFragScoreEvent(Player(source.Player), Player(self.Player));

			Player(source.Player).UpdateScore(se);

			//[CW] update frag trophies
			if (!bKilledByAlly)
			{
				Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_fragsatonce, 1);
				Player(source.Player).UpdateQueuedTrophy(HexenDefs::trophycl_fragsrow, 1);
			}
		}
	}
}

//==========================================================================
//
//	PlayerKilled
//
//==========================================================================

void PlayerKilled(EntityEx source, EntityEx inflictor)
{
	//[CW] process obituary
	Player(Player).DisplayObituary(inflictor, source, DamageType);
	Player(Player).Deaths++;

	//[CW] Show scoreboard for died player
	Player(Player).Scoreboard(true);

	if (Player(Player).Morph.bMorphed)
		Player(Player).bRecalculateLevelOnRespawn = true;

	// Player death
	if (!source)
	{
		// Fragged by enviroment
		Player.Frags--;
	}

	//[CW] notify advanced game mode
	if (MainGameInfo(Level.Game).GameModel)
		MainGameInfo(Level.Game).GameModel.NotifyPlayerDeath(Player(Player), source);

	Player(Player).SetFOV(HexenDefs::DEFAULT_FOV);
}

//==========================================================================
//
//  HeresiarchMorphPlayer
//
//  [CW] Morph player into... err... something
//
//==========================================================================

bool HeresiarchMorphPlayer(int pclass, class<Actor> moclass, bool timed,
	bool until_death)
{
	Actor fog;
	Actor beastMo;
	int i;
	int bak_level;

	if (bInvulnerable)
	{
		// Immune when invulnerable
		return (false);
	}
	if (Player(Player).Morph.bMorphed)
	{
		// Player is already a beast
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('Teleport', CHAN_VOICE);

	beastMo = Spawn(moclass, Origin);
	beastMo.Tracer = Player(Player).ReadyWeapon;
	beastMo.Angles = Angles;
	beastMo.Player = Player;
	beastMo.bIsPlayer = true;
	Player.Health = beastMo.Health;
	Player.MO = beastMo;
	Player.Camera = beastMo;
	BasicArmor BArmor = BasicArmor(FindInventory(BasicArmor));
	BArmor.Amount = 0;
	Player.PClass = pclass;
	beastMo.bFly = bFly;
	Player(Player).Morph.bMorphed = true;
	Player(Player).Morph.bTimer = timed;
	Player(Player).Morph.bUntilDeath = until_death;
	if (timed)
		Player(Player).Morph.MorphTime = Player::MORPHTIME;
	Player(Player).ActivateMorphWeapon();

	// [CW] If morphed player cannot move from current position try to find more appropriate position or him
	if (!Actor(Player.MO).TryMove(Origin))
	{
		Actor(Player.MO).MoveToFreePosition();
	}
	else
	{
		fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
		fog.PlaySound('Teleport', CHAN_VOICE);
	}

	// [CW] Recalc attributes based on the new player's body
	bak_level = Player(Player).exp_level;
	Player(Player).InitiateLevel();
	Player(Player).ActivateLevel(bak_level, false);

	SetState(FindState('FreeTargMobj'));

	return true;
}

//==========================================================================
//
//  PoisonPlayer - Sets up all data concerning poisoning
//
//==========================================================================

final void PoisonPlayer(Actor poisoner, int poison)
{
	if (!Player)
		Error("Actor::PoisonPlayer : Player reference not set to an instance of an object");

	if ((Player(Player).Cheats & Player::CF_GODMODE) || bInvulnerable)
	{
		return;
	}
	Player(Player).PoisonCount += poison;
	if (poisoner)
		Player(Player).Poisoner = Player(poisoner.Player);
	if (Player(Player).PoisonCount > 100)
	{
		Player(Player).PoisonCount = 100;
	}
	Player(Player).LastPoisonTime = XLevel.Time;
}

//==========================================================================
//
//  PoisonDamage
//
//  Similar to Actor::Damage
//
//==========================================================================

final void PoisonDamage(Actor inflictor, Actor source, int damage, bool playPainSound)
{
	//Actor inflictor;

	//inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
		bInvulnerable))
	{
		return;
	}
	Player.Health -= damage;	// mirror mobj health here for Dave
	if (Player.Health < 0)
	{
		Player.Health = 0;
	}
	Player(Player).Attacker = source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (bIsPlayer && inflictor && Player(Player).PClass != HexenDefs::PCLASS_PIG)
		{
			// Check for flame death
			if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
			{
				DamageType = 'Fire';
			}
			else
			{
				DamageType = inflictor.DamageType;
			}
		}
		DamageType = 'Poison';
		Died(source, inflictor);
		return;
	}
	if (!(XLevel.TicTime & 63) && playPainSound)
	{
		SetState(FindState('Pain'));
	}
}

//==========================================================================
//
//  BlindPlayer
//
//  [FB] Similar to Actor::Damage
//
//==========================================================================

void BlindPlayer(Actor blinder, int blind)
{
	if ((Player(Player).Cheats & Player::CF_GODMODE) || bInvulnerable)
	{
		return;
	}
	Player(Player).BlindCount += blind;
	if (blinder)
		Player(Player).Blinder = Player(blinder.Player);
	if (Player(Player).BlindCount > 220)
	{
		Player(Player).BlindCount = 220;
	}
	Player(Player).LastBlindTime = XLevel.Time;
}

//==========================================================================
//
//  BlindDamage
//
//==========================================================================

void BlindDamage(Actor source, int damage, bool playPainSound)
{
	Actor inflictor;

	inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
		bInvulnerable))
	{
		return;
	}
	Player.Health -= damage;	// mirror mobj health here for Dave
	if (Player.Health < 0)
	{
		Player.Health = 0;
	}
	Player(Player).Attacker = source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (bIsPlayer && inflictor && Player(Player).PClass != HexenDefs::PCLASS_PIG)
		{
			// Check for flame death
			if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
			{
				DamageType = 'Fire';
			}
			else
			{
				DamageType = inflictor.DamageType;
			}
		}
		DamageType = 'Blind';
		Died(source, inflictor);
		return;
	}
	if (playPainSound)
	{
		SetState(FindState('Pain'));
	}
}

//==========================================================================
//
//  SpawnCombatAttributes
//
//==========================================================================

void SpawnCombatAttributes(Actor master, Thinker shooter)
{
	Target = master;
	PInstigator = Player(master.Player);
	if (shooter)
	{
		if (shooter.IsA('KArenaWeapon'))
			Obituary = KArenaWeapon(shooter).RangedObituary;
		else if (shooter.IsA('Pawn'))
			Obituary = Pawn(shooter).RangedObituary;
		else if (shooter.IsA('Actor'))
			Obituary = Actor(shooter).Obituary;
	}
}

//==========================================================================
//
//  Spawn_2
//
//==========================================================================

Actor Spawn_2(Thinker shooter, class<Thinker> Type, optional TVec AOrigin,
	optional TAVec AAngles, optional mthing_t* mthing)
{
	TVec org = specified_AOrigin ? AOrigin : Origin;
	TAVec angles;
	if (specified_AAngles)
		angles = AAngles;
	if (!specified_mthing)
		mthing = NULL;
	Actor A = Actor(Spawn(Type, AOrigin, AAngles, mthing));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnMissileAngles_2
//
//==========================================================================

Actor SpawnMissileAngles_2(Thinker shooter, class<EntityEx> type, float yaw, float pitch,
	optional float SpawnHeight)
{
	TVec org = Origin;
	if (specified_SpawnHeight)
	{
		org.z = Origin.z + SpawnHeight;
	}
	else if (type.default.bIgnoreFloorStep)
	{
		org.z = ONFLOORZ + FloorClip;
	}
	else if (type.default.bIgnoreCeilingStep)
	{
		org.z = ONCEILINGZ;
	}
	else
	{
		org.z = Origin.z + 32.0;
	}

	Actor A = Actor(SpawnMissileAngles(type, yaw, pitch, SpawnHeight));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissile_2
//
//==========================================================================

Actor SpawnPlayerMissile_2(Thinker shooter, class<EntityEx> type)
{
	Actor A = Actor(SpawnPlayerMissile(type));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileAngle_2
//
//==========================================================================

Actor SpawnPlayerMissileAngle_2(Thinker shooter, class<EntityEx> type, float angle)
{
	Actor A = Actor(SpawnPlayerMissileAngle(type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//===========================================================================
//
//  SpawnPlayerMissileAngleXYZ_2
//
//===========================================================================

Actor SpawnPlayerMissileAngleXYZ_2(Thinker shooter, TVec org, class<EntityEx> type,
	float angle)
{
	Actor A = Actor(SpawnPlayerMissileAngleXYZ(org, type, angle));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnPlayerMissileEx_2
//
//==========================================================================

Actor SpawnPlayerMissileEx_2(Thinker shooter, class<EntityEx> type, bool RetExploded,
	out EntityEx AimTarget, optional float angle, optional TVec SpawnOrg)
{
	angle = specified_angle ? angle : 0.0;
	TVec org = specified_SpawnOrg ? SpawnOrg : Origin;
	Actor A = Actor(SpawnPlayerMissileEx(type, RetExploded, AimTarget, angle, SpawnOrg));
	if (A)
		A.SpawnCombatAttributes(self, shooter);
	return A;
}

//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================

final void SpawnDirt(float radius)
{
	float angle;
	TVec org;
	class<Actor> dtype;
	Actor dirt;

	angle = 360.0 * Random();
	org.x = Origin.x + radius * cos(angle);
	org.y = Origin.y + radius * sin(angle);
	org.z = Origin.z + Random() * 2.0 + 1.0;
	switch (P_Random() % 6)
	{
	case 0:
		dtype = Dirt1;
		break;
	case 1:
		dtype = Dirt2;
		break;
	case 2:
		dtype = Dirt3;
		break;
	case 3:
		dtype = Dirt4;
		break;
	case 4:
		dtype = Dirt5;
		break;
	case 5:
		dtype = Dirt6;
		break;
	}
	dirt = Spawn(dtype, org);
	if (dirt)
	{
		dirt.Velocity.z = Random() * 4.0 * 35.0;
	}
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

final TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//===========================================================================
//
//	PlayerIsMorphed
//
//===========================================================================

bool PlayerIsMorphed()
{
//	return Player(Player).PClass == HexenDefs::PCLASS_PIG;
	// [FB] This one seems to fix the random crashes
	return self.Class == PlayerPig;
}

//==========================================================================
//
//	GetBaseViewHeight
//
//==========================================================================

float GetBaseViewHeight()
{
	return PlayerPawn(self).ViewHeight;
}

//============================================================================
//
//  A_PlayerScream
//
//============================================================================

final void A_PlayerScream()
{
	// Handle the different player death screams
	if (Velocity.z <= -39.0 * 35.0)
	{
		// Falling splat
		PlaySound('*splat', CHAN_VOICE);
	}
	else if (Health > -50)
	{
		// Normal death sound
		PlaySound('*death', CHAN_VOICE);
	}
	else if (Health > -100)
	{
		// Crazy death sound
		PlaySound('*crazydeath', CHAN_VOICE);
	}
	else
	{
		// Extreme death sound
		PlaySound('*xdeath', CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_AddPlayerCorpse
//
//==========================================================================

final void A_AddPlayerCorpse()
{
	int n = HexenLevelInfo(Level).bodyqueslot % HexenLevelInfo(Level).BodyQueSize;
	if (HexenLevelInfo(Level).bodyqueslot >= HexenLevelInfo(Level).BodyQueSize)
	{
		// Too many player corpses - remove an old one
		if (HexenLevelInfo(Level).bodyque[n])
			HexenLevelInfo(Level).bodyque[n].Destroy();
	}
	HexenLevelInfo(Level).bodyque[n] = self;
	HexenLevelInfo(Level).bodyqueslot++;
}

//============================================================================
//
//  A_CheckBurnGone
//
//============================================================================

final void A_CheckBurnGone()
{
	if (Special2 == 666)
	{
		SetState(FindState('BurnGone'));
	}
}

//==========================================================================
//
//  A_QueueCorpse
//
//  Throw another corpse on the queue.
//
//==========================================================================

final void A_QueueCorpse()
{
	EntityEx corpse;

	if (HexenLevelInfo(Level).corpseQueueSlot >= HexenLevelInfo(Level).CorpseQueSize)
	{
		// Too many corpses - remove an old one
		corpse = HexenLevelInfo(Level).corpseQueue[HexenLevelInfo(Level).corpseQueueSlot % HexenLevelInfo(Level).CorpseQueSize];
		if (corpse)
			corpse.Destroy();
	}
	HexenLevelInfo(Level).corpseQueue[HexenLevelInfo(Level).corpseQueueSlot % HexenLevelInfo(Level).CorpseQueSize] = self;
	HexenLevelInfo(Level).corpseQueueSlot++;
}

//============================================================================
//
//  A_DeQueueCorpse
//
//  Remove a mobj from the queue (for resurrection)
//
//============================================================================

final void A_DeQueueCorpse()
{
	int slot;

	for (slot = 0; slot < HexenLevelInfo(Level).CorpseQueSize; slot++)
	{
		if (HexenLevelInfo(Level).corpseQueue[slot] == self)
		{
			HexenLevelInfo(Level).corpseQueue[slot] = none;
			break;
		}
	}
}

//==========================================================================
//
//  A_PigPain
//
//==========================================================================

final void A_PigPain()
{
	A_Pain();
	if (Origin.z <= FloorZ)
	{
		Velocity.z = 3.5 * 35.0;
	}
}

//==========================================================================
//
//	A_PlayerBurnScream
//
//==========================================================================

final void A_PlayerBurnScream()
{
	PlaySound('*burndeath', CHAN_VOICE);
}

states
{
Crunch:
	GIBS A -1
	Stop
}

defaultproperties
{
	SoundClass = 'fighter';
	CrunchSound = '*splat';
}
